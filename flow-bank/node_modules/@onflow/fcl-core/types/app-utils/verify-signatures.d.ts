import { CompositeSignature } from "@onflow/typedefs";
import { FCLContext } from "../context";
export interface AccountProofData {
    address: string;
    nonce: string;
    signatures: CompositeSignature[];
}
export interface VerifySignaturesScriptOptions {
    fclCryptoContract?: string;
}
export interface ValidateArgsInput {
    appIdentifier?: string;
    address?: string;
    nonce?: string;
    signatures?: CompositeSignature[];
    message?: string;
    compSigs?: CompositeSignature[];
}
/**
 * @description Validates input arguments for signature verification functions (both account proof and user signature verification).
 * This function performs comprehensive validation of parameters to ensure they meet the requirements for cryptographic
 * signature verification on the Flow blockchain. It handles two different validation scenarios: account proof validation
 * (when appIdentifier is provided) and user signature validation (when message is provided).
 *
 * @param args Object containing the arguments to validate. The validation behavior depends on which properties are present:
 * - For account proof validation: appIdentifier, address, nonce, and signatures are required
 * - For user signature validation: message, address, and compSigs are required
 * @param args.appIdentifier Optional unique identifier for the application (triggers account proof validation mode)
 * @param args.address Flow account address that should be exactly 16 characters (without 0x prefix)
 * @param args.nonce Hexadecimal string representing a cryptographic nonce (for account proof validation)
 * @param args.signatures Array of CompositeSignature objects for account proof validation
 * @param args.message Hexadecimal string representing the signed message (for user signature validation)
 * @param args.compSigs Array of CompositeSignature objects for user signature validation
 *
 * @returns Always returns true if validation passes, otherwise throws an error
 *
 * @throws Throws an invariant error if any validation check fails, with specific error messages for each validation failure
 *
 * @example
 * // Validate account proof arguments
 * const accountProofArgs = {
 *   appIdentifier: "MyApp",
 *   address: "1234567890abcdef",
 *   nonce: "75f8587e5bd982ec9289c5be1f9426bd",
 *   signatures: [{
 *     f_type: "CompositeSignature",
 *     f_vsn: "1.0.0",
 *     addr: "0x1234567890abcdef",
 *     keyId: 0,
 *     signature: "abc123def456..."
 *   }]
 * }
 *
 * const isValid = validateArgs(accountProofArgs) // Returns true or throws
 *
 * // Validate user signature arguments
 * const userSigArgs = {
 *   message: "48656c6c6f20576f726c64", // "Hello World" in hex
 *   address: "1234567890abcdef",
 *   compSigs: [{
 *     f_type: "CompositeSignature",
 *     f_vsn: "1.0.0",
 *     addr: "0x1234567890abcdef",
 *     keyId: 0,
 *     signature: "def456abc123..."
 *   }]
 * }
 *
 * const isValid = validateArgs(userSigArgs) // Returns true or throws
 */
export declare const validateArgs: (args: ValidateArgsInput) => boolean;
export declare function createVerifyAccountProof(context: Pick<FCLContext, "config" | "sdk">): (appIdentifier: string, { address, nonce, signatures }: AccountProofData, opts?: VerifySignaturesScriptOptions) => Promise<boolean>;
export declare function createVerifyUserSignatures(context: Pick<FCLContext, "config" | "sdk">): (message: string, compSigs: CompositeSignature[], opts?: VerifySignaturesScriptOptions) => Promise<boolean>;
export declare const verifyAccountProof: (appIdentifier: string, { address, nonce, signatures }: AccountProofData, opts?: VerifySignaturesScriptOptions) => Promise<boolean>;
export declare const verifyUserSignatures: (message: string, compSigs: CompositeSignature[], opts?: VerifySignaturesScriptOptions) => Promise<boolean>;
