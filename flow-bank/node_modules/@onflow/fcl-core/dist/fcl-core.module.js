import * as sdk from '@onflow/sdk';
import { getNetworkParameters, resolve, block, account, subscribeRaw, subscribe, decode, send, encodeMessageFromSignable, pipe, interaction, createSignableVoucher, getTransactionStatus, SubscriptionsNotSupportedError, isUnknown as isUnknown$1, getEventsAtBlockHeightRange, invariant as invariant$1, getAccount, arg, t as t$1, createSdkClient } from '@onflow/sdk';
export { TestUtils, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, createSignableVoucher, decode, flowEmulator, flowMainnet, flowTestnet, getAccount, getBlock, getBlockHeader, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getNetworkParameters, getNodeVersionInfo, getTransaction, getTransactionStatus, invariant, isBad, isOk, limit, nodeVersionInfo, param, params, payer, ping, pipe, proposer, ref, script, send, subscribe, subscribeEvents, subscribeRaw, transaction, validator, voucherIntercept, voucherToTxId, why } from '@onflow/sdk';
import * as t from '@onflow/types';
export { t };
import { invariant } from '@onflow/util-invariant';
import fetchTransport from 'cross-fetch';
import * as logger from '@onflow/util-logger';
import { log, LEVELS } from '@onflow/util-logger';
import { config, getContracts } from '@onflow/config';
export { config } from '@onflow/config';
import { withPrefix, sansPrefix } from '@onflow/util-address';
export { display, sansPrefix, withPrefix } from '@onflow/util-address';
import * as rlp from '@onflow/rlp';
import { Buffer, encode } from '@onflow/rlp';
import { FvmErrorCode, TransactionExecutionStatus, SubscriptionTopic } from '@onflow/typedefs';
export * from '@onflow/typedefs';
import { subscriber, snapshoter, spawn, UPDATED as UPDATED$2, SNAPSHOT as SNAPSHOT$1, UNSUBSCRIBE, SUBSCRIBE, INIT, send as send$1 } from '@onflow/util-actor';
import { HTTPRequestError, httpTransport } from '@onflow/transport-http';
import { grpc } from '@improbable-eng/grpc-web';
import { SHA3 } from 'sha3';
export { template as cadence, template as cdc } from '@onflow/util-template';
import * as semver from '@onflow/util-semver';
import { v4 } from 'uuid';

const VERSION = "1.21.0";

const is = type => d => typeof d === type;

/**
 * @description Checks if a value is required (not null or undefined). This is a type guard that
 * ensures the value is not null or undefined, useful for validation and filtering operations.
 *
 * @param d The value to check for null or undefined
 * @returns True if the value is not null or undefined, false otherwise
 *
 * @example
 * // Filter out null/undefined values from an array
 * import * as fcl from "@onflow/fcl"
 *
 * const values = [1, null, "hello", undefined, true]
 * const requiredValues = values.filter(fcl.isRequired)
 * console.log(requiredValues) // [1, "hello", true]
 */
const isRequired = d => d != null;

/**
 * @description Type guard that checks if a value is an object. This is useful for runtime type checking
 * and ensuring type safety when working with dynamic data.
 *
 * @param d The value to check
 * @returns True if the value is an object, false otherwise
 *
 * @example
 * // Check if a value is an object
 * import * as fcl from "@onflow/fcl"
 *
 * const obj = { name: "Flow" }
 * const notObj = "string"
 * console.log(fcl.isObject(obj)) // true
 * console.log(fcl.isObject(notObj)) // false
 */
const isObject = is("object");

/**
 * @description Type guard that checks if a value is a string. Useful for validating input types
 * and ensuring type safety in your applications.
 *
 * @param d The value to check
 * @returns True if the value is a string, false otherwise
 *
 * @example
 * // Validate string input
 * import * as fcl from "@onflow/fcl"
 *
 * const text = "Hello, Flow!"
 * const notText = 123
 * console.log(fcl.isString(text)) // true
 * console.log(fcl.isString(notText)) // false
 */
const isString = is("string");

/**
 * @description Type guard that checks if a value is a function. This is particularly useful
 * when working with callbacks, event handlers, or optional function parameters.
 *
 * @param d The value to check
 * @returns True if the value is a function, false otherwise
 *
 * @example
 * // Check if a callback is provided
 * import * as fcl from "@onflow/fcl"
 *
 * const callback = () => console.log("Hello")
 * const notCallback = "string"
 * console.log(fcl.isFunc(callback)) // true
 * console.log(fcl.isFunc(notCallback)) // false
 */
const isFunc = is("function");

/**
 * @description Type guard that checks if a value is a number. This includes both integers
 * and floating-point numbers, but excludes NaN and Infinity.
 *
 * @param d The value to check
 * @returns True if the value is a number, false otherwise
 *
 * @example
 * // Validate numeric input
 * import * as fcl from "@onflow/fcl"
 *
 * const num = 42
 * const notNum = "42"
 * console.log(fcl.isNumber(num)) // true
 * console.log(fcl.isNumber(notNum)) // false
 */
const isNumber = is("number");

/**
 * @description Normalizes function or array arguments into a standard array format for use with
 * Flow transactions and scripts. If the input is a function, it executes the function with
 * sdk.arg and types as parameters. Otherwise, returns an empty array.
 *
 * @param ax Arguments function, array, or undefined value to normalize
 * @returns Normalized array of arguments ready for use with Flow transactions/scripts
 *
 * @example
 * // Using with function-style arguments
 * const argsFn = (arg, t) => [
 *   arg("Hello", t.String),
 *   arg(42, t.Int)
 * ]
 * const normalized = normalizeArgs(argsFn)
 * // Returns: [{value: "Hello", xform: ...}, {value: 42, xform: ...}]
 */
function normalizeArgs(ax) {
  if (isFunc(ax)) return ax(sdk.arg, t);
  return [];
}

async function pre(context, type, opts) {
  // prettier-ignore
  invariant(isRequired(opts), `${type}(opts) -- opts is required`);
  // prettier-ignore
  invariant(isObject(opts), `${type}(opts) -- opts must be an object`);
  // prettier-ignore
  invariant(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`);
  // prettier-ignore
  invariant(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`);
  // // prettier-ignore
  invariant(isString(opts.cadence) || opts?.template, `${type}({ cadence }) -- cadence must be a string`);
  // prettier-ignore
  invariant(await context.config.get("accessNode.api"), `${type}(opts) -- Required value for "accessNode.api" not defined in config. See: ${"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration"}`);
}

/**
 * @description Validates and prepares options for Flow transaction execution (mutations). This function
 * performs comprehensive validation of the provided options to ensure they meet the requirements for
 * executing transactions on the Flow blockchain, including checking for required configuration values.
 *
 * @param opts Options object containing either Cadence code or template references for the transaction
 * @param opts.cadence Optional Cadence transaction code string
 * @param opts.template Optional interaction template object or reference
 * @returns Promise that resolves when validation passes
 * @throws Error if validation fails or required configuration is missing
 *
 * @example
 * // Validate transaction options with Cadence code
 * await preMutate({
 *   cadence: "transaction { execute { log(\"Hello Flow!\") } }"
 * })
 *
 * // Validate transaction options with template
 * await preMutate({
 *   template: transferFlowTemplate
 * })
 */
async function preMutate(context, opts) {
  return pre(context, "mutate", opts);
}

/**
 * @description Validates and prepares options for Flow script execution (queries). This function
 * performs comprehensive validation of the provided options to ensure they meet the requirements for
 * executing scripts on the Flow blockchain, including checking for required configuration values.
 *
 * @param opts Options object containing either Cadence code or template references for the script
 * @param opts.cadence Optional Cadence script code string
 * @param opts.template Optional interaction template object or reference
 * @returns Promise that resolves when validation passes
 * @throws Error if validation fails or required configuration is missing
 *
 * @example
 * // Validate script options with Cadence code
 * await preQuery({
 *   cadence: "access(all) fun main(): String { return \"Hello Flow!\" }"
 * })
 *
 * // Validate script options with template
 * await preQuery({
 *   template: getAccountTemplate
 * })
 */
async function preQuery(context, opts) {
  return pre(context, "query", opts);
}

async function httpDocumentResolver(_ref) {
  let {
    url
  } = _ref;
  invariant(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
  let res;
  try {
    res = await fetchTransport(url);
  } catch (e) {
    throw new Error("httpDocumentResolver Error: Failed to retrieve document.");
  }
  let document = res.ok ? await res.json() : null;
  return document;
}
const DOCUMENT_RESOLVERS = new Map([["http", httpDocumentResolver], ["https", httpDocumentResolver]]);

/**
 * @description Retrieves a document from a URL using protocol-specific resolvers. This function
 * supports HTTP/HTTPS by default and can be extended with custom resolvers through FCL configuration.
 * It's used internally by FCL to fetch interaction templates and other external documents.
 *
 * @param params The retrieval parameters
 * @param params.url The URL of the document to retrieve
 * @returns Promise that resolves to the retrieved document (typically a JSON object)
 * @throws {Error} If URL is invalid, protocol is unsupported, or retrieval fails
 *
 * @example
 * // Retrieve an interaction template
 * const template = await retrieve({
 *   url: "https://flix.flow.com/v1.0/templates/transfer-flow-tokens"
 * })
 * console.log("Template:", template)
 */
async function retrieve(context, _ref2) {
  let {
    url
  } = _ref2;
  invariant(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
  invariant(typeof url === "string", "retrieve({ url }) -- url must be a string");
  const documentResolversFromConfig = await context.config.where(/^document\.resolver\./);
  Object.keys(documentResolversFromConfig).map(key => {
    const resolverFromConfig = documentResolversFromConfig[key];
    const resolverProtocol = key.replace(/^document\.resolver\./, "");
    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);
  });
  const urlParts = /^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(url);
  invariant(urlParts, "Failed to parse URL");
  const protocol = urlParts[1];
  invariant(urlParts, "Failed to parse URL protocol");
  const resolver = DOCUMENT_RESOLVERS.get(protocol);
  invariant(resolver, `No resolver found for protcol=${protocol}`);
  let document = await resolver({
    url
  });
  return document;
}

/**
 * @description Fills import addresses in Cadence for network
 *
 * @param params
 * @param params.network Network to derive Cadence for
 * @param params.template Interaction Template to derive Cadence from
 * @returns Promise that resolves with the derived Cadence code
 */
async function deriveCadenceByNetwork100(_ref) {
  let {
    network,
    template
  } = _ref;
  invariant(template.f_version === "1.0.0", "deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0");
  const networkDependencies = Object.keys(template?.data?.dependencies).map(dependencyPlaceholder => {
    const dependencyNetworkContracts = Object.values(template?.data?.dependencies?.[dependencyPlaceholder]);
    invariant(dependencyNetworkContracts !== undefined, `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);
    invariant(dependencyNetworkContracts.length > 0, `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);
    const dependencyContract = dependencyNetworkContracts[0];
    const dependencyContractForNetwork = dependencyContract?.[network];
    invariant(dependencyContractForNetwork, `deriveCadenceByNetwork100 -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`);
    return [dependencyPlaceholder, dependencyContractForNetwork?.address];
  });
  return networkDependencies.reduce((cadence, _ref2) => {
    let [placeholder, address] = _ref2;
    const regex = new RegExp("(\\b" + placeholder + "\\b)", "g");
    return cadence.replace(regex, address);
  }, template.data.cadence);
}

/**
 * @description Replaces string imports with the actual contract address
 *
 * @param params
 * @param params.cadence The Cadence code
 * @param params.networkDependencies Network dependencies mapping
 * @returns Cadence code with replaced imports
 */
function replaceStringImports(_ref) {
  let {
    cadence,
    networkDependencies
  } = _ref;
  return Object.keys(networkDependencies).reduce((c, contractName) => {
    const address = networkDependencies[contractName];
    const regex = new RegExp(`import "\\b${contractName}\\b"`, "g");
    return c.replace(regex, `import ${contractName} from ${address}`);
  }, cadence);
}

/**
 * @description Fills import addresses in Cadence for network
 *
 * @param params
 * @param params.network Network to derive Cadence for
 * @param params.template Interaction Template to derive Cadence from
 * @returns Promise that resolves with the derived Cadence code
 */
async function deriveCadenceByNetwork110(_ref) {
  let {
    network,
    template
  } = _ref;
  invariant(template.f_version === "1.1.0", "deriveCadenceByNetwork110({ template }) -- template must be version 1.1.0");

  // get network dependencies from template dependencies, use new string import format
  const networkDependencies = {};
  template?.data?.dependencies.forEach(dependency => {
    dependency.contracts.forEach(contract => {
      const contractName = contract.contract;
      contract.networks.forEach(net => {
        if (net.network === network) {
          networkDependencies[contractName] = net.address;
        }
      });
      invariant(networkDependencies[contractName] !== undefined, `deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${network} ${contractName}`);
    });
  });
  invariant(Object.keys(networkDependencies).length === template?.data?.dependencies.length, `deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${networkDependencies}`);
  invariant(Object.keys(networkDependencies).length === Object.values(networkDependencies).length, `deriveCadenceByNetwork110 -- Could not find all addresses for network ${network} dependencies:  ${networkDependencies}`);
  invariant(!!template?.data?.cadence?.body, `no cadence found -- Could not replace import dependencies: ${networkDependencies}`);
  return replaceStringImports({
    cadence: template?.data?.cadence?.body,
    networkDependencies
  });
}

/**
 * @description Fills import addresses in Cadence for network
 *
 * @param params
 * @param params.network Network to derive Cadence for
 * @param params.template Interaction Template to derive Cadence from
 * @returns Promise that resolves with the derived Cadence code
 */
async function deriveCadenceByNetwork(_ref) {
  let {
    network,
    template
  } = _ref;
  invariant(network != undefined, "deriveCadenceByNetwork({ network }) -- network must be defined");
  invariant(typeof network === "string", "deriveCadenceByNetwork({ network }) -- network must be a string");
  invariant(template != undefined, "deriveCadenceByNetwork({ template }) -- template must be defined");
  invariant(typeof template === "object", "deriveCadenceByNetwork({ template }) -- template must be an object");
  invariant(template.f_type === "InteractionTemplate", "deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      return await deriveCadenceByNetwork110({
        network,
        template
      });
    case "1.0.0":
      return await deriveCadenceByNetwork100({
        network,
        template
      });
    default:
      throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
  }
}

/**
 * @description Fetches the chain ID from the Flow network by querying the network parameters.
 * The chain ID is a unique identifier for the specific Flow network (mainnet, testnet, etc.)
 * and is essential for ensuring transactions are executed on the correct network.
 *
 * @param opts Optional configuration object that can contain network access settings and other parameters
 * @returns Promise that resolves to the chain ID string (e.g., "flow-mainnet", "flow-testnet")
 *
 * @example
 * // Fetch chain ID from the configured network
 * const chainId = await fetchChainId()
 * console.log(chainId) // "flow-mainnet" or "flow-testnet"
 */
async function fetchChainId(context) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const response = await context.sdk.send([getNetworkParameters()], opts).then(context.sdk.decode);
  return response.chainId;
}

/**
 * Note to self:
 * Create the partial context
 * Then you need to make functions take only the necessary parts of the context
 * This way you can avoid the issue where the subtype does not satisfy the args
 */

/**
 * Create a global FCL Context based on the current global config.
 *
 * Some configuration values are still curried to the context as a backward compatibility measure.
 */
function createPartialGlobalFCLContext() {
  return {
    config: config(),
    sdk: {
      send,
      decode,
      subscribe,
      subscribeRaw,
      account,
      block,
      resolve
    }
  };
}

// Cache of chainId promises for each access node value
// key: access node, value: chainId promise
let chainIdCache = {};
let hasWarnedEnv = false;
function createGetChainId(context) {
  /**
   * @description
   * Gets the chain ID if its set, otherwise gets the chain ID from the access node
   *
   * @param opts Optional configuration parameters
   * @param opts.node Override the access node URL for this request instead of using the configured one
   * @param opts.enableRequestLogging Enable logging for the chain ID request
   * @returns Promise that resolves to the chain ID string (e.g., "mainnet", "testnet", "local")
   * @throws If the chain ID cannot be determined from configuration or access node
   *
   * @example
   * // Get chain ID using configured access node
   * import * as fcl from "@onflow/fcl"
   *
   * const chainId = await fcl.getChainId()
   * console.log("Connected to:", chainId) // "testnet" or "mainnet"
   */
  async function getChainId() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let flowNetworkCfg = await context.config.get("flow.network");
    let envCfg = await context.config.get("env");
    if (envCfg && !hasWarnedEnv) {
      log.deprecate({
        pkg: "FCL",
        subject: 'Using the "env" configuration key for specifying the flow network',
        message: "Configuring to specify flow network is no longer required",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"
      });
      hasWarnedEnv = true;
    }
    const accessNode = opts.node || (await context.config.get("accessNode.api"));
    if (!accessNode) {
      // Fall back to deprecated flow.network and env config keys
      // This probably should have been done before trying to fetch the chainId from the access node
      // However, this was the behaviour with the initial implementation of getChainId()
      if (flowNetworkCfg) {
        return flowNetworkCfg;
      } else if (envCfg) {
        return envCfg;
      }
      throw new Error(`Either the "accessNode.api" config key or opts.node must be set`);
    }

    // Try using cached chainId first if it exists and access node is the same
    if (chainIdCache[accessNode]) {
      try {
        return await chainIdCache[accessNode];
      } catch {}
    }

    // If no cached chainId, value is stale, or last attempt failed, try getting chainId from access node
    // Check if another getChainId() call has already started a new promise, if not, start a new one
    // There may have been concurrent calls to getChainId() while the first call was waiting for the response
    if (!chainIdCache[accessNode]) {
      chainIdCache[accessNode] = fetchChainId(context, opts).catch(error => {
        // If there was an error, reset the promise so that the next call will try again
        chainIdCache[accessNode] = null;
        throw error;
      });
    }

    // Use newly created promise
    try {
      return await chainIdCache[accessNode];
    } catch (e) {
      // Fall back to deprecated flow.network and env config keys
      // This probably should have been done before trying to fetch the chainId from the access node
      // However, this was the behaviour with the initial implementation of getChainId()
      if (flowNetworkCfg) {
        return flowNetworkCfg;
      } else if (envCfg) {
        return envCfg;
      }
      throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`);
    }
  }
  return getChainId;
}
const getChainId = /* @__PURE__ */createGetChainId(createPartialGlobalFCLContext());

/**
 * @description Watches the FCL configuration for changes to the access node and automatically updates
 * the chain ID cache accordingly. This ensures that chain ID information stays current when the
 * access node configuration changes, preventing stale chain ID data from being used.
 *
 * @returns A function that can be called to unsubscribe the configuration listener
 *
 * @example
 * // Start watching for chain ID changes
 * import * as fcl from "@onflow/fcl"
 *
 * const unsubscribe = fcl.watchForChainIdChanges()
 *
 * // Later, when you want to stop watching
 * unsubscribe()
 */
function watchForChainIdChanges(context) {
  if (!context) {
    context = createPartialGlobalFCLContext();
  }
  return context.config.subscribe(() => {
    // Call getChainId to update the chainId cache if access node has changed
    createGetChainId(context)({
      enableRequestLogging: false
    }).catch(() => {});
  });
}

/**
 * @description Prepares and processes template options for Flow transactions and scripts. This function handles
 * the resolution of interaction templates by either fetching them from a URL or using provided template data,
 * and derives the appropriate Cadence code based on the current network configuration.
 *
 * @param opts Template options object that can contain either direct Cadence code or template references
 * @param opts.cadence Optional Cadence code string to use directly
 * @param opts.template Optional template object or URL string. If a URL string is provided, the template will be fetched
 * @returns Promise that resolves to the processed template options with resolved Cadence code
 *
 * @example
 * // Prepare template with direct Cadence code
 * const opts = await prepTemplateOpts({
 *   cadence: "transaction { execute { log(\"Hello Flow!\") } }"
 * })
 *
 * // Prepare template from URL
 * const opts = await prepTemplateOpts({
 *   template: "https://flix.flow.com/v1/templates/transfer-flow"
 * })
 *
 * // Prepare template with template object
 * const opts = await prepTemplateOpts({
 *   template: {
 *     f_type: "InteractionTemplate",
 *     f_version: "1.1.0",
 *     id: "transfer-flow",
 *     data: { cadence: { "flow-mainnet": "transaction { ... }" } }
 *   }
 * })
 */
async function prepTemplateOpts(context, opts) {
  if (isString(opts?.template)) {
    opts.template = await retrieve(context, {
      url: opts?.template
    });
  }
  const cadence = opts.cadence || (await deriveCadenceByNetwork({
    template: opts.template,
    network: await createGetChainId(context)(opts)
  }));
  opts.cadence = cadence;
  return opts;
}

function createQueryRaw(context) {
  /**
   * @description Allows you to submit scripts to query the blockchain and get raw response data.
   *
   * @param opts Query Options and configuration
   * @param opts.cadence Cadence Script used to query Flow
   * @param opts.args Arguments passed to cadence script
   * @param opts.template Interaction Template for a script
   * @param opts.isSealed Block Finality
   * @param opts.limit Compute Limit for Query
   * @returns A promise that resolves to the raw query result
   *
   * @example
   * import * as fcl from '@onflow/fcl';
   *
   * const result = await fcl.queryRaw({
   *   cadence: `
   *     access(all) fun main(a: Int, b: Int, addr: Address): Int {
   *       log(addr)
   *       return a + b
   *     }
   *   `,
   *   args: (arg, t) => [
   *     arg(7, t.Int), // a: Int
   *     arg(6, t.Int), // b: Int
   *     arg('0xba1132bc08f82fe2', t.Address), // addr: Address
   *   ],
   * });
   */
  async function queryRaw() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    await preQuery(context, opts);
    opts = await prepTemplateOpts(context, opts);
    return context.sdk.send([sdk.script(opts.cadence), sdk.args(normalizeArgs(opts.args || [])), sdk.atLatestBlock(opts.isSealed ?? false), opts.limit && typeof opts.limit === "number" && sdk.limit(opts.limit)]);
  }
  return queryRaw;
}
const queryRaw = /* @__PURE__ */createQueryRaw(createPartialGlobalFCLContext());

function createQuery(context) {
  /**
   * @description Allows you to submit scripts to query the blockchain.
   *
   * @param opts Query options configuration
   * @param opts.cadence A valid cadence script (required)
   * @param opts.args Any arguments to the script if needed should be supplied via a function that returns an array of arguments
   * @param opts.limit Compute (Gas) limit for query.
   * @param opts.template Interaction Template for a script
   * @param opts.isSealed Block Finality
   * @returns A JSON representation of the response
   *
   * @example
   * import * as fcl from '@onflow/fcl';
   *
   * const result = await fcl.query({
   *   cadence: `
   *     access(all) fun main(a: Int, b: Int, addr: Address): Int {
   *       log(addr)
   *       return a + b
   *     }
   *   `,
   *   args: (arg, t) => [
   *     arg(7, t.Int), // a: Int
   *     arg(6, t.Int), // b: Int
   *     arg('0xba1132bc08f82fe2', t.Address), // addr: Address
   *   ],
   * });
   * console.log(result); // 13
   */
  async function query() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return createQueryRaw(context)(opts).then(context.sdk.decode);
  }
  return query;
}
const query = /* @__PURE__ */createQuery(createPartialGlobalFCLContext());

const FCL_REDIRECT_URL_PARAM_NAME = "fcl_redirect_url";
const FCL_RESPONSE_PARAM_NAME = "fclResponseJson";
const CORE_STRATEGIES = {
  "HTTP/RPC": "HTTP/RPC",
  "HTTP/POST": "HTTP/POST",
  "IFRAME/RPC": "IFRAME/RPC",
  "POP/RPC": "POP/RPC",
  "TAB/RPC": "TAB/RPC",
  "EXT/RPC": "EXT/RPC",
  "DEEPLINK/RPC": "DEEPLINK/RPC"
};

/**
 * @description Sets up a message listener to receive messages from the parent FCL application. This
 * function is used by wallet services to listen for specific message types from FCL and respond
 * accordingly. It handles message filtering, data sanitization, and provides context about the
 * message origin for security purposes.
 *
 * @param messageType The specific message type to listen for (e.g., "FCL:VIEW:READY:RESPONSE")
 * @param cb Callback function executed when a matching message is received
 * @param cb.data The message data received from FCL, with deprecated fields removed
 * @param cb.context Context object providing security information
 * @param cb.context.origin The origin URL of the FCL application sending the message
 *
 * @returns Function to remove the event listener and stop listening for messages
 *
 * @example
 * // Listen for authentication requests from FCL
 * import { onMessageFromFCL } from "@onflow/fcl"
 *
 * const removeListener = onMessageFromFCL("FCL:VIEW:READY:RESPONSE", (data, context) => {
 *   console.log("FCL is ready for communication")
 *   console.log("Message from:", context.origin)
 *   console.log("Ready data:", data)
 *
 *   // Verify origin for security
 *   if (context.origin === "https://myapp.com") {
 *     initializeWalletServices()
 *   } else {
 *     console.warn("Unexpected origin:", context.origin)
 *   }
 * })
 *
 * // Stop listening when wallet service closes
 * window.addEventListener("beforeunload", () => {
 *   removeListener()
 * })
 */
const onMessageFromFCL = function (messageType) {
  let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
  const buildData = data => {
    if (data.deprecated) console.warn("DEPRECATION NOTICE", data.deprecated.message);
    delete data?.body?.interaction;
    return data;
  };
  const internal = e => {
    const {
      data,
      origin
    } = e;
    if (typeof data !== "object") return;
    if (typeof data == null) return;
    if (data.type !== messageType) return;
    cb(buildData(data), {
      origin
    });
  };
  window.addEventListener("message", internal);
  return () => window.removeEventListener("message", internal);
};

/**
 * @description Sends messages from a wallet or service back to the parent FCL application. This function
 * handles communication between wallet UIs (running in iframes, popups, or redirects) and the main FCL
 * application. It automatically detects the communication method (redirect, iframe, or popup) and sends
 * the message accordingly.
 *
 * @param type The message type identifier (e.g., "FCL:VIEW:RESPONSE", "FCL:VIEW:READY")
 * @param msg Optional message payload containing response data
 * @param msg.f_type FCL message format type, should be "PollingResponse"
 * @param msg.f_vsn FCL message format version, should be "1.0.0"
 * @param msg.status Response status
 * @param msg.reason Reason for the response (especially for DECLINED status)
 * @param msg.data Actual response data (signatures, account info, etc.)
 *
 * @throws When unable to communicate with parent FCL instance
 *
 * @example
 * // Send approval response with signature data
 * import { sendMsgToFCL } from "@onflow/fcl"
 *
 * sendMsgToFCL("FCL:VIEW:RESPONSE", {
 *   f_type: "CompositeSignature",
 *   f_vsn: "1.0.0",
 *   addr: "0x1234567890abcdef",
 *   keyId: 0,
 *   signature: "abc123..."
 * })
 */
const sendMsgToFCL = (type, msg) => {
  const data = {
    ...msg,
    type
  };
  const urlParams = new URLSearchParams(window.location.search);
  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME);
  if (redirectUrl) {
    const url = new URL(redirectUrl);
    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data));
    window.location.href = url.href;
  } else if (window.location !== window.parent.location) {
    window.parent.postMessage({
      ...msg,
      type
    }, "*");
  } else if (window.opener) {
    window.opener.postMessage({
      ...msg,
      type
    }, "*");
  } else {
    throw new Error("Unable to communicate with parent FCL instance");
  }
};

/**
 * @description Initiates the communication handshake between a wallet service and FCL. This function
 * listens for the "FCL:VIEW:READY:RESPONSE" message from FCL and automatically sends "FCL:VIEW:READY"
 * to indicate the wallet service is ready to receive requests. This is typically the first function
 * called when a wallet service loads.
 *
 * @param cb Callback function executed when FCL responds with ready confirmation
 * @param cb.data Data received from FCL ready response
 * @param cb.context Context object containing origin information
 * @param cb.context.origin Origin of the FCL application
 * @param msg Optional message payload to include with ready signal
 *
 * @example
 * // Basic wallet service initialization
 * import { ready } from "@onflow/fcl"
 *
 * ready((data, context) => {
 *   console.log("FCL is ready to communicate")
 *   console.log("FCL origin:", context.origin)
 *   console.log("Ready data:", data)
 *
 *   // Wallet service is now ready to handle authentication requests
 *   initializeWalletUI()
 * })
 */
const ready = function (cb) {
  onMessageFromFCL("FCL:VIEW:READY:RESPONSE", cb);
  sendMsgToFCL("FCL:VIEW:READY");
};

/**
 * @description Closes the wallet service window/iframe and notifies FCL that the service is shutting down.
 * This should be called when the user cancels an operation or when the wallet service needs to close itself.
 *
 * Sends "FCL:VIEW:CLOSE".
 */
const close = () => {
  sendMsgToFCL("FCL:VIEW:CLOSE");
};

/**
 * @description Sends an approval response to FCL with the provided data. This indicates that the user
 * has approved the requested operation (authentication, transaction signing, etc.) and includes the
 * resulting data (signatures, account information, etc.).
 *
 * Sends "FCL:VIEW:RESPONSE". with status "APPROVED".
 *
 * @param data The approval data to send back to FCL (signatures, account info, etc.)
 *
 * @example
 * // Approve authentication with account data
 * import { approve } from "@onflow/fcl"
 *
 * const accountData = {
 *   f_type: "AuthnResponse",
 *   f_vsn: "1.0.0",
 *   addr: "0x1234567890abcdef",
 *   services: [
 *     {
 *       f_type: "Service",
 *       f_vsn: "1.0.0",
 *       type: "authz",
 *       method: "HTTP/POST",
 *       endpoint: "https://wallet.example.com/authz"
 *     }
 *   ]
 * }
 *
 * approve(accountData)
 */
const approve = data => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "APPROVED",
    reason: null,
    data: data
  });
};

/**
 * @description Sends a decline response to FCL indicating that the user has rejected or cancelled
 * the requested operation. This should be called when the user explicitly cancels an operation
 * or when an error prevents the operation from completing.
 *
 * Sends "FCL:VIEW:RESPONSE". with status "DECLINED".
 *
 * @param reason Human-readable reason for declining the request
 *
 * @example
 * // Decline when user cancels authentication
 * import { decline } from "@onflow/fcl"
 *
 * document.getElementById('cancel-btn').addEventListener('click', () => {
 *   decline("User cancelled authentication")
 * })
 */
const decline = reason => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "DECLINED",
    reason: reason,
    data: null
  });
};

/**
 * @description Sends a redirect response to FCL indicating that the operation requires a redirect
 * to complete. This is used when the wallet service needs to redirect the user to another URL
 * (such as a native app deep link or external service).
 *
 * Sends "FCL:VIEW:RESPONSE". with status "REDIRECT".
 *
 * @param data Redirect data containing the target URL and any additional parameters
 *
 * @example
 * // Redirect to native wallet app
 * import { redirect } from "@onflow/fcl"
 *
 * redirect({
 *   f_type: "RedirectResponse",
 *   f_vsn: "1.0.0",
 *   url: "flow-wallet://sign?transaction=abc123",
 *   callback: "https://myapp.com/callback"
 * })
 */
const redirect = data => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "REDIRECT",
    reason: null,
    data: data
  });
};

const SERVICE_PRAGMA = {
  f_type: "Service",
  f_vsn: "1.0.0"
};
const IDENTITY_PRAGMA = {
  f_type: "Identity",
  f_vsn: "1.0.0"
};
const USER_PRAGMA = {
  f_type: "USER",
  f_vsn: "1.0.0"
};
const POLLING_RESPONSE_PRAGMA = {
  f_type: "PollingResponse",
  f_vsn: "1.0.0"
};
const COMPOSITE_SIGNATURE_PRAGMA = {
  f_type: "CompositeSignature",
  f_vsn: "1.0.0"
};

/**
 * @description Creates a new CompositeSignature instance. CompositeSignature is a standardized
 * signature format used in the Flow ecosystem to represent cryptographic signatures along with
 * the signing account information. It includes the signature data, the account address, and
 * the key ID used for signing.
 *
 * @param addr Flow account address that created the signature (will be normalized with 0x prefix)
 * @param keyId The key ID/index used to create the signature (will be converted to number)
 * @param signature The cryptographic signature as a hexadecimal string
 *
 * @property f_type FCL type identifier, always "CompositeSignature"
 * @property f_vsn FCL version identifier for the signature format
 * @property addr Flow account address with 0x prefix
 * @property keyId Key ID used for signing (as number)
 * @property signature Signature data as hex string
 *
 * @example
 * // Create a composite signature for transaction signing
 * import { CompositeSignature } from "@onflow/fcl"
 *
 * const compSig = new CompositeSignature(
 *   "1234567890abcdef", // will be normalized to "0x1234567890abcdef"
 *   0,                  // key ID
 *   "abc123def456..."   // signature hex string
 * )
 *
 * console.log(compSig)
 * // {
 * //   f_type: "CompositeSignature",
 * //   f_vsn: "1.0.0",
 * //   addr: "0x1234567890abcdef",
 * //   keyId: 0,
 * //   signature: "abc123def456..."
 * // }
 */
class CompositeSignature {
  constructor(addr, keyId, signature) {
    this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;
    this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;
    this.addr = withPrefix(addr);
    this.keyId = Number(keyId);
    this.signature = signature;
  }
}

const rightPaddedHexBuffer = (value, pad) => Buffer.from(value.padEnd(pad * 2, "0"), "hex");
const leftPaddedHexBuffer = (value, pad) => Buffer.from(value.padStart(pad * 2, "0"), "hex");
const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);
const nonceBuffer = nonce => Buffer.from(nonce, "hex");

/**
 * @description Encodes account proof data for cryptographic signing on the Flow blockchain. This function
 * creates a standardized message format that combines the application identifier, account address,
 * and nonce into a format suitable for cryptographic signing. The encoded message can then be signed
 * by the account's private key to create an account proof.
 *
 * @param data Object containing the account proof components
 * @param data.address The Flow account address for which to create the proof
 * @param data.nonce A random hexadecimal string (minimum 32 bytes/64 hex chars) to prevent replay attacks
 * @param data.appIdentifier A unique identifier for your application to prevent cross-app replay attacks
 * @param includeDomainTag Whether to include the FCL domain tag in the encoding
 *
 * @returns The encoded message as a hexadecimal string ready for signing
 *
 * @throws If required parameters are missing or invalid, or if nonce is too short
 *
 * @example
 * // Basic account proof encoding
 * import { encodeAccountProof } from "@onflow/fcl"
 *
 * const accountProofData = {
 *   address: "0x1234567890abcdef",
 *   nonce: "75f8587e5bd982ec9289c5be1f9426bd12b4c1de9c7a7e4d8c5f9e8b2a7c3f1e9", // 64 hex chars (32 bytes)
 *   appIdentifier: "MyAwesomeApp"
 * }
 *
 * const encodedMessage = encodeAccountProof(accountProofData)
 * console.log("Encoded message:", encodedMessage)
 */
const encodeAccountProof = function (_ref) {
  let {
    address,
    nonce,
    appIdentifier
  } = _ref;
  let includeDomainTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  invariant(!!address, "Encode Message For Provable Authn Error: address must be defined");
  invariant(!!nonce, "Encode Message For Provable Authn Error: nonce must be defined");
  invariant(!!appIdentifier, "Encode Message For Provable Authn Error: appIdentifier must be defined");
  invariant(nonce.length >= 64, "Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");
  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"), 32);
  if (includeDomainTag) {
    return Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, encode([appIdentifier, addressBuffer(sansPrefix(address)), nonceBuffer(nonce)])]).toString("hex");
  }
  return encode([appIdentifier, addressBuffer(sansPrefix(address)), nonceBuffer(nonce)]).toString("hex");
};

/**
 * @description Injects an external authentication service into the global FCL extensions array.
 * This function is used by wallet providers to register their authentication services with FCL,
 * making them available for user authentication. The service must be of type "authn" and have
 * a valid endpoint.
 *
 * @param service The authentication service to inject. Must have type "authn" and a valid endpoint
 *
 * @example
 * // Register a wallet authentication service
 * const walletService = {
 *   type: "authn",
 *   endpoint: "https://example-wallet.com/fcl/authn",
 *   method: "HTTP/POST",
 *   identity: { address: "0x123..." },
 *   provider: { name: "Example Wallet" }
 * }
 * fcl.WalletUtils.injectExtService(walletService)
 */
function injectExtService(service) {
  if (service.type === "authn" && service.endpoint != null) {
    if (!Array.isArray(window.fcl_extensions)) {
      window.fcl_extensions = [];
    }
    window.fcl_extensions.push(service);
  } else {
    console.warn("Authn service is required");
  }
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CompositeSignature: CompositeSignature,
  approve: approve,
  close: close,
  decline: decline,
  encodeAccountProof: encodeAccountProof,
  encodeMessageFromSignable: encodeMessageFromSignable,
  injectExtService: injectExtService,
  onMessageFromFCL: onMessageFromFCL,
  ready: ready,
  redirect: redirect,
  sendMsgToFCL: sendMsgToFCL
});

const ACCOUNT_PROOF = "ACCOUNT_PROOF";
const USER_SIGNATURE = "USER_SIGNATURE";

/**
 * @description Validates input arguments for signature verification functions (both account proof and user signature verification).
 * This function performs comprehensive validation of parameters to ensure they meet the requirements for cryptographic
 * signature verification on the Flow blockchain. It handles two different validation scenarios: account proof validation
 * (when appIdentifier is provided) and user signature validation (when message is provided).
 *
 * @param args Object containing the arguments to validate. The validation behavior depends on which properties are present:
 * - For account proof validation: appIdentifier, address, nonce, and signatures are required
 * - For user signature validation: message, address, and compSigs are required
 * @param args.appIdentifier Optional unique identifier for the application (triggers account proof validation mode)
 * @param args.address Flow account address that should be exactly 16 characters (without 0x prefix)
 * @param args.nonce Hexadecimal string representing a cryptographic nonce (for account proof validation)
 * @param args.signatures Array of CompositeSignature objects for account proof validation
 * @param args.message Hexadecimal string representing the signed message (for user signature validation)
 * @param args.compSigs Array of CompositeSignature objects for user signature validation
 *
 * @returns Always returns true if validation passes, otherwise throws an error
 *
 * @throws Throws an invariant error if any validation check fails, with specific error messages for each validation failure
 *
 * @example
 * // Validate account proof arguments
 * const accountProofArgs = {
 *   appIdentifier: "MyApp",
 *   address: "1234567890abcdef",
 *   nonce: "75f8587e5bd982ec9289c5be1f9426bd",
 *   signatures: [{
 *     f_type: "CompositeSignature",
 *     f_vsn: "1.0.0",
 *     addr: "0x1234567890abcdef",
 *     keyId: 0,
 *     signature: "abc123def456..."
 *   }]
 * }
 *
 * const isValid = validateArgs(accountProofArgs) // Returns true or throws
 *
 * // Validate user signature arguments
 * const userSigArgs = {
 *   message: "48656c6c6f20576f726c64", // "Hello World" in hex
 *   address: "1234567890abcdef",
 *   compSigs: [{
 *     f_type: "CompositeSignature",
 *     f_vsn: "1.0.0",
 *     addr: "0x1234567890abcdef",
 *     keyId: 0,
 *     signature: "def456abc123..."
 *   }]
 * }
 *
 * const isValid = validateArgs(userSigArgs) // Returns true or throws
 */
const validateArgs = args => {
  if (args.appIdentifier) {
    const {
      appIdentifier,
      address,
      nonce,
      signatures
    } = args;
    invariant(isString(appIdentifier), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string");
    invariant(isString(address) && sansPrefix(address).length === 16, "verifyAccountProof({ address }) -- address must be a valid address");
    invariant(/^[0-9a-f]+$/i.test(nonce), "nonce must be a hex string");
    invariant(Array.isArray(signatures) && signatures.every((sig, i, arr) => sig.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    invariant(signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  } else {
    const {
      message,
      address,
      compSigs
    } = args;
    invariant(/^[0-9a-f]+$/i.test(message), "Signed message must be a hex string");
    invariant(isString(address) && sansPrefix(address).length === 16, "verifyUserSignatures({ address }) -- address must be a valid address");
    invariant(Array.isArray(compSigs) && compSigs.every((sig, i, arr) => sig.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    invariant(compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  }
};

// TODO: pass in option for contract but we're connected to testnet
// log address + network -> in sync?
const getVerifySignaturesScript = async (context, sig, opts) => {
  const verifyFunction = sig === "ACCOUNT_PROOF" ? "verifyAccountProofSignatures" : "verifyUserSignatures";
  const network = await createGetChainId(context)(opts);
  const contractAddresses = {
    testnet: "0x74daa6f9c7ef24b1",
    mainnet: "0xb4b82a1c9d21d284",
    previewnet: "0x40b5b8b2ce81ea4a"
  };
  const fclCryptoContract = opts.fclCryptoContract || contractAddresses[network];
  invariant(fclCryptoContract, `${verifyFunction}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${network}. Please manually specify the FCLCrypto contract address.`);
  return `
      import FCLCrypto from ${fclCryptoContract}

      access(all) fun main(
          address: Address, 
          message: String, 
          keyIndices: [Int], 
          signatures: [String]
      ): Bool {
        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)
      }
    `;
};
function createVerifyAccountProof(context) {
  /**
   * @description Verifies the authenticity of an account proof signature on the Flow blockchain.
   * Account proofs are cryptographic signatures used to prove ownership of a Flow account without
   * revealing private keys. This function validates that the provided signatures were indeed created
   * by the private keys associated with the specified Flow account address.
   *
   * @param appIdentifier A unique identifier for your application. This is typically
   * your app's name or domain and is included in the signed message to prevent replay attacks
   * across different applications.
   * @param accountProofData Object containing the account proof data to verify
   * @param accountProofData.address The Flow account address that allegedly signed the proof
   * @param accountProofData.nonce A random hexadecimal string (minimum 32 bytes, 64 hex chars)
   * used to prevent replay attacks. Should be unique for each proof request.
   * @param accountProofData.signatures Array of composite signatures to verify
   * against the account's public keys
   * @param opts Optional configuration parameters
   * @param opts.fclCryptoContract Override address for the FCLCrypto contract if not using
   * the default for the current network
   *
   * @returns Promise that resolves to true if all signatures are valid, false otherwise.
   *
   * @returns `true` if verified or `false`
   *
   * @example
   * import * as fcl from "@onflow/fcl"
   *
   * const accountProofData = {
   *   address: "0x123",
   *   nonce: "F0123"
   *   signatures: [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
   * }
   *
   * const isValid = await fcl.AppUtils.verifyAccountProof(
   *   "AwesomeAppId",
   *   accountProofData,
   *   {fclCryptoContract}
   * )
   */
  async function verifyAccountProof(appIdentifier, _ref) {
    let {
      address,
      nonce,
      signatures
    } = _ref;
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    validateArgs({
      appIdentifier,
      address,
      nonce,
      signatures
    });
    const message = encodeAccountProof({
      address,
      nonce,
      appIdentifier
    }, false);
    const signaturesArr = [];
    const keyIndices = [];
    for (const el of signatures) {
      signaturesArr.push(el.signature);
      keyIndices.push(el.keyId.toString());
    }
    return createQuery(context)({
      cadence: await getVerifySignaturesScript(context, ACCOUNT_PROOF, opts),
      args: (arg, t) => [arg(withPrefix(address), t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]
    });
  }
  return verifyAccountProof;
}
function createVerifyUserSignatures(context) {
  /**
   * @description Verifies user signatures for arbitrary messages on the Flow blockchain. This function
   * validates that the provided signatures were created by the private keys associated with the specified
   * Flow account when signing the given message. This is useful for authenticating users or validating
   * signed data outside of transaction contexts.
   *
   * @param message The message that was signed, encoded as a hexadecimal string. The original
   * message should be converted to hex before passing to this function.
   * @param compSigs Array of composite signatures to verify. All signatures
   * must be from the same account address.
   * @param compSigs[].f_type Must be "CompositeSignature"
   * @param compSigs[].f_vsn Must be "1.0.0"
   * @param compSigs[].addr The Flow account address that created the signature
   * @param compSigs[].keyId The key ID used to create the signature
   * @param compSigs[].signature The actual signature data
   * @param opts Optional configuration parameters
   * @param opts.fclCryptoContract Override address for the FCLCrypto contract
   *
   * @returns Promise that resolves to true if all signatures are valid, false otherwise
   *
   * @throws If parameters are invalid, signatures are from different accounts, or network issues occur
   *
   * @example
   * // Basic message signature verification
   * import * as fcl from "@onflow/fcl"
   *
   * const originalMessage = "Hello, Flow blockchain!"
   * const hexMessage = Buffer.from(originalMessage).toString("hex")
   *
   * const signatures = [{
   *   f_type: "CompositeSignature",
   *   f_vsn: "1.0.0",
   *   addr: "0x1234567890abcdef",
   *   keyId: 0,
   *   signature: "abc123def456..." // signature from user's wallet
   * }]
   *
   * const isValid = await fcl.AppUtils.verifyUserSignatures(
   *   hexMessage,
   *   signatures
   * )
   */
  async function verifyUserSignatures(message, compSigs) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const address = withPrefix(compSigs[0].addr);
    validateArgs({
      message,
      address,
      compSigs
    });
    const signaturesArr = [];
    const keyIndices = [];
    for (const el of compSigs) {
      signaturesArr.push(el.signature);
      keyIndices.push(el.keyId.toString());
    }
    return createQuery(context)({
      cadence: await getVerifySignaturesScript(context, USER_SIGNATURE, opts),
      args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]
    });
  }
  return verifyUserSignatures;
}
const verifyAccountProof = /* @__PURE__ */createVerifyAccountProof(createPartialGlobalFCLContext());
const verifyUserSignatures$1 = /* @__PURE__ */createVerifyUserSignatures(createPartialGlobalFCLContext());

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  verifyAccountProof: verifyAccountProof,
  verifyUserSignatures: verifyUserSignatures$1
});

/**
 * @description Verify a valid signature/s for an account on Flow.
 * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead
 */
const verifyUserSignatures = log.deprecate({
  pkg: "FCL",
  subject: "fcl.verifyUserSignatures()",
  message: "Please use fcl.AppUtils.verifyUserSignatures()",
  callback: function verifyUserSignatures(message, compSigs) {
    return verifyUserSignatures$1(message, compSigs);
  }
});

/**
 * @description Serializes a Flow transaction or script to a JSON-formatted signable voucher that can be
 * used for offline signing or inspection. This is useful for creating signable transactions that can be
 * signed by external wallets or hardware devices.
 *
 * @param args Array of interaction builder functions or a pre-built interaction object. Builder functions are typically from @onflow/sdk such as
 * transaction(), script(), args(), proposer(), etc.
 * @param opts Optional configuration object
 * @param opts.resolve Custom resolve function to use instead of the default
 *
 * @returns A JSON string representation of the signable voucher that contains all
 * the transaction details needed for signing
 *
 * @example
 * // Serialize a simple transaction
 * import * as fcl from "@onflow/fcl"
 *
 * const voucher = await fcl.serialize([
 *   fcl.transaction`
 *     transaction(amount: UFix64, to: Address) {
 *       prepare(signer: AuthAccount) {
 *         // Transaction logic here
 *       }
 *     }
 *   `,
 *   fcl.args([
 *     fcl.arg("10.0", fcl.t.UFix64),
 *     fcl.arg("0x01", fcl.t.Address)
 *   ]),
 *   fcl.proposer(authz),
 *   fcl.payer(authz),
 *   fcl.authorizations([authz])
 * ])
 */
function createSerialize(context) {
  const serialize = async function (args) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const resolveFunction = opts.resolve || context.sdk.resolve;
    if (Array.isArray(args)) args = await pipe(interaction(), args);
    return JSON.stringify(createSignableVoucher(await resolveFunction(args)), null, 2);
  };
  return serialize;
}
const serialize = /* @__PURE__ */createSerialize(createPartialGlobalFCLContext());

const ERROR_CODE_REGEX = /\[Error Code: (\d+)\]/;
class TransactionError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = FvmErrorCode[code];
  }
  static fromErrorMessage(errorMessage) {
    const match = errorMessage.match(ERROR_CODE_REGEX);
    const code = match ? parseInt(match[1], 10) : undefined;
    return new TransactionError(errorMessage, code || FvmErrorCode.UNKNOWN_ERROR);
  }
}

/**
 * @description Extracts configuration values that match a given regular expression pattern from the Flow configuration.
 * This utility function filters the configuration entries using the provided regex pattern and returns a simplified
 * object with the matching keys (with the regex pattern removed) and their corresponding values.
 *
 * @param regex Regular expression pattern to filter configuration keys. The matched portion will be removed from the resulting keys
 * @returns Promise that resolves to an object containing the filtered configuration entries with simplified keys
 *
 * @example
 * // Extract all configuration keys starting with "accessNode"
 * const accessNodeConfig = await configLens(/^accessNode\./)
 * // If config has "accessNode.api" = "https://rest-mainnet.onflow.org"
 * // Result: { "api": "https://rest-mainnet.onflow.org" }
 *
 * // Extract wallet-related configuration
 * const walletConfig = await configLens(/^wallet\./)
 * // Filters keys like "wallet.discovery.api" and returns simplified object
 */
async function configLens(context, regex) {
  return Object.fromEntries(Object.entries(await context.config.where(regex)).map(_ref => {
    let [key, value] = _ref;
    return [key.replace(regex, ""), value];
  }));
}

/**
 * @description Checks if a transaction has expired based on its status code.
 * A transaction is considered expired when its status equals 5.
 *
 * @param tx The transaction status object to check
 * @returns True if the transaction has expired, false otherwise
 *
 * @example
 * // Check if a transaction has expired
 * const txStatus = await fcl.tx(transactionId).snapshot()
 * if (isExpired(txStatus)) {
 *   console.log("Transaction has expired")
 * }
 */
const isExpired = tx => tx.status === 5;

/**
 * @description Checks if a transaction has been sealed. A transaction is sealed when it has been
 * included in a block and finalized on the blockchain (status >= 4).
 *
 * @param tx The transaction status object to check
 * @returns True if the transaction is sealed, false otherwise
 *
 * @example
 * // Wait for transaction to be sealed
 * const txStatus = await fcl.tx(transactionId).snapshot()
 * if (isSealed(txStatus)) {
 *   console.log("Transaction is sealed and finalized")
 * }
 */
const isSealed = tx => tx.status >= 4;

/**
 * @description Checks if a transaction has been executed. A transaction is executed when it has
 * been processed by the blockchain network (status >= 3).
 *
 * @param tx The transaction status object to check
 * @returns True if the transaction has been executed, false otherwise
 *
 * @example
 * // Check if transaction has been executed
 * const txStatus = await fcl.tx(transactionId).snapshot()
 * if (isExecuted(txStatus)) {
 *   console.log("Transaction has been executed")
 * }
 */
const isExecuted = tx => tx.status >= 3;

/**
 * @description Checks if a transaction has been finalized. A transaction is finalized when it has
 * been included in a block (status >= 2).
 *
 * @param tx The transaction status object to check
 * @returns True if the transaction has been finalized, false otherwise
 *
 * @example
 * // Check if transaction has been finalized
 * const txStatus = await fcl.tx(transactionId).snapshot()
 * if (isFinalized(txStatus)) {
 *   console.log("Transaction has been finalized")
 * }
 */
const isFinalized = tx => tx.status >= 2;

/**
 * @description Checks if a transaction is pending. A transaction is pending when it has been
 * submitted to the network but not yet processed (status >= 1).
 *
 * @param tx The transaction status object to check
 * @returns True if the transaction is pending, false otherwise
 *
 * @example
 * // Check if transaction is still pending
 * const txStatus = await fcl.tx(transactionId).snapshot()
 * if (isPending(txStatus)) {
 *   console.log("Transaction is still pending")
 * }
 */
const isPending = tx => tx.status >= 1;

/**
 * @description Checks if a transaction status is unknown. A transaction has unknown status when
 * it hasn't been processed yet or there's no information available (status >= 0).
 *
 * @param tx The transaction status object to check
 * @returns True if the transaction status is unknown, false otherwise
 *
 * @example
 * // Check if transaction status is unknown
 * const txStatus = await fcl.tx(transactionId).snapshot()
 * if (isUnknown(txStatus)) {
 *   console.log("Transaction status is unknown")
 * }
 */
const isUnknown = tx => tx.status >= 0;

/**
 * @description Performs a deep equality comparison between two values. This function recursively
 * compares all properties of objects and arrays to determine if they are equal.
 *
 * @param a First value to compare
 * @param b Second value to compare
 * @returns True if the values are deeply equal, false otherwise
 *
 * @example
 * // Compare two objects
 * const obj1 = { name: "Flow", version: "1.0" }
 * const obj2 = { name: "Flow", version: "1.0" }
 * console.log(deepEqual(obj1, obj2)) // true
 */
const deepEqual = (a, b) => {
  if (a === b) return true;
  if (typeof a !== "object" || typeof b !== "object") return false;
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (const key in a) if (!deepEqual(a[key], b[key])) return false;
  return true;
};

/**
 * @description Checks if two values are different by performing a deep equality comparison.
 * This is the inverse of the deepEqual function.
 *
 * @param a First value to compare
 * @param b Second value to compare
 * @returns True if the values are different, false if they are equal
 *
 * @example
 * // Check if objects are different
 * const obj1 = { name: "Flow", version: "1.0" }
 * const obj2 = { name: "Flow", version: "2.0" }
 * console.log(isDiff(obj1, obj2)) // true
 */
const isDiff = (a, b) => {
  return !deepEqual(a, b);
};

/**
 * @description Extracts a transaction ID from either a string or an object containing a transactionId property.
 * This utility function handles both formats and ensures a valid transaction ID is returned.
 *
 * @param transactionId Either a transaction ID string or an object with a transactionId property
 * @returns The transaction ID as a string
 * @throws If transactionId is null, undefined, or invalid
 *
 * @example
 * // Extract from string
 * const txId = scoped("abc123def456")
 * console.log(txId) // "abc123def456"
 */
const scoped = transactionId => {
  if (typeof transactionId === "object") transactionId = transactionId.transactionId;
  if (transactionId == null) throw new Error("transactionId required");
  return transactionId;
};

const TXID_REGEXP = /^[0-9a-fA-F]{64}$/;

const POLL = "POLL";
const TIMEOUT = "TIMEOUT";

/**
 * @typedef {import("@onflow/typedefs").Transaction} Transaction
 */

/**
 * @typedef {import("@onflow/typedefs").TransactionStatus} TransactionStatus
 */

const fetchTxStatus = async transactionId => {
  return send([getTransactionStatus(transactionId)]).then(decode);
};
const makeHandlers$1 = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    [INIT]: async ctx => {
      setTimeout(() => ctx.sendSelf(TIMEOUT), opts.txNotFoundTimeout);
      ctx.sendSelf(POLL);
    },
    [SUBSCRIBE]: (ctx, letter) => {
      ctx.subscribe(letter.from);
      ctx.send(letter.from, UPDATED$2, ctx.all());
    },
    [UNSUBSCRIBE]: (ctx, letter) => {
      ctx.unsubscribe(letter.from);
    },
    [SNAPSHOT$1]: async (ctx, letter) => {
      letter.reply(ctx.all());
    },
    [TIMEOUT]: async ctx => {
      // If status is still unknown, send a timeout error
      if (Object.keys(ctx.all()).length === 0) {
        ctx.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${opts.txNotFoundTimeout}ms)`));
      }
    },
    [POLL]: async ctx => {
      // Helper to queue another poll
      const poll = () => setTimeout(() => ctx.sendSelf(POLL), opts.pollRate);
      let tx;
      const prevTx = ctx.all();
      try {
        tx = await fetchTxStatus(ctx.self());
      } catch (e) {
        const isHttpNotFound = e instanceof HTTPRequestError && e.statusCode === 404;
        const isGrpcNotFound = e.code === grpc.Code.NotFound;

        // If TX is not found, suppress error and poll again
        if (isHttpNotFound || isGrpcNotFound) {
          return poll();
        }
        return ctx.fatalError(e);
      }
      if (!isSealed(tx)) poll();
      if (isDiff(prevTx, tx)) ctx.broadcast(UPDATED$2, tx);
      ctx.merge(tx);
    }
  };
};
const spawnTransaction = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return transactionId => {
    return spawn(makeHandlers$1(opts), scoped(transactionId));
  };
};

/**
 * Provides methods for interacting with a transaction
 *
 * @param {string} transactionId - The transaction ID
 * @param {object} [opts] - Optional parameters
 * @param {number} [opts.pollRate=1000] - Polling rate in milliseconds
 * @param {number} [opts.txNotFoundTimeout=12500] - Timeout in milliseconds for ignoring transaction not found errors (do not modify unless you know what you are doing)
 * @returns {{
 *    snapshot: function(): Promise<TransactionStatus>,
 *    subscribe: function(SubscriptionCallback): function(): void,
 *    onceFinalized: function(): Promise<TransactionStatus>,
 *    onceExecuted: function(): Promise<TransactionStatus>,
 *    onceSealed: function(): Promise<TransactionStatus>
 * }}
 * @throws {Error} If transactionId is not a 64 byte hash string
 */
function transaction$1(transactionId) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    txNotFoundTimeout: 12500,
    pollRate: 1000
  };
  // Validate transactionId as 64 byte hash
  if (!TXID_REGEXP.test(scoped(transactionId))) throw new Error("Invalid transactionId");
  function snapshot() {
    return snapshoter(transactionId, spawnTransaction(opts));
  }
  function subscribe(callback) {
    return subscriber(scoped(transactionId), spawnTransaction(opts), callback);
  }
  function once(predicate) {
    return function innerOnce() {
      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const suppress = opts.suppress || false;
      return new Promise((resolve, reject) => {
        const unsub = subscribe((txStatus, error) => {
          if ((error || txStatus.statusCode) && !suppress) {
            if (error != null) {
              reject(error);
              unsub();
            } else if (txStatus.statusCode === 1) {
              const transactionError = TransactionError.fromErrorMessage(txStatus.errorMessage);
              reject(transactionError);
              unsub();
            }
            return;
          }
          if (predicate(txStatus)) {
            resolve(txStatus);
            unsub();
          }
        });
      });
    };
  }
  return {
    snapshot,
    subscribe,
    onceFinalized: once(isFinalized),
    onceExecuted: once(isExecuted),
    onceSealed: once(isSealed)
  };
}
transaction$1.isUnknown = isUnknown;
transaction$1.isPending = isPending;
transaction$1.isFinalized = isFinalized;
transaction$1.isExecuted = isExecuted;
transaction$1.isSealed = isSealed;
transaction$1.isExpired = isExpired;

const FLOW_EMULATOR$1 = "local";

// Map of transaction observables
// Used for shared global singleton to prevent duplicate subscriptions
const registry = new Map();
function createTransaction(context) {
  /**
   * @description Creates a transaction monitor that provides methods for tracking and subscribing to
   * transaction status updates on the Flow blockchain. This function returns an object with methods
   * to get snapshots, subscribe to status changes, and wait for specific transaction states.
   *
   * @param transactionId The 64-character hex transaction ID to monitor. Must be a valid
   * Flow transaction hash (64 bytes represented as hex string).
   * @param opts Optional configuration parameters
   * @param opts.pollRate Polling rate in milliseconds when using legacy polling fallback
   * @param opts.txNotFoundTimeout Timeout in milliseconds for ignoring transaction
   * not found errors during initial transaction propagation (do not modify unless you know what you are doing)
   *
   * @returns Transaction monitor object with methods for tracking transaction status
   *
   * @throws If transactionId is not a valid 64-byte hash string
   *
   * @example
   * // Basic transaction monitoring
   * import * as fcl from "@onflow/fcl"
   *
   * const txId = await fcl.mutate({
   *   cadence: `
   *     transaction {
   *       execute { log("Hello, World!") }
   *     }
   *   `
   * })
   *
   * // Get current status
   * const status = await fcl.tx(txId).snapshot()
   * console.log("Current status:", status.status)
   *
   * // Subscribe to all status changes
   * const unsubscribe = fcl.tx(txId).subscribe((status) => {
   *   console.log("Status update:", status.status)
   *   if (status.status === fcl.transaction.isSealed) {
   *     console.log("Transaction sealed!")
   *     console.log("Events:", status.events)
   *   }
   * })
   * // Clean up subscription when done
   * setTimeout(() => unsubscribe(), 60000)
   *
   * // Wait for specific transaction states
   * try {
   *   // Wait for finalization (consensus reached)
   *   const finalizedStatus = await fcl.tx(txId).onceFinalized()
   *   console.log("Transaction finalized")
   *
   *   // Wait for execution (transaction executed)
   *   const executedStatus = await fcl.tx(txId).onceExecuted()
   *   console.log("Transaction executed")
   *
   *   // Wait for sealing (transaction sealed in block)
   *   const sealedStatus = await fcl.tx(txId).onceSealed()
   *   console.log("Transaction sealed:", sealedStatus.events)
   * } catch (error) {
   *   console.error("Transaction failed:", error.message)
   * }
   *
   * // Handle transaction errors
   * fcl.tx(txId).subscribe(
   *   (status) => {
   *     if (status.statusCode === 1) {
   *       console.error("Transaction error:", status.errorMessage)
   *     }
   *   },
   *   (error) => {
   *     console.error("Subscription error:", error)
   *   }
   * )
   */
  function transaction(transactionId) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      txNotFoundTimeout: 12500,
      pollRate: 1000
    };
    // Validate transactionId as 64 byte hash
    if (!TXID_REGEXP.test(scoped(transactionId))) throw new Error("Invalid transactionId");
    function getObservable() {
      let observable = registry.get(transactionId);
      if (!observable) {
        observable = createObservable(context, transactionId, opts);
        registry.set(transactionId, observable);
      }
      return observable;
    }
    function snapshot() {
      return Promise.resolve(getObservable().value);
    }
    function subscribe(onData, onError) {
      const observable = getObservable();
      const {
        unsubscribe
      } = observable.subscribe(onData, onError);
      return () => unsubscribe();
    }
    function once(predicate) {
      return function innerOnce() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          suppress: false
        };
        const suppress = opts.suppress || false;
        return new Promise((resolve, reject) => {
          const unsub = subscribe(txStatus => {
            if (txStatus.statusCode === 1) {
              const transactionError = TransactionError.fromErrorMessage(txStatus.errorMessage);
              reject(transactionError);
              unsub();
            } else if (predicate(txStatus)) {
              resolve(txStatus);
              unsub();
            }
          }, err => {
            if (!suppress) {
              reject(err);
              unsub();
            }
          });
        });
      };
    }
    return {
      snapshot,
      subscribe,
      onceFinalized: once(isFinalized),
      onceExecuted: once(isExecuted),
      onceSealed: once(isSealed)
    };
  }
  transaction.isUnknown = isUnknown$1;
  transaction.isPending = isPending;
  transaction.isFinalized = isFinalized;
  transaction.isExecuted = isExecuted;
  transaction.isSealed = isSealed;
  transaction.isExpired = isExpired;
  return transaction;
}
const transaction = /* @__PURE__ */createTransaction(createPartialGlobalFCLContext());

/**
 * @description Creates an observable for a transaction
 */
function createObservable(context, txId, opts) {
  const observers = new Set();
  let value = {
    blockId: "",
    status: TransactionExecutionStatus.UNKNOWN,
    statusCode: 0,
    errorMessage: "",
    events: [],
    statusString: ""
  };

  // Initialize the subscription
  init().catch(error);
  async function init() {
    const flowNetwork = await createGetChainId(context)();

    // As of Flow CLI v2.2.8, WebSocket subscriptions are not supported on the Flow emulator
    // This conditional will be removed when WebSocket subscriptions are supported in this environment
    if (flowNetwork === FLOW_EMULATOR$1) {
      console.warn("Events are not supported on the Flow emulator, falling back to legacy polling.");
      fallbackLegacyPolling();
    } else {
      subscribeTransactionStatuses();
    }
  }

  // Subscribe to transaction status updates
  function subscribeTransactionStatuses() {
    // Subscribe to transaction status updates
    const subscription = context.sdk.subscribe({
      topic: SubscriptionTopic.TRANSACTION_STATUSES,
      args: {
        transactionId: txId
      },
      onData: txStatus => {
        if (isDiff(value, txStatus)) {
          value = txStatus;
          next(txStatus);
        }

        // Clean up the subscription if the transaction is sealed
        // Wait for next tick to ensure unsubscribe is defined
        if (isSealed(txStatus)) {
          new Promise(resolve => setTimeout(resolve, 0)).then(() => {
            if (isSealed(txStatus)) {
              subscription.unsubscribe();
            }
          });
        }
      },
      onError: err => {
        if (err instanceof SubscriptionsNotSupportedError) {
          console.warn("Failed to subscribe to transaction status updates using real-time streaming (are you using the deprecated GRPC transport?), falling back to polling.");
          fallbackLegacyPolling();
        } else {
          error(err);
        }
      }
    });
  }
  function fallbackLegacyPolling() {
    // Poll for transaction status updates
    const unsubscribe = transaction$1(txId, opts).subscribe((txStatus, err) => {
      if (err) {
        error(err);
      } else if (txStatus && isDiff(value, txStatus)) {
        value = txStatus;
        next(txStatus);

        // Clean up the subscription if the transaction is sealed
        // Wait for next tick to ensure unsubscribe is defined
        if (isSealed(txStatus)) {
          new Promise(resolve => setTimeout(resolve, 0)).then(() => {
            unsubscribe();
          });
        }
      }
    });
  }
  function next(txStatus) {
    for (const observer of observers) {
      try {
        observer.onData(txStatus);
      } catch (error) {
        console.error("Error in transaction observer", error);
      }
    }
  }
  function error(err) {
    for (const observer of observers) {
      try {
        observer.onError(err);
      } catch (error) {
        console.error("Error in transaction observer", error);
      }
    }
  }
  return {
    subscribe(onData, onError) {
      const observer = {
        onData,
        onError: onError || (() => {})
      };
      observers.add(observer);
      onData(value);
      return {
        unsubscribe: () => observers.delete(observer)
      };
    },
    get value() {
      return value;
    }
  };
}

const RATE = 10000;
const UPDATED$1 = "UPDATED";
const TICK = "TICK";
const HIGH_WATER_MARK = "hwm";
const scheduleTick = async (fclContext, ctx) => {
  return setTimeout(() => ctx.sendSelf(TICK), await fclContext.config.get("fcl.eventPollRate", RATE));
};
function createHandlers$1(fclContext) {
  const HANDLERS = {
    [TICK]: async ctx => {
      if (!ctx.hasSubs()) return;
      let hwm = ctx.get(HIGH_WATER_MARK);
      if (hwm == null) {
        ctx.put(HIGH_WATER_MARK, await fclContext.sdk.block());
        ctx.put(TICK, await scheduleTick(fclContext, ctx));
      } else {
        let next = await fclContext.sdk.block();
        ctx.put(HIGH_WATER_MARK, next);
        if (hwm.height < next.height) {
          const data = await fclContext.sdk.send([getEventsAtBlockHeightRange(ctx.self(), hwm.height + 1, next.height)]).then(fclContext.sdk.decode);
          for (let d of data) ctx.broadcast(UPDATED$1, d);
        }
        ctx.put(TICK, await scheduleTick(fclContext, ctx));
      }
    },
    [SUBSCRIBE]: async (ctx, letter) => {
      if (!ctx.hasSubs()) {
        ctx.put(TICK, await scheduleTick(fclContext, ctx));
      }
      ctx.subscribe(letter.from);
    },
    [UNSUBSCRIBE]: (ctx, letter) => {
      ctx.unsubscribe(letter.from);
      if (!ctx.hasSubs()) {
        clearTimeout(ctx.get(TICK));
        ctx.delete(TICK);
        ctx.delete(HIGH_WATER_MARK);
      }
    }
  };
  return HANDLERS;
}
const spawnEvents = (fclContext, key) => spawn(createHandlers$1(fclContext), key);
function createLegacyEvents(context) {
  /**
   * @description Subscribe to events
   * @param key A valid event name
   * @returns An object with a subscribe method
   *
   * @example
   * import * as fcl from "@onflow/fcl"
   * fcl.events(eventName).subscribe((event) => console.log(event))
   */
  function legacyEvents(key) {
    return {
      /**
       * @description Subscribe to events
       * @param {Function} callback The callback function
       * @returns {SubscriptionCallback}
       */
      subscribe: callback => subscriber(key, address => spawnEvents(context, address), callback)
    };
  }
  return legacyEvents;
}

const FLOW_EMULATOR = "local";
function createEvents(context) {
  /**
   * @description Subscribes to Flow blockchain events in real-time. This function provides a way to listen
   * for specific events emitted by smart contracts on the Flow blockchain. It automatically handles
   * fallback to legacy polling for environments that don't support WebSocket subscriptions.
   *
   * @param filterOrType Event filter object or event type string.
   * If a string is provided, it will be treated as a single event type to subscribe to.
   * If an EventFilter object is provided, it can contain multiple event types and other filter criteria.
   * @param filterOrType.eventTypes Array of event type strings to subscribe to
   * @param filterOrType.startBlockId Block ID to start streaming from
   * @param filterOrType.startBlockHeight Block height to start streaming from
   *
   * @returns An object containing a subscribe method
   * @returns returns.subscribe Function to start the subscription
   * @returns returns.subscribe.onData Callback function called when an event is received
   * @returns returns.subscribe.onError Optional callback function called when an error occurs
   * @returns returns.subscribe.unsubscribe Function returned by subscribe() to stop the subscription
   *
   * @example
   * // Subscribe to a specific event type
   * import * as fcl from "@onflow/fcl"
   *
   * const unsubscribe = fcl.events("A.0x1654653399040a61.FlowToken.TokensWithdrawn")
   *   .subscribe((event) => {
   *     console.log("Event received:", event)
   *     console.log("Event data:", event.data)
   *     console.log("Transaction ID:", event.transactionId)
   *   })
   *
   * // Stop listening after 30 seconds
   * setTimeout(() => {
   *   unsubscribe()
   * }, 30000)
   *
   * // Subscribe to multiple event types with error handling
   * const unsubscribe = fcl.events({
   *   eventTypes: [
   *     "A.0x1654653399040a61.FlowToken.TokensWithdrawn",
   *     "A.0x1654653399040a61.FlowToken.TokensDeposited"
   *   ]
   * }).subscribe(
   *   (event) => {
   *     console.log("Token event:", event.type, event.data)
   *   },
   *   (error) => {
   *     console.error("Event subscription error:", error)
   *   }
   * )
   *
   * // Subscribe to events starting from a specific block height
   * const unsubscribe = fcl.events({
   *   eventTypes: ["A.CONTRACT.EVENT"],
   *   startBlockHeight: 12345678
   * }).subscribe((event) => {
   *   console.log("Historical and new events:", event)
   * })
   */
  function events(filterOrType) {
    let filter;
    if (typeof filterOrType === "string") {
      filter = {
        eventTypes: [filterOrType]
      };
    } else {
      filter = filterOrType || {};
    }
    return {
      subscribe: function (onData) {
        let onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : error => {
          console.error("Unhandled error in event subscription:", error);
        };
        let unsubscribeFn = () => {};
        let unsubscribeFnLegacy = () => {};

        // Subscribe to the event stream
        function subscribeEventStream() {
          const {
            unsubscribe
          } = context.sdk.subscribe({
            topic: SubscriptionTopic.EVENTS,
            args: filter,
            onData: event => {
              // Emit the event
              onData(event);
            },
            onError: error => {
              // If subscriptions are not supported, fallback to legacy polling, otherwise return the error
              if (error instanceof SubscriptionsNotSupportedError) {
                console.warn("Failed to subscribe to events using real-time streaming (are you using the deprecated GRPC transport?), falling back to legacy polling.");
                fallbackLegacyPolling();
              } else {
                onError(error);
              }
            }
          });
          unsubscribeFn = unsubscribe;
        }

        // Fallback to legacy polling if real-time streaming is not supported
        function fallbackLegacyPolling() {
          if (typeof filterOrType !== "string") {
            throw new Error("Legacy fcl.events fallback only supports string filters (single event type)");
          }
          unsubscribeFnLegacy = createLegacyEvents(context)(filterOrType).subscribe((event, error) => {
            if (error) {
              onError(error);
            } else {
              if (event) {
                onData(event);
              }
            }
          });
        }
        async function subscribeToEvents() {
          const network = await createGetChainId(context)();

          // As of Flow CLI v2.2.8, WebSocket subscriptions are not supported on the Flow emulator
          // This conditional will be removed when WebSocket subscriptions are supported in this environment
          if (network === FLOW_EMULATOR) {
            console.warn("Events are not supported on the Flow emulator, falling back to legacy polling.");
            fallbackLegacyPolling();
          } else {
            subscribeEventStream();
          }
        }

        // Subscribe to events
        const initPromise = subscribeToEvents().catch(error => {
          onError(error);
        });

        // Return an unsubscribe function
        return () => {
          initPromise.finally(() => {
            unsubscribeFn();
            unsubscribeFnLegacy();
          });
        };
      }
    };
  }
  return events;
}
const events = /*@__PURE__*/createEvents(createPartialGlobalFCLContext());

const stub = () => {
  throw new Error(`Platform specific Core Strategies are not initialized`);
};
const stubCoreStrategies = {
  [CORE_STRATEGIES["EXT/RPC"]]: stub,
  [CORE_STRATEGIES["HTTP/POST"]]: stub,
  [CORE_STRATEGIES["IFRAME/RPC"]]: stub,
  [CORE_STRATEGIES["POP/RPC"]]: stub,
  [CORE_STRATEGIES["TAB/RPC"]]: stub,
  [CORE_STRATEGIES["EXT/RPC"]]: stub
};
const supportedPlugins = ["ServicePlugin"];
const supportedServicePlugins = ["discovery-service"];
const validateDiscoveryPlugin = servicePlugin => {
  const {
    services = [],
    serviceStrategy
  } = servicePlugin;
  invariant(Array.isArray(services), "Services must be an array");
  for (const ds of services) {
    invariant(isRequired(ds.f_type) && ds.f_type === "Service", "Service is required");
    invariant(isRequired(ds.type) && ds.type === "authn", `Service must be type authn. Received ${ds.type}`);
    invariant(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, `Service method ${ds.method} is not supported`);
  }
  invariant(isRequired(serviceStrategy), "Service strategy is required");
  invariant(isRequired(serviceStrategy.method) && isString(serviceStrategy.method), "Service strategy method is required");
  invariant(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), "Service strategy exec function is required");
  return {
    discoveryServices: services,
    serviceStrategy
  };
};
const ServiceRegistry = _ref => {
  let {
    coreStrategies
  } = _ref;
  let services = new Set();
  let strategies = new Map(Object.entries(coreStrategies));
  const add = servicePlugin => {
    invariant(supportedServicePlugins.includes(servicePlugin.type), `Service Plugin type ${servicePlugin.type} is not supported`);
    if (servicePlugin.type === "discovery-service") {
      const {
        discoveryServices,
        serviceStrategy
      } = validateDiscoveryPlugin(servicePlugin);
      setServices(discoveryServices);
      if (!strategies.has(serviceStrategy.method)) {
        strategies.set(serviceStrategy.method, serviceStrategy.exec);
      } else {
        log({
          title: `Add Service Plugin`,
          message: `Service strategy for ${serviceStrategy.method} already exists`,
          level: LEVELS.warn
        });
      }
    }
  };
  const setServices = discoveryServices => services = new Set([...discoveryServices]);
  const getServices = () => [...services];
  const getStrategy = method => strategies.get(method);
  const getStrategies = () => [...strategies.keys()];
  return Object.freeze({
    add,
    getServices,
    getStrategy,
    getStrategies
  });
};
const validatePlugins = plugins => {
  let pluginsArray;
  invariant(!!plugins, "No plugins supplied");
  if (!Array.isArray(plugins)) {
    pluginsArray = [plugins];
  } else {
    pluginsArray = [...plugins];
  }
  for (const p of pluginsArray) {
    invariant(isRequired(p.name), "Plugin name is required");
    invariant(isRequired(p.f_type), "Plugin f_type is required");
    invariant(supportedPlugins.includes(p.f_type), `Plugin type ${p.f_type} is not supported`);
  }
  return pluginsArray;
};
const PluginRegistry = () => {
  const pluginsMap = new Map();
  const getPlugins = () => pluginsMap;
  const add = plugins => {
    const pluginsArray = validatePlugins(plugins);
    for (const p of pluginsArray) {
      pluginsMap.set(p.name, p);
      if (p.f_type === "ServicePlugin") {
        serviceRegistry.add(p);
      }
    }
  };
  return Object.freeze({
    add,
    getPlugins
  });
};
let serviceRegistry;
const getIsServiceRegistryInitialized = () => typeof serviceRegistry !== "undefined";

/**
 * @description Initializes the service registry with core strategies for different communication methods.
 * This function sets up the registry that manages wallet service strategies and should be called once
 * during FCL initialization with platform-specific core strategies.
 *
 * @param params Configuration object containing core strategies
 * @param params.coreStrategies Object mapping strategy names to their implementation functions
 * @returns The initialized service registry instance
 *
 * @example
 * // Initialize service registry with core strategies
 * const registry = initServiceRegistry({
 *   coreStrategies: {
 *     "HTTP/POST": httpPostStrategy,
 *     "IFRAME/RPC": iframeRpcStrategy,
 *     "POP/RPC": popupRpcStrategy
 *   }
 * })
 */
const initServiceRegistry = _ref2 => {
  let {
    coreStrategies
  } = _ref2;
  if (getIsServiceRegistryInitialized()) {
    return serviceRegistry;
  }
  const _serviceRegistry = ServiceRegistry({
    coreStrategies
  });
  serviceRegistry = _serviceRegistry;
  return _serviceRegistry;
};

/**
 * @description Gets the singleton service registry instance. If the registry hasn't been initialized,
 * it will be initialized with stub core strategies and a warning will be logged. This function
 * provides access to the registry for service and strategy management.
 *
 * @returns The service registry instance
 *
 * @example
 * // Get the service registry
 * const registry = getServiceRegistry()
 * const services = registry.getServices()
 * const strategy = registry.getStrategy("HTTP/POST")
 */
const getServiceRegistry = () => {
  if (!getIsServiceRegistryInitialized()) {
    console.warn("Registry is not initalized, it will be initialized with stub core strategies");
    return initServiceRegistry({
      coreStrategies: stubCoreStrategies
    });
  }
  return serviceRegistry;
};

/**
 * @description Global plugin registry instance for managing FCL plugins. This registry handles
 * the registration and management of various FCL plugins including service plugins that add
 * new wallet services and strategies.
 *
 * @example
 * // Add a plugin to the registry
 * pluginRegistry.add({
 *   name: "MyWalletPlugin",
 *   f_type: "ServicePlugin",
 *   type: "discovery-service",
 *   services: [...],
 *   serviceStrategy: { method: "CUSTOM/RPC", exec: customExecFunction }
 * })
 */
const pluginRegistry = PluginRegistry();

/**
 * @description Creates an array of discovery services by combining extension services from the
 * window object with registered services from the service registry. This is used internally
 * by FCL to gather all available wallet and authentication services.
 *
 * @returns Promise that resolves to an array of available services
 *
 * @example
 * // Get all available discovery services
 * const services = await makeDiscoveryServices()
 * console.log(services.length) // Number of available services
 * services.forEach(service => {
 *   console.log(`Service: ${service.provider?.name}, Type: ${service.type}`)
 * })
 */
const makeDiscoveryServices = async () => {
  const extensionServices = window?.fcl_extensions || [];
  return [...extensionServices, ...getServiceRegistry().getServices()];
};

/**
 * @description Creates and configures a discovery service object used for wallet authentication.
 * This function combines the provided service configuration with discovery-related settings from
 * the FCL configuration to create a complete service definition for wallet authentication flows.
 *
 * @param context FCL context containing configuration and SDK
 * @param service Optional partial service configuration to override defaults
 * @param service.method Optional communication method for the service
 * @param service.endpoint Optional endpoint URL for the service
 * @returns Promise that resolves to a complete discovery service configuration
 * @throws Error if required configuration values are missing
 *
 * @example
 * // Get discovery service with default configuration
 * const discoveryService = await getDiscoveryService(context)
 * console.log(discoveryService.endpoint) // Configured discovery endpoint
 *
 * // Override discovery service endpoint
 * const customService = await getDiscoveryService(context, {
 *   endpoint: "https://wallet.example.com/authn",
 *   method: "HTTP/POST"
 * })
 *
 * // Use with custom wallet service
 * const walletService = await getDiscoveryService(context, {
 *   endpoint: "https://my-wallet.com/fcl",
 *   provider: {
 *     name: "My Wallet",
 *     icon: "https://my-wallet.com/icon.png"
 *   }
 * })
 */
async function getDiscoveryService(context, service) {
  const discoveryAuthnInclude = await context.config.get("discovery.authn.include", []);
  const discoveryAuthnExclude = await context.config.get("discovery.authn.exclude", []);
  const discoveryFeaturesSuggested = await context.config.get("discovery.features.suggested", []);
  const discoveryWalletMethod = await context.config.first(["discovery.wallet.method", "discovery.wallet.method.default"], undefined);
  const method = service?.method ? service.method : discoveryWalletMethod;
  const endpoint = service?.endpoint ?? (await context.config.first(["discovery.wallet", "challenge.handshake"], undefined));
  invariant(endpoint, `
    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.
    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"
    `);
  return {
    ...service,
    type: "authn",
    endpoint,
    method,
    discoveryAuthnInclude,
    discoveryAuthnExclude,
    discoveryFeaturesSuggested
  };
}

let _isReactNative = false;

/**
 * @description Checks if the current environment is React Native. This function returns a boolean
 * indicating whether FCL is running in a React Native environment rather than a browser or Node.js.
 * This is useful for platform-specific functionality and enabling React Native-specific features.
 *
 * @returns True if running in React Native environment, false otherwise
 *
 * @example
 * // Check if running in React Native
 * import * as fcl from "@onflow/fcl"
 *
 * if (fcl.isReactNative()) {
 *   console.log("Running in React Native")
 *   // Use React Native specific wallet integrations
 *   // Enable deep linking for wallet connections
 * } else {
 *   console.log("Running in browser or Node.js")
 *   // Use web-based wallet integrations
 * }
 */
function isReactNative() {
  return _isReactNative;
}

/**
 * @description Sets the React Native environment flag for FCL. This function should be called during
 * initialization of React Native applications to inform FCL that it's running in a React Native
 * environment. This enables React Native-specific behaviors and optimizations.
 *
 * @param value True to indicate React Native environment, false otherwise
 *
 * @example
 * // Set React Native flag during app initialization
 * import * as fcl from "@onflow/fcl"
 *
 * // In your React Native app's entry point (e.g., App.js)
 * fcl.setIsReactNative(true)
 *
 * // Configure FCL for React Native
 * fcl.config({
 *   "accessNode.api": "https://rest-testnet.onflow.org",
 *   "discovery.wallet": "https://fcl-discovery.onflow.org/api/testnet/authn"
 * })
 */
function setIsReactNative(value) {
  _isReactNative = value;
}

// This is a workaround for an ongoing issue with URL in React Native
// It does not parse the URL correctly and appends trailing slashes
// See: https://github.com/facebook/react-native/issues/24428
// See: https://github.com/facebook/react-native/issues/24428

const _URL = globalThis.URL;
let URL$1 = class URL extends _URL {
  constructor(url, base) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    super(url, base, ...args);

    // Extra check if in React Native
    if (!isReactNative()) {
      return;
    }

    // Fix trailing slash issue
    if (this._url && !url.toString().endsWith("/") && this._url.endsWith("/")) {
      this._url = this._url.slice(0, -1);
    }
  }
};

/**
 * @description Fetches available wallet services from the discovery endpoint based on the
 * requested service types. This function queries the FCL discovery service to find compatible
 * wallet providers that support the specified service types.
 *
 * @param params Object containing the types of services to discover
 * @returns Promise resolving to an array of Service objects from the discovery endpoint
 *
 * @example
 * // Discover authentication services
 * const services = await getServices({ types: ["authn"] })
 * console.log(services) // Array of available wallet authentication services
 */
async function getServices(_ref) {
  let {
    context,
    types
  } = _ref;
  const endpoint = await context.config.get("discovery.authn.endpoint");
  invariant(Boolean(endpoint), `"discovery.authn.endpoint" in config must be defined.`);
  const include = await context.config.get("discovery.authn.include", []);
  const exclude = await context.config.get("discovery.authn.exclude", []);
  const url = new URL$1(endpoint);
  return fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      type: types,
      fclVersion: VERSION,
      include,
      exclude,
      features: {
        suggested: await context.config.get("discovery.features.suggested", [])
      },
      clientServices: await makeDiscoveryServices(),
      supportedStrategies: getServiceRegistry().getStrategies(),
      userAgent: window?.navigator?.userAgent,
      network: await getChainId()
    })
  }).then(d => d.json());
}

const SERVICE_ACTOR_KEYS = {
  AUTHN: "authn",
  RESULTS: "results",
  SNAPSHOT: "SNAPSHOT",
  UPDATED: "UPDATED",
  UPDATE_RESULTS: "UPDATE_RESULTS"
};
const warn = (fact, msg) => {
  if (fact) {
    console.warn(`
      %cFCL Warning
      ============================
      ${msg}
      For more info, please see the docs: https://docs.onflow.org/fcl/
      ============================
      `, "font-weight:bold;font-family:monospace;");
  }
};
const fetchServicesFromDiscovery = async context => {
  try {
    const services = await getServices({
      context,
      types: [SERVICE_ACTOR_KEYS.AUTHN]
    });
    send$1(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {
      results: services
    });
  } catch (error) {
    log({
      title: `${error.name} Error fetching Discovery API services.`,
      message: error.message,
      level: LEVELS.error
    });
  }
};
function createHandlers(context) {
  return {
    [INIT]: async ctx => {
      warn(typeof window === "undefined", '"fcl.discovery" is only available in the browser.');
      // If you call this before the window is loaded extensions will not be set yet
      if (document.readyState === "complete") {
        fetchServicesFromDiscovery(context);
      } else {
        window.addEventListener("load", () => {
          fetchServicesFromDiscovery(context);
        });
      }
    },
    [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {
      ctx.merge(data);
      ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {
        ...ctx.all()
      });
    },
    [SUBSCRIBE]: (ctx, letter) => {
      ctx.subscribe(letter.from);
      ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {
        ...ctx.all()
      });
    },
    [UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),
    [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) => letter.reply({
      ...ctx.all()
    })
  };
}
const spawnProviders = context => spawn(createHandlers(context), SERVICE_ACTOR_KEYS.AUTHN);

/**
 * Discovery authn service for interacting with Flow compatible wallets.
 *
 * Discovery abstracts away code so that developers don't have to deal with the discovery
 * of Flow compatible wallets, integration, or authentication. Using discovery from FCL
 * allows dapps to list and authenticate with wallets while having full control over the UI.
 * Common use cases for this are login or registration pages.
 *
 * NOTE: The following methods can only be used in web browsers.
 *
 * WARNING: discovery.authn.endpoint value MUST be set in the configuration before calling this method.
 *
 * @example
 * // Basic usage with React
 * import './config';
 * import { useState, useEffect } from 'react';
 * import * as fcl from '@onflow/fcl';
 *
 * function Component() {
 *   const [wallets, setWallets] = useState([]);
 *   useEffect(
 *     () => fcl.discovery.authn.subscribe((res) => setWallets(res.results)),
 *     [],
 *   );
 *
 *   return (
 *     <div>
 *       {wallets.map((wallet) => (
 *         <button
 *           key={wallet.provider.address}
 *           onClick={() => fcl.authenticate({ service: wallet })}
 *         >
 *           Login with {wallet.provider.name}
 *         </button>
 *       ))}
 *     </div>
 *   );
 * }
 *
 * // Configuration for opt-in services
 * import { config } from '@onflow/fcl';
 *
 * config({
 *   'discovery.authn.endpoint':
 *     'https://fcl-discovery.onflow.org/api/testnet/authn', // Endpoint set to Testnet
 *   'discovery.authn.include': ['0x9d2e44203cb13051'], // Ledger wallet address on Testnet set to be included
 *   'discovery.authn.exclude': ['0x123456789abcdef01'], // Example of excluding a wallet by address
 * });
 */
function createAuthn(context) {
  /**
   * @description Discovery methods for interacting with Authn.
   */
  const authn = {
    /**
     * Subscribe to Discovery authn services and receive real-time updates.
     *
     * This method allows you to subscribe to changes in the available authentication services.
     * When new services are discovered or existing ones are updated, the callback function will be invoked.
     *
     * @param cb Callback function that receives the list of available services and any error
     * @returns A function to unsubscribe from the service updates
     *
     * @example
     * import * as fcl from '@onflow/fcl';
     *
     * const unsubscribe = fcl.discovery.authn.subscribe((services, error) => {
     *   if (error) {
     *     console.error('Discovery error:', error);
     *     return;
     *   }
     *   console.log('Available services:', services);
     * });
     *
     * // Later, to stop receiving updates
     * unsubscribe();
     */
    subscribe: cb => subscriber(SERVICE_ACTOR_KEYS.AUTHN, () => spawnProviders(context), cb),
    /**
     * Get the current snapshot of Discovery authn services.
     *
     * This method returns a promise that resolves to the current state of available authentication services
     * without setting up a subscription. Useful for one-time checks or initial state loading.
     *
     * @returns A promise that resolves to the current service data
     *
     * @example
     * import * as fcl from '@onflow/fcl';
     *
     * async function getServices() {
     *   try {
     *     const serviceData = await fcl.discovery.authn.snapshot();
     *     console.log('Current services:', serviceData.results);
     *   } catch (error) {
     *     console.error('Failed to get services:', error);
     *   }
     * }
     */
    snapshot: () => snapshoter(SERVICE_ACTOR_KEYS.AUTHN, () => spawnProviders(context)),
    /**
     * Trigger an update of authn services from the discovery endpoint.
     *
     * This method manually triggers a refresh of the available authentication services
     * from the configured discovery endpoint. Useful when you want to force a refresh
     * of the service list.
     *
     * @example
     * import * as fcl from '@onflow/fcl';
     *
     * // Force refresh of available services
     * fcl.discovery.authn.update();
     */
    update: () => {
      // Only fetch services if the window is loaded
      // Otherwise, this will be called by the INIT handler
      if (document.readyState === "complete") {
        fetchServicesFromDiscovery(context);
      }
    }
  };
  return authn;
}
const authn = /* @__PURE__ */createAuthn(createPartialGlobalFCLContext());

const discovery = {
  authn
};

/**
 * @description Generates a SHA3-256 hash of a UTF-8 string. This function is commonly used in Flow
 * for creating deterministic hashes of Cadence code, interaction templates, and other string data
 * that need to be uniquely identified or verified for integrity.
 *
 * @param utf8String The UTF-8 string to hash
 * @returns The SHA3-256 hash of the input string as a hexadecimal string
 *
 * @example
 * // Generate hash of Cadence code
 * const cadenceCode = "access(all) fun main(): String { return \"Hello\" }"
 * const hash = genHash(cadenceCode)
 * console.log(hash) // "a1b2c3d4e5f6..." (64-character hex string)
 */
function genHash(utf8String) {
  const sha = new SHA3(256);
  sha.update(Buffer.from(utf8String, "utf8"));
  return sha.digest("hex");
}

/**
 * @description Generates Interaction Template ID for a given Interaction Template
 *
 * @param params
 * @param params.template Interaction Template
 * @returns Interaction Template ID
 */
async function generateTemplateId$2(_ref) {
  let {
    template
  } = _ref;
  invariant(!!template, "generateTemplateId({ template }) -- template must be defined");
  invariant(typeof template === "object", "generateTemplateId({ template }) -- template must be an object");
  invariant(template.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  invariant(template.f_version === "1.0.0", "generateTemplateId({ template }) -- template object must be an version 1.0.0");
  const templateData = template.data;
  const messages = await Promise.all(Object.keys(templateData.messages).map(async messageKey => [genHash(messageKey), await Promise.all(Object.keys(templateData.messages?.[messageKey]?.i18n).map(async i18nkeylanguage => [genHash(i18nkeylanguage), genHash(templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage])]))]));
  const dependencies = await Promise.all(Object.keys(templateData?.dependencies).map(async dependencyAddressPlaceholder => [genHash(dependencyAddressPlaceholder), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]).map(async dependencyContract => [genHash(dependencyContract), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]).map(async dependencyContractNetwork => [genHash(dependencyContractNetwork), [genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].address), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].contract), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].fq_address), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin), genHash(String(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin_block_height))]]))]))]));
  const _arguments = await Promise.all(Object.keys(templateData?.["arguments"]).map(async argumentLabel => [genHash(argumentLabel), [genHash(String(templateData?.["arguments"]?.[argumentLabel].index)), genHash(templateData?.["arguments"]?.[argumentLabel].type), genHash(templateData?.["arguments"]?.[argumentLabel].balance || ""), await Promise.all(Object.keys(templateData?.["arguments"]?.[argumentLabel].messages).map(async argumentMessageKey => [genHash(argumentMessageKey), await Promise.all(Object.keys(templateData?.["arguments"]?.[argumentLabel].messages?.[argumentMessageKey].i18n).map(async i18nkeylanguage => [genHash(i18nkeylanguage), genHash(templateData?.["arguments"]?.[argumentLabel].messages?.[argumentMessageKey].i18n?.[i18nkeylanguage])]))]))]]));
  const encodedHex = encode([genHash("InteractionTemplate"), genHash("1.0.0"), genHash(templateData?.type), genHash(templateData?.interface), messages, genHash(templateData?.cadence), dependencies, _arguments]).toString("hex");
  return genHash(encodedHex);
}

/**
 * @description Creates an ImportItem object from a contract name and address. This is a utility
 * function used to generate standardized import objects for interaction templates and dependency
 * management. The contract field is initialized as an empty string.
 *
 * @param params The parameters object containing contract details
 * @param params.contractName The name of the contract being imported
 * @param params.address The Flow address where the contract is deployed
 * @returns ImportItem object with contractName, address, and empty contract field
 *
 * @example
 * // Generate import for FlowToken contract
 * const importItem = generateImport({
 *   contractName: "FlowToken",
 *   address: "0x1654653399040a61"
 * })
 * console.log(importItem)
 * // { contractName: "FlowToken", address: "0x1654653399040a61", contract: "" }
 */
function generateImport(_ref) {
  let {
    contractName,
    address
  } = _ref;
  return {
    contractName,
    address,
    contract: ""
  };
}

/**
 * @description Parses a Cadence script or transaction to find all import statements and extracts
 * the contract names and addresses. This function uses regular expressions to identify import
 * statements and creates ImportItem objects for each imported contract.
 *
 * @param cadence The Cadence code string to parse for import statements
 * @returns Array of ImportItem objects containing contract names and addresses
 *
 * @example
 * // Parse imports from Cadence code
 * const cadenceCode = `
 *   import FlowToken from 0x1654653399040a61
 *   import FungibleToken, NonFungibleToken from 0x9a0766d93b6608b7
 *
 *   transaction() {
 *     // transaction code
 *   }
 * `
 *
 * const imports = findImports(cadenceCode)
 * console.log(imports)
 * // [
 * //   { contractName: "FlowToken", address: "0x1654653399040a61", contract: "" },
 * //   { contractName: "FungibleToken", address: "0x9a0766d93b6608b7", contract: "" },
 * //   { contractName: "NonFungibleToken", address: "0x9a0766d93b6608b7", contract: "" }
 * // ]
 */
function findImports(cadence) {
  const imports = [];
  const importsReg = /import ((\w|,| )+)* from 0x\w+/g;
  const fileImports = cadence.match(importsReg) || [];
  for (const fileImport of fileImports) {
    const importLineReg = /import ((\w+|, |)*) from (0x\w+)/g;
    const importLine = importLineReg.exec(fileImport);
    const contractsReg = /((?:\w+)+),?/g;
    const contracts = importLine?.[1].match(contractsReg) || [];
    for (const contract of contracts) {
      imports.push(generateImport({
        address: importLine?.[3],
        contractName: contract.replace(/,/g, "")
      }));
    }
  }
  return imports;
}

function createGenerateDependencyPin110(context) {
  /**
   * @description Produces a dependency pin for a contract at current state of chain
   * @param params
   * @param params.address The address of the account containing the contract
   * @param params.contractName The name of the contract
   * @param params.blockHeight The block height to generate the dependency pin at
   * @param opts Options to pass to the interaction
   * @returns The dependency pin
   */
  async function generateDependencyPin110(_ref) {
    let {
      address,
      contractName
    } = _ref;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    invariant$1(address != undefined, "generateDependencyPin({ address }) -- address must be defined");
    invariant$1(contractName != undefined, "generateDependencyPin({ contractName }) -- contractName must be defined");
    invariant$1(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
    invariant$1(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
    const horizon = [generateImport({
      contractName,
      address
    })];
    for (const horizonImport of horizon) {
      const account = await context.sdk.send([getAccount(await context.config.get(horizonImport.address, horizonImport.address))], opts).then(context.sdk.decode);
      horizonImport.contract = account.contracts?.[horizonImport.contractName];
      if (!horizonImport.contract) {
        console.error("Did not find expected contract", horizonImport, account);
        throw new Error("Did not find expected contract");
      }
      const contractImports = findImports(horizonImport.contract);
      horizon.push(...contractImports);
    }
    const contractPinSelfHashesPromises = horizon.map(iport => genHash(iport.contract));
    // genHash returns a promise, so we need to await the results of all the promises
    const contractPinSelfHashes = await Promise.all(contractPinSelfHashesPromises);
    const contractPinHashes = contractPinSelfHashes.join("");
    return genHash(contractPinHashes);
  }
  return generateDependencyPin110;
}
const generateDependencyPin110 = /* @__PURE__ */createGenerateDependencyPin110(createPartialGlobalFCLContext());

async function generateContractNetworks(context, contractName, networks) {
  const values = [];
  for (const net of networks) {
    const networkHashes = [genHash(net.network)];
    const {
      address,
      dependency_pin_block_height
    } = net;
    if (net.dependency_pin) {
      const hash = await createGenerateDependencyPin110(context)({
        address,
        contractName,
        blockHeight: dependency_pin_block_height
      });
      networkHashes.push(genHash(hash));
    }
    values.push(networkHashes);
  }
  return values;
}
async function generateContractDependencies(context, dependencies) {
  const values = [];
  for (let i = 0; i < dependencies.length; i++) {
    const dependency = dependencies[i];
    const contracts = [];
    for (let j = 0; j < dependency?.contracts.length; j++) {
      const c = dependency?.contracts[j];
      const contractName = c?.contract;
      contracts.push(genHash(contractName));
      const contractHashes = await generateContractNetworks(context, contractName, c?.networks);
      contracts.push(contractHashes);
    }
    values.push(contracts);
  }
  return values;
}
function createGenerateTemplateId(context) {
  /**
   * @description Generates Interaction Template ID for a given Interaction Template
   *
   * @param params
   * @param params.template Interaction Template
   * @returns Interaction Template ID
   */
  async function generateTemplateId(_ref) {
    let {
      template
    } = _ref;
    invariant(!!template, "generateTemplateId({ template }) -- template must be defined");
    invariant(typeof template === "object", "generateTemplateId({ template }) -- template must be an object");
    invariant(template.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
    invariant(template.f_version === "1.1.0", "generateTemplateId({ template }) -- template object must be an version 1.1.0");
    const templateData = template.data;
    const messages = await Promise.all(templateData.messages.map(async templateMessage => [genHash(templateMessage.key), await Promise.all(templateMessage.i18n.map(async templateMessagei18n => [genHash(templateMessagei18n.tag), genHash(templateMessagei18n.translation)]))]));
    const params = await Promise.all(templateData?.["parameters"].sort((a, b) => a.index - b.index).map(async arg => [genHash(arg.label), [genHash(String(arg.index)), genHash(arg.type), await Promise.all(arg.messages.map(async argumentMessage => [genHash(argumentMessage.key), await Promise.all(argumentMessage.i18n.map(async argumentMessagei18n => [genHash(argumentMessagei18n.tag), genHash(argumentMessagei18n.translation)]))]))]]));
    const dependencies = [await generateContractDependencies(context, templateData?.dependencies)];
    const encodedHex = encode([genHash(template?.f_type), genHash(template?.f_version), genHash(templateData?.type), genHash(templateData?.interface), messages, genHash(templateData?.cadence?.body), [dependencies], params]).toString("hex");
    return genHash(encodedHex);
  }
  return generateTemplateId;
}
const generateTemplateId$1 = /* @__PURE__ */createGenerateTemplateId(createPartialGlobalFCLContext());

/**
 * @description Generates Interaction Template ID for a given Interaction Template
 *
 * @param params
 * @param params.template Interaction Template
 * @returns Interaction Template ID
 */
async function generateTemplateId(_ref) {
  let {
    template
  } = _ref;
  invariant(!!template, "generateTemplateId({ template }) -- template must be defined");
  invariant(typeof template === "object", "generateTemplateId({ template }) -- template must be an object");
  invariant(template.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      return await generateTemplateId$1({
        template
      });
    case "1.0.0":
      return await generateTemplateId$2({
        template
      });
    default:
      throw new Error("generateTemplateId Error: Unsupported template version");
  }
}

/**
 * @description Verifies the given Interaction Template Id has been correctly generated
 *
 * @param params
 * @param params.template Interaction Template
 * @returns true or false, Interaction Template ID
 */
async function verifyGeneratedTemplateId(_ref2) {
  let {
    template
  } = _ref2;
  return template.id === (await generateTemplateId({
    template
  }));
}

/**
 * @description Checks whether a set of auditors have audited a given Interaction Template on the Flow
 * blockchain. This function validates that the provided interaction template has been properly audited
 * for security by trusted auditors before execution. It queries the Flow blockchain's audit contract
 * to verify audit status.
 *
 * @param params
 * @param params.template The Interaction Template to check audits for. Must be
 * a valid InteractionTemplate object with f_type "InteractionTemplate"
 * @param params.auditors Array of auditor addresses to check. If not provided, will use
 * auditors from configuration 'flow.auditors'
 * @param opts Optional configuration parameters
 * @param opts.flowInteractionAuditContract Override address for the FlowInteractionAudit
 * contract if not using network defaults
 *
 * @returns Promise that resolves to an object mapping auditor
 * addresses to boolean values indicating whether they have audited the template
 *
 * @throws If template is invalid, template ID cannot be recomputed, network is unsupported,
 * or required configuration is missing
 *
 * @example
 * // Check if template has been audited by specific auditors
 * import * as fcl from "@onflow/fcl"
 *
 * const template = {
 *   f_type: "InteractionTemplate",
 *   f_version: "1.1.0",
 *   id: "template-id-123",
 *   data: {
 *     type: "transaction",
 *     interface: "...",
 *     cadence: "transaction { ... }"
 *   }
 * }
 *
 * const auditorAddresses = [
 *   "0x1234567890abcdef",
 *   "0xabcdef1234567890"
 * ]
 *
 * const auditResults = await fcl.InteractionTemplateUtils.getInteractionTemplateAudits({
 *   template,
 *   auditors: auditorAddresses
 * })
 *
 * console.log(auditResults)
 * // { "0x1234567890abcdef": true, "0xabcdef1234567890": false }
 */
async function getInteractionTemplateAudits(context, _ref) {
  let {
    template,
    auditors
  } = _ref;
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  invariant$1(template != undefined, "getInteractionTemplateAudits({ template }) -- template must be defined");
  invariant$1(template.f_type === "InteractionTemplate", "getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");

  // Recompute ID to be sure it matches
  let recomputedTemplateID = await generateTemplateId({
    template
  });
  if (recomputedTemplateID !== template.id) {
    log({
      title: "getInteractionTemplateAudits Debug Error",
      message: `Could not recompute and match template ID
                computed: ${recomputedTemplateID}
                template: ${template.id}
            `,
      level: LEVELS.debug
    });
    throw new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");
  }
  switch (template.f_version) {
    case "1.1.0":
    case "1.0.0":
      const _auditors = auditors || (await context.config.get("flow.auditors"));
      invariant$1(_auditors, "getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set");
      invariant$1(Array.isArray(_auditors), "getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");
      let FlowInteractionAuditContract = opts.flowInteractionAuditContract;
      if (!FlowInteractionAuditContract) {
        const fclNetwork = await createGetChainId(context)(opts);
        invariant$1(fclNetwork === "mainnet" || fclNetwork === "testnet", "getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'");
        if (fclNetwork === "mainnet") {
          FlowInteractionAuditContract = "0xfd100e39d50a13e6";
        } else {
          FlowInteractionAuditContract = "0xf78bfc12d0a786dc";
        }
      }
      const audits = await createQuery(context)({
        cadence: `
        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}
        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {
          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)
        }
        `,
        args: (arg, t) => [arg(recomputedTemplateID, t.String), arg(_auditors, t.Array(t.Address))]
      });
      return audits;
    default:
      throw new Error("getInteractionTemplateAudits Error: Unsupported template version");
  }
}

function creategenerateDependencyPin100(context) {
  /**
   * @description Produces a dependency pin for a contract at current state of chain
   * @param params
   * @param params.address The address of the account containing the contract
   * @param params.contractName The name of the contract
   * @param opts Options to pass to the interaction
   * @returns The dependency pin
   */
  async function generateDependencyPin100(_ref) {
    let {
      address,
      contractName
    } = _ref;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    invariant$1(address != undefined, "generateDependencyPin({ address }) -- address must be defined");
    invariant$1(contractName != undefined, "generateDependencyPin({ contractName }) -- contractName must be defined");
    invariant$1(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
    invariant$1(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
    const horizon = [generateImport({
      contractName,
      address
    })];
    for (const horizonImport of horizon) {
      const account = await context.sdk.send([getAccount(await context.config.get(horizonImport.address, horizonImport.address))], opts).then(context.sdk.decode);
      horizonImport.contract = account.contracts?.[horizonImport.contractName];
      if (!horizonImport.contract) {
        console.error("Did not find expected contract", horizonImport, account);
        throw new Error("Did not find expected contract");
      }
      const contractImports = findImports(horizonImport.contract);
      horizon.push(...contractImports);
    }
    const contractHashes = horizon.map(iport => genHash(iport.contract));
    const contractHashesJoined = contractHashes.join("");
    return genHash(contractHashesJoined);
  }
  return generateDependencyPin100;
}
const generateDependencyPin100 = /* @__PURE__ */creategenerateDependencyPin100(createPartialGlobalFCLContext());

/**
 * @description Generates a dependency pin for a smart contract on the Flow blockchain. A dependency
 * pin is a cryptographic hash that uniquely identifies a specific version of a contract at a particular
 * state. This is used in Interaction Templates to ensure consistent behavior by pinning to specific
 * contract versions and preventing issues from contract updates.
 *
 * @param params
 * @param params.version The version of the interaction template (e.g., "1.0.0", "1.1.0")
 * @param params.address The Flow account address containing the contract (with or without 0x prefix)
 * @param params.contractName The name of the contract to generate a pin for
 * @param params.blockHeight Optional specific block height to pin to
 * @param opts Additional options to pass to the underlying interaction
 *
 * @returns Promise that resolves to the dependency pin as a string
 *
 * @throws If required parameters are missing or invalid, or if the template version is unsupported
 *
 * @example
 * // Generate dependency pin for a contract at current state
 * import * as fcl from "@onflow/fcl"
 *
 * const dependencyPin = await fcl.InteractionTemplateUtils.generateDependencyPin({
 *   version: "1.1.0",
 *   address: "0x1654653399040a61",
 *   contractName: "FlowToken"
 * })
 */
async function generateDependencyPin(_ref) {
  let {
    version,
    address,
    contractName
  } = _ref;
  invariant$1(address != undefined, "generateDependencyPin({ address }) -- address must be defined");
  invariant$1(contractName != undefined, "generateDependencyPin({ contractName }) -- contractName must be defined");
  invariant$1(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  invariant$1(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  switch (version) {
    case "1.1.0":
      return await generateDependencyPin110({
        address,
        contractName
      });
    case "1.0.0":
      return await generateDependencyPin100({
        address,
        contractName
      });
    default:
      throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
  }
}

/**
 * @description Generates a dependency pin for a smart contract at the latest sealed block on the Flow
 * blockchain. This variant ensures the pin is generated against the most recent finalized state of the
 * network, providing consistency and avoiding issues with pending transactions affecting the pin generation.
 *
 * @param params
 * @param params.version The version of the interaction template (e.g., "1.0.0", "1.1.0")
 * @param params.address The Flow account address containing the contract (with or without 0x prefix)
 * @param params.contractName The name of the contract to generate a pin for
 * @param params.blockHeight This parameter is ignored as the function always uses latest sealed block
 * @param opts Additional options to pass to the underlying interaction
 *
 * @returns Promise that resolves to the dependency pin as a string
 *
 * @throws If required parameters are missing or invalid, template version is unsupported,
 * or if unable to fetch the latest sealed block
 *
 * @example
 * // Generate dependency pin at latest sealed block
 * import * as fcl from "@onflow/fcl"
 *
 * const dependencyPin = await fcl.InteractionTemplateUtils.generateDependencyPinAtLatestSealedBlock({
 *   version: "1.1.0",
 *   address: "0x1654653399040a61",
 *   contractName: "FlowToken"
 * })
 */
async function generateDependencyPinAtLatestSealedBlock(_ref2) {
  let {
    version,
    address,
    contractName
  } = _ref2;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const latestSealedBlock = await block({
    sealed: true
  }, opts);
  latestSealedBlock?.height;
  return generateDependencyPin({
    version,
    address,
    contractName});
}

/**
 * @description Checks if an Interaction Template's pins match those generated at a block height
 *
 * @param params
 * @param params.template Interaction Template to check pins for
 * @param params.blockHeight Block height to check pins at
 * @param params.network Network to check pins on
 * @param opts
 * @returns Whether or not the pins match
 */
async function verifyDependencyPinsSame(_ref) {
  let {
    template,
    blockHeight,
    network
  } = _ref;
  invariant$1(template != undefined, "generateDependencyPin({ template }) -- template must be defined");
  invariant$1(typeof template === "object", "generateDependencyPin({ template }) -- template must be an object");
  invariant$1(template.f_type === "InteractionTemplate", "generateDependencyPin({ template }) -- template must be an InteractionTemplate");
  invariant$1(network != undefined, "generateDependencyPin({ network }) network must be defined");
  invariant$1(blockHeight != undefined, "generateDependencyPin({ blockHeight }) blockHeight must be defined");
  invariant$1(typeof blockHeight === "number", "generateDependencyPin({ blockHeight }) blockHeight must be a number");
  switch (template.f_version) {
    case "1.0.0":
      const templateDependenciesPlaceholderKeys = Object.keys(template.data.dependencies);
      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {
        const templateDependencyPlaceholder = template.data.dependencies[templateDependencyPlaceholderKey];
        const templateDependencyPlaceholderContractNames = Object.keys(templateDependencyPlaceholder);
        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {
          const templateDependencyPlaceholderContractNetworks = template.data.dependencies[templateDependencyPlaceholderKey][templateDependencyPlaceholderContractName];
          const templateDependency = templateDependencyPlaceholderContractNetworks[network];
          if (typeof templateDependency === "undefined") continue;
          const pin = await generateDependencyPin({
            address: templateDependency.address,
            contractName: templateDependency.contract});
          if (pin !== templateDependency.pin) {
            log({
              title: "verifyDependencyPinsSame Debug Error",
              message: `Could not recompute and match dependency pin.
                                address: ${templateDependency.address} | contract: ${templateDependency.contract}
                                computed: ${pin}
                                template: ${templateDependency.pin}
                            `,
              level: LEVELS.debug
            });
            return false;
          }
        }
      }
      return true;
    case "1.1.0":
      let isVerified = false;
      // iterate over each dependency
      for (let i = 0; i < template.data?.dependencies.length; i++) {
        const dependency = template.data?.dependencies[i];
        // iterate over each contract in dependency
        for (let j = 0; j < dependency?.contracts.length; j++) {
          const contract = dependency?.contracts[j];
          // iterate over each network in contract
          for (let k = 0; k < contract?.networks.length; k++) {
            const net = contract?.networks[k];
            // if network matches, generate pin and compare
            if (net.network === network) {
              const pin = await generateDependencyPin({
                version: template.f_version,
                address: net.address,
                contractName: contract.contract});
              if (pin !== net.dependency_pin.pin) {
                log({
                  title: "verifyDependencyPinsSame Debug Error",
                  message: `Could not recompute and match dependency pin.
                                    address: ${net.address} | contract: ${contract.contract}
                                    computed: ${pin}
                                    template: ${net.pin}
                                `,
                  level: LEVELS.debug
                });
                return false;
              } else {
                isVerified = true;
              }
            }
          }
        }
      }
      return isVerified;
    default:
      throw new Error("verifyDependencyPinsSame Error: Unsupported template version");
  }
}

/**
 * @description Checks if an Interaction Template's pins match those generated at the latest block height
 *
 * @param params
 * @param params.template Interaction Template to check pins for
 * @param params.network Network to check pins on
 * @param opts
 * @returns Whether or not the pins match
 */
async function verifyDependencyPinsSameAtLatestSealedBlock(_ref2) {
  let {
    template,
    network
  } = _ref2;
  const latestSealedBlock = await block({
    sealed: true
  });
  const latestSealedBlockHeight = latestSealedBlock?.height;
  return verifyDependencyPinsSame({
    template,
    network,
    blockHeight: latestSealedBlockHeight
  });
}

/**
 * @description Get Interaction Template argument message
 *
 * @param params
 * @param params.localization [localization="en-US"] Localization code
 * @param params.messageKey Message key
 * @param params.template Interaction Template
 * @returns Message
 */
function getTemplateMessage(_ref) {
  let {
    localization = "en-US",
    messageKey,
    template
  } = _ref;
  invariant(messageKey, "getTemplateMessage({ messageKey }) -- messageKey must be defined");
  invariant(typeof messageKey === "string", "getTemplateMessage({ messageKey }) -- messageKey must be a string");
  invariant(localization, "getTemplateMessage({ localization }) -- localization must be defined");
  invariant(typeof localization === "string", "getTemplateMessage({ localization }) -- localization must be a string");
  invariant(template != undefined, "getTemplateMessage({ template }) -- template must be defined");
  invariant(typeof template === "object", "getTemplateMessage({ template }) -- template must be an object");
  invariant(template.f_type === "InteractionTemplate", "getTemplateMessage({ template }) -- template object must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      const msg = template?.data?.messages?.find(a => a.key === messageKey);
      if (!msg) return undefined;
      const lzn = msg?.i18n?.find(a => a.tag === localization);
      if (!lzn) return undefined;
      return lzn.translation;
    case "1.0.0":
      return template?.data?.messages?.[messageKey]?.i18n?.[localization];
    default:
      throw new Error("getTemplateArgumentMessage Error: Unsupported template version");
  }
}

/**
 * @description Gets Interaction Template argument message by message key, argument label, and localization
 *
 * @param params
 * @param params.localization [localization="en-US"] Localization to get message for
 * @param params.argumentLabel Argument label to get message for
 * @param params.messageKey Message key to get message for
 * @param params.template Interaction Template to get message from
 * @returns Message
 */
function getTemplateArgumentMessage(_ref) {
  let {
    localization = "en-US",
    argumentLabel,
    messageKey,
    template
  } = _ref;
  invariant$1(messageKey, "getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined");
  invariant$1(typeof messageKey === "string", "getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string");
  invariant$1(argumentLabel, "getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined");
  invariant$1(typeof argumentLabel === "string", "getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string");
  invariant$1(localization, "getTemplateArgumentMessage({ localization }) -- localization must be defined");
  invariant$1(typeof localization === "string", "getTemplateArgumentMessage({ localization }) -- localization must be a string");
  invariant$1(template != undefined, "getTemplateArgumentMessage({ template }) -- template must be defined");
  invariant$1(typeof template === "object", "getTemplateArgumentMessage({ template }) -- template must be an object");
  invariant$1(template.f_type === "InteractionTemplate", "getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      const param = template?.data?.parameters?.find(a => a.label === argumentLabel);
      if (!param) return undefined;
      const message = param?.messages?.find(a => a.key === messageKey);
      if (!message) return undefined;
      const lzn = message?.i18n?.find(a => a.tag === localization);
      if (!lzn) return undefined;
      return lzn.translation;
    case "1.0.0":
      return template?.data?.arguments?.[argumentLabel]?.messages?.[messageKey]?.i18n?.[localization];
    default:
      throw new Error("getTemplateArgumentMessage Error: Unsupported template version");
  }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deriveCadenceByNetwork: deriveCadenceByNetwork,
  generateDependencyPin: generateDependencyPin,
  generateDependencyPinAtLatestSealedBlock: generateDependencyPinAtLatestSealedBlock,
  generateTemplateId: generateTemplateId,
  getInteractionTemplateAudits: getInteractionTemplateAudits,
  getTemplateArgumentMessage: getTemplateArgumentMessage,
  getTemplateMessage: getTemplateMessage,
  verifyDependencyPinsSame: verifyDependencyPinsSame,
  verifyDependencyPinsSameAtLatestSealedBlock: verifyDependencyPinsSameAtLatestSealedBlock,
  verifyGeneratedTemplateId: verifyGeneratedTemplateId
});

/**
 * @description Factory function that returns a mutate function for a given currentUser.
 *
 * @param currentUserOrConfig CurrentUser actor or configuration
 */
const createMutate = context => {
  /**
   * @description Allows you to submit transactions to the blockchain to potentially mutate the state.
   *
   * When being used in the browser, `fcl.mutate` uses the built-in `fcl.authz` function to produce the authorization (signatures) for the current user. When calling this method from Node.js, you will need to supply your own custom authorization function.
   *
   * @param opts Mutation options configuration
   * @param opts.cadence A valid cadence transaction (required)
   * @param opts.args Any arguments to the script if needed should be supplied via a function that returns an array of arguments
   * @param opts.limit Compute (Gas) limit for query.
   * @param opts.proposer The authorization function that returns a valid AuthorizationObject for the proposer role
   * @param opts.template Interaction Template for a transaction
   * @param opts.authz Authorization function for transaction
   * @param opts.payer Payer Authorization function for transaction
   * @param opts.authorizations Authorizations function for transaction
   * @returns The transaction ID
   *
   * @example
   * import * as fcl from '@onflow/fcl';
   * // login somewhere before
   * fcl.authenticate();
   *
   * const txId = await fcl.mutate({
   *   cadence: `
   *     import Profile from 0xba1132bc08f82fe2
   *
   *     transaction(name: String) {
   *       prepare(account: auth(BorrowValue) &Account) {
   *         account.storage.borrow<&{Profile.Owner}>(from: Profile.privatePath)!.setName(name)
   *       }
   *     }
   *   `,
   *   args: (arg, t) => [arg('myName', t.String)],
   * });
   */
  const mutate = async function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var txid;
    try {
      await preMutate(context, opts);
      opts = await prepTemplateOpts(context, opts);
      // Allow for a config to overwrite the authorization function.
      // prettier-ignore
      const authz = await context.config.get("fcl.authz", context.currentUser.authorization);
      txid = context.sdk.send([sdk.transaction(opts.cadence), sdk.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && sdk.limit(opts.limit),
      // opts.proposer > opts.authz > authz
      sdk.proposer(opts.proposer || opts.authz || authz),
      // opts.payer > opts.authz > authz
      sdk.payer(opts.payer || opts.authz || authz),
      // opts.authorizations > [opts.authz > authz]
      sdk.authorizations(opts.authorizations || [opts.authz || authz])]).then(context.sdk.decode);
      return txid;
    } catch (error) {
      throw error;
    }
  };
  return mutate;
};

/**
 * @description Legacy factory function that creates a mutate function using global FCL context.
 * This function provides backward compatibility for code that was written before the
 * introduction of dependency injection patterns in FCL. It creates a mutate function
 * by combining a partial global context with a provided current user service.
 *
 * This function is considered legacy and should be used primarily for backward compatibility.
 * New code should prefer using the `createMutate` function with a complete FCL context
 * for better testability and dependency management.
 *
 * The function creates a partial context using global configuration and SDK methods,
 * then combines it with the provided current user service to create a fully functional
 * mutate function.
 *
 * @param currentUserOrConfig The current user service instance that provides authentication
 * and authorization capabilities. This service must implement the CurrentUserService interface
 * and provide methods for user authentication, authorization, and session management.
 *
 * @returns A mutate function that can submit transactions to the Flow blockchain.
 * The returned function accepts the same options as the standard mutate function:
 * - cadence: The Cadence transaction code to execute
 * - args: Function that returns transaction arguments
 * - template: Interaction template for standardized transactions
 * - limit: Compute limit for the transaction
 * - authz: Authorization function for all roles
 * - proposer: Specific authorization for proposer role
 * - payer: Specific authorization for payer role
 * - authorizations: Array of authorization functions for authorizer roles
 *
 * @example
 * // Legacy usage with global context
 * import { getMutate } from "@onflow/fcl-core"
 * import { getCurrentUser } from "@onflow/fcl-core"
 *
 * // Get the current user service
 * const currentUser = getCurrentUser({ platform: "web" })
 *
 * // Create mutate function using legacy pattern
 * const mutate = getMutate(currentUser)
 *
 * // Use the mutate function
 * const txId = await mutate({
 *   cadence: `
 *     transaction {
 *       execute { log("Hello, Flow!") }
 *     }
 *   `
 * })
 */
const getMutate = currentUserOrConfig => {
  const partialContext = createPartialGlobalFCLContext();
  const context = {
    ...partialContext,
    currentUser: currentUserOrConfig
  };
  return createMutate(context);
};

/**
 * @description Normalizes a composite signature to ensure compatibility with FCL format
 *
 * @param resp The composite signature to normalize
 * @returns The normalized composite signature or null
 *
 * @example
 * const resp = normalizeCompositeSignature({
 *   f_type: "CompositeSignature",
 *   f_vsn: "1.0.0",
 *   addr: "_____",         // sans-prefix
 *   signature: "adfe1234", // hex
 *   keyId: 3,
 * })
 */
function normalizeCompositeSignature(resp) {
  if (resp == null) return null;
  if (!resp["f_vsn"]) {
    return {
      ...COMPOSITE_SIGNATURE_PRAGMA,
      addr: sansPrefix(resp.addr || resp.address),
      signature: resp.signature || resp.sig,
      keyId: resp.keyId
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}

/**
 * @description Normalizes an authn service to ensure compatibility with FCL service format
 *
 * @param service The authn service to normalize
 * @returns The normalized authn service or null
 *
 * @example
 * const service = normalizeAuthn({
 *   f_type: "Service",
 *   f_vsn: "1.0.0",
 *   type: "authn",
 *   uid: "uniqueDedupeKey",
 *   endpoint: "https://rawr",
 *   id: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
 *   identity: {
 *     address: "0x____"
 *   },
 *   provider: {
 *     address: "0x____",
 *     name: "Best Wallet",
 *     description: "The Best Wallet",
 *     icon: "https://",
 *   }
 * })
 */
function normalizeAuthn(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.authn,
      id: service.pid,
      provider: {
        address: withPrefix(service.addr),
        name: service.name,
        icon: service.icon
      }
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes an authz service to ensure compatibility with FCL service format
 *
 * @param service The authz service to normalize
 * @returns The normalized authz service or null
 *
 * @example
 * const service = normalizeAuthz({
 *   f_type: "service",
 *   f_vsn: "1.0.0",
 *   type: "authz",
 *   uid: "uniqueDedupeKey",
 *   endpoint: "https://rawr",
 *   method: "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
 *   identity: {
 *     address: "0x______",
 *     keyId: 0,
 *   },
 *   data: {}, // included in body of authz request
 *   params: {}, // included as query params on endpoint url
 * })
 */
function normalizeAuthz(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.endpoint,
      method: service.method,
      identity: {
        ...IDENTITY_PRAGMA,
        address: withPrefix(service.addr),
        keyId: service.keyId
      },
      params: service.params,
      data: service.data
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes a pre-authz service to ensure compatibility with FCL service format
 *
 * @param service The pre-authz service to normalize
 * @returns The normalized pre-authz service or null
 *
 * @example
 * const service = normalizePreAuthz({
 *   f_type: "service",
 *   f_vsn: "1.0.0",
 *   type: "pre-authz",
 *   uid: "uniqueDedupeKey",
 *   endpoint: "https://rawr",
 *   method: "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
 *   identity: {
 *     address: "0x______",
 *     keyId: 0,
 *   },
 * })
 */
function normalizePreAuthz(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.endpoint,
      method: service.method,
      identity: {
        ...IDENTITY_PRAGMA,
        address: withPrefix(service.addr),
        keyId: service.keyId
      },
      params: service.params,
      data: service.data
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes a frame service to ensure compatibility with FCL service format
 *
 * @param service The frame service to normalize
 * @returns The normalized frame service or null
 *
 * @example
 * const service = normalizeFrame({
 *   f_type: "Service",
 *   f_vsn: "1.0.0",
 *   type: "frame",
 *   endpoint: "https://rawr",
 *   data: {},   // Sent to frame when ready
 *   params: {}, // include in query params on frame
 * })
 */
function normalizeFrame(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      old: service,
      ...SERVICE_PRAGMA,
      type: "frame",
      endpoint: service.endpoint,
      params: service.params || {},
      data: service.data || {}
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes a back-channel-rpc service to ensure compatibility with FCL service format
 *
 * @param service The back-channel-rpc service to normalize
 * @returns The normalized back-channel-rpc service or null
 *
 * @example
 * const service = normalizeBackChannelRpc({
 *   f_type: "Service",
 *   f_vsn: "1.0.0",
 *   type: "back-channel-rpc",
 *   endpoint: "https://rawr",
 *   method: "HTTP/GET", // HTTP/GET | HTTP/POST
 *   data: {},           // included in body of rpc
 *   params: {},         // included as query params on endpoint url
 * })
 */
function normalizeBackChannelRpc(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: "back-channel-rpc",
      endpoint: service.endpoint,
      method: service.method,
      params: service.params || {},
      data: service.data || {}
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes an open-id service to ensure compatibility with FCL service format
 *
 * @param service The open-id service to normalize
 * @returns The normalized open-id service or null
 *
 * @example
 * const service = normalizeOpenId({
 *   f_type: "Service",
 *   f_vsn: "1.0.0",
 *   type: "open-id",
 *   uid: "uniqueDedupeKey",
 *   method: "data",
 *   data: {
 *      profile: {
 *        name: "Bob",
 *        family_name: "Builder",
 *        given_name: "Robert",
 *        middle_name: "the",
 *        nickname: "Bob the Builder",
 *        preferred_username: "bob",
 *        profile: "https://www.bobthebuilder.com/",
 *        picture: "https://avatars.onflow.org/avatar/bob",
 *        gender: "...",
 *        birthday: "2001-01-18",
 *        zoneinfo: "America/Vancouver",
 *        locale: "en-us",
 *        updated_at: "1614970797388"
 *      },
 *      email: {
 *        email: "bob@bob.bob",
 *        email_verified: true
 *      },
 *      address: {
 *        address: "One Apple Park Way, Cupertino, CA 95014, USA"
 *      },
 *      phone: {
 *        phone_number: "+1 (xxx) yyy-zzzz",
 *        phone_number_verified: true
 *      },
 *      social: {
 *        twitter: "@_qvvg",
 *        twitter_verified: true
 *      },
 *   }
 * })
 */
function normalizeOpenId(service) {
  if (service == null) return null;
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes a user-signature service to ensure compatibility with FCL service format
 *
 * @param service The user-signature service to normalize
 * @returns The normalized user-signature service or null
 *
 * @example
 * const service = {
 *   "f_type": "Service",
 *   "f_vsn": "1.0.0",
 *   "type": "user-signature",
 *   "uid": "uniqueDedupeKey",
 *   "endpoint": "https://rawr",
 *   "method": "IFRAME/RPC", // HTTP/POST | IFRAME/RPC | HTTP/RPC
 *   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
 *   "data": {}, // included in body of user-signature request
 *   "params": {}, // included as query params on endpoint url
 * }
 */
function normalizeUserSignature(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error("Invalid user-signature service");
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes a local-view service to ensure compatibility with FCL format
 *
 * @param resp The local-view to normalize
 * @returns The normalized local-view or null
 *
 * @example
 * const service = normalizeLocalView({
 *   f_type: "Service",
 *   f_vsn: "1.0.0",
 *   type: "local-view",
 *   method: "VIEW/IFRAME",
 *   endpoint: "https://woot.org/authz/local",
 *   data: {},
 *   params: {},
 * })
 */
function normalizeLocalView(resp) {
  if (resp == null) return null;
  if (resp.method == null) {
    resp = {
      ...resp,
      type: "local-view",
      method: "VIEW/IFRAME"
    };
  }
  if (!resp["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: resp.type || "local-view",
      method: resp.method,
      endpoint: resp.endpoint,
      data: resp.data || {},
      params: resp.params || {}
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}

/**
 * @description Normalizes an account-proof service to ensure compatibility with FCL service format
 *
 * @param service The account-proof service to normalize
 * @returns The normalized account-proof service or null
 *
 * @example
 * {
 *   "f_type": "Service",                    // Its a service!
 *   "f_vsn": "1.0.0",                       // Follows the v1.0.0 spec for the service
 *   "type": "account-proof",                // the type of service it is
 *   "method": "DATA",                       // Its data!
 *   "uid": "awesome-wallet#account-proof",  // A unique identifier for the service
 *   "data": {
 *     "f_type": "account-proof",
 *     "f_vsn": "1.0.0",
 *     "nonce": "0A1BC2FF",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)
 *     "address": "0xUSER",                  // The user's address (8 bytes, i.e 16 hex characters)
 *     "signature": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)
 * }
 */
function normalizeAccountProof(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error(`FCL Normalizer Error: Invalid account-proof service`);
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes an authn-refresh service to ensure compatibility with FCL service format
 *
 * @param service The authn-refresh service to normalize
 * @returns The normalized authn-refresh service or null
 *
 * @example
 * const service = normalizeAuthnRefresh({
 *   f_type: "Service",
 *   f_vsn: "1.0.0",
 *   type: "authn-refresh",
 *   uid: "uniqueDedupeKey",
 *   endpoint: "https://rawr",
 *   method: "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
 *   id: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
 *   data: {}, // included in body of request
 *   params: {}, // included as query params on endpoint url
 * })
 */
function normalizeAuthnRefresh(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error("Invalid authn-refresh service");
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

/**
 * @description Normalizes an array of services by applying type-specific normalization to each service.
 * This function processes multiple services in batch, applying the appropriate normalizer based on
 * each service's type, and filters out any services that fail normalization.
 *
 * @param services Array of services to normalize
 * @param data Optional additional data to pass to individual service normalizers
 * @returns Array of normalized services with invalid services filtered out
 *
 * @example
 * // Normalize multiple services from wallet discovery
 * const rawServices = [
 *   { type: "authn", endpoint: "https://wallet.com/authn", ... },
 *   { type: "authz", endpoint: "https://wallet.com/authz", ... },
 *   { type: "user-signature", endpoint: "https://wallet.com/sign", ... }
 * ]
 *
 * const normalizedServices = normalizeServices(rawServices)
 * console.log("Normalized services:", normalizedServices)
 */
function normalizeServices(services, data) {
  return services.map(service => normalizeService(service, data)).filter(Boolean);
}
const serviceNormalizers = {
  "back-channel-rpc": normalizeBackChannelRpc,
  "pre-authz": normalizePreAuthz,
  authz: normalizeAuthz,
  authn: normalizeAuthn,
  frame: normalizeFrame,
  "open-id": normalizeOpenId,
  "user-signature": normalizeUserSignature,
  "local-view": normalizeLocalView,
  "account-proof": normalizeAccountProof,
  "authn-refresh": normalizeAuthnRefresh
};

/**
 * @description Normalizes a single service by applying the appropriate type-specific normalizer.
 * This function looks up the correct normalizer based on the service type and applies it to
 * ensure the service conforms to expected formats and contains required fields.
 *
 * @param service The service object to normalize
 * @param data Optional additional data to pass to the service normalizer
 * @returns The normalized service object
 *
 * @example
 * // Normalize an authentication service
 * const rawService = {
 *   type: "authn",
 *   endpoint: "https://wallet.example.com/authn",
 *   method: "HTTP/POST",
 *   // ... other service properties
 * }
 *
 * const normalized = normalizeService(rawService)
 * console.log("Normalized service:", normalized)
 */
function normalizeService(service, data) {
  try {
    const normalized = serviceNormalizers[service.type](service, data);
    return normalized;
  } catch (error) {
    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);
    return service;
  }
}

/**
 * @description Fetches additional services from a remote endpoint using an authorization code.
 * This function handles both modern service arrays and legacy wallet provider formats for
 * backward compatibility.
 *
 * @param servicesURL The URL endpoint to fetch services from
 * @param code The authorization code to include in the request
 * @returns Promise resolving to an array of Service objects
 *
 * @example
 * // Fetch services from a wallet provider
 * const services = await fetchServices(
 *   "https://wallet.example.com/services",
 *   "auth_code_123"
 * )
 */
async function fetchServices(servicesURL, code) {
  if (servicesURL == null || code == null) return [];
  const url = new URL$1(servicesURL);
  url.searchParams.append("code", code);
  const resp = await fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(d => d.json());
  if (Array.isArray(resp)) return resp;

  // Backwards compatibility for First-Gen Wallet Providers
  const services = [];

  // Convert authorizations into authz services
  if (Array.isArray(resp.authorizations)) {
    for (let service of resp.authorizations) {
      services.push({
        type: "authz",
        keyId: resp.keyId,
        ...service
      });
    }
  }

  // Convert Provider info into an authn service
  if (resp.provider != null) {
    services.push({
      type: "authn",
      id: "wallet-provider#authn",
      ...resp.provider
    });
  }
  return services;
}

/**
 * @description Merges two arrays of services into a single array. This is a simple concatenation
 * operation used internally by FCL to combine service arrays from different sources.
 * The function handles undefined/null inputs gracefully by treating them as empty arrays.
 *
 * @param sx1 First array of services to merge
 * @param sx2 Second array of services to merge
 * @returns Combined array containing all services from both input arrays
 *
 * @example
 * // Merge wallet services with discovery services
 * const walletServices = [
 *   { type: "authn", endpoint: "wallet1.com" },
 *   { type: "authz", endpoint: "wallet1.com" }
 * ]
 * const discoveryServices = [
 *   { type: "authn", endpoint: "wallet2.com" }
 * ]
 * const allServices = mergeServices(walletServices, discoveryServices)
 */
function mergeServices() {
  let sx1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let sx2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // TODO: Make this smarter
  return [...sx1, ...sx2];
}

/**
 * @description Finds a service of a specific type from an array of services, returning the one with
 * the highest version number. This is used internally by FCL to select the most recent version
 * of a service when multiple services of the same type are available.
 *
 * @param services Array of services to search through
 * @param type The type of service to find (e.g., "authn", "authz", "user-signature")
 * @returns The service with the highest version number of the specified type, or null if none found
 *
 * @example
 * // Find the latest authentication service
 * const services = [
 *   { type: "authn", f_vsn: "1.0.0", endpoint: "..." },
 *   { type: "authn", f_vsn: "1.1.0", endpoint: "..." },
 *   { type: "authz", f_vsn: "1.0.0", endpoint: "..." }
 * ]
 * const latestAuthn = serviceOfType(services, "authn")
 */
function serviceOfType() {
  let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let type = arguments.length > 1 ? arguments[1] : undefined;
  // Find the greatest version of the service type
  return services.reduce((mostRecent, service) => service.type === type ? !mostRecent || semver.compare(service.f_vsn, mostRecent.f_vsn) > 0 ? service : mostRecent : mostRecent, null);
}

function deriveCompositeId(authn) {
  return rlp.encode([authn.provider?.address || authn.provider?.name || "UNSPECIFIED", authn.id]).toString("hex");
}
function normalizeData(data) {
  data.addr = data.addr ? withPrefix(data.addr) : null;
  data.paddr = data.paddr ? withPrefix(data.paddr) : null;
  return data;
}

/**
 * @description Builds a complete CurrentUser object from user data by normalizing addresses,
 * fetching additional services, and creating a composite ID. This function handles the
 * construction of the user object that represents the authenticated state in FCL.
 *
 * @param data The user data containing address, services, and authentication information
 * @returns Promise resolving to a CurrentUser object with normalized data and services
 *
 * @example
 * // Build a user object from authentication data
 * const userData = {
 *   addr: "0x1234567890abcdef",
 *   services: [...],
 *   hks: "https://wallet.example.com/hooks",
 *   code: "auth_code_123"
 * }
 * const user = await buildUser(userData)
 * console.log(user.addr) // "0x1234567890abcdef"
 */
async function buildUser(data) {
  data = normalizeData(data);
  var services = normalizeServices(mergeServices(data.services || [], await fetchServices(data.hks, data.code)));
  const authn = serviceOfType(services, "authn");
  return {
    ...USER_PRAGMA,
    addr: withPrefix(data.addr),
    cid: deriveCompositeId(authn),
    loggedIn: true,
    services: services,
    expiresAt: data.expires
  };
}

const FCL_WC_SERVICE_METHOD = "WC/RPC";
const isServerSide = typeof window === "undefined";

/**
 * @description Checks if WalletConnect service plugin is enabled and logs a warning if it's not.
 * This function verifies that the WalletConnect strategy is registered in the service registry.
 * It's called internally by FCL to notify developers about missing WalletConnect configuration,
 * which is required for users to connect with certain wallets.
 *
 * @example
 * // This function is called automatically by FCL, but can be used manually:
 * checkWalletConnectEnabled()
 * // If WalletConnect is not configured, an error will be logged to the console
 *
 * // To properly configure WalletConnect to avoid the warning:
 * import * as fcl from "@onflow/fcl"
 *
 * fcl.config({
 *   "app.detail.title": "My App",
 *   "walletconnect.projectId": "your-walletconnect-project-id"
 * })
 */
// Utility to notify the user if the Walletconnect service plugin has not been loaded
function checkWalletConnectEnabled() {
  if (isServerSide) return;
  const serviceRegistry = getServiceRegistry();
  const strategies = serviceRegistry.getStrategies();
  if (!strategies.includes(FCL_WC_SERVICE_METHOD)) {
    logger.log({
      title: "FCL WalletConnect Service Plugin",
      level: logger.LEVELS.error,
      message: "All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information."
    });
  }
}

const AbortController = globalThis.AbortController || require("abort-controller");
/**
 * @description Executes a service strategy based on the service method. This function looks up the
 * appropriate strategy from the service registry and executes it with the provided parameters.
 * It's used internally by FCL to handle different communication methods with wallet services.
 *
 * @param params The parameters object containing service details and execution context
 * @returns Promise resolving to the strategy response
 *
 * @example
 * // Execute a service strategy (internal usage)
 * const response = await execStrategy({
 *   service: { method: "HTTP/POST", endpoint: "https://wallet.example.com/authz" },
 *   body: { transaction: "..." },
 *   config: execConfig,
 *   abortSignal: controller.signal
 * })
 */
const execStrategy = async _ref => {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    user,
    opts
  } = _ref;
  const strategy = getServiceRegistry().getStrategy(service.method);
  return strategy({
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts,
    user
  });
};

/**
 * @description Executes a service with the provided parameters, handling configuration setup,
 * error handling, and recursive service redirects. This is the main entry point for executing
 * wallet service interactions in FCL.
 *
 * @param params The service execution parameters including service, message, and configuration
 * @returns Promise resolving to a StrategyResponse containing the execution result
 *
 * @example
 * // Execute a service (internal usage)
 * const response = await execService({
 *   service: { type: "authz", method: "HTTP/POST", endpoint: "..." },
 *   msg: { transaction: "..." },
 *   config: { client: { platform: "web" } }
 * })
 */
async function execService(context, _ref2) {
  let {
    service,
    msg = {},
    config = {},
    opts = {},
    platform,
    abortSignal = new AbortController().signal,
    execStrategy: _execStrategy,
    user
  } = _ref2;
  // Notify the developer if WalletConnect is not enabled
  checkWalletConnectEnabled();
  msg.data = service.data;
  const execConfig = {
    services: await configLens(context, /^service\./),
    app: await configLens(context, /^app\.detail\./),
    client: {
      ...config.client,
      platform,
      fclVersion: VERSION,
      fclLibrary: "https://github.com/onflow/fcl-js",
      hostname: window?.location?.hostname ?? null,
      network: await createGetChainId(context)(opts)
    }
  };
  try {
    const res = await (_execStrategy || execStrategy)({
      service,
      body: msg,
      config: execConfig,
      opts,
      user,
      abortSignal
    });
    if (res.status === "REDIRECT") {
      invariant(service.type === res.data.type, "Cannot shift recursive service type in execService");
      return await execService(context, {
        service: res.data,
        msg,
        config: execConfig,
        opts,
        abortSignal,
        platform,
        user
      });
    } else {
      return res;
    }
  } catch (error) {
    log({
      title: `Error on execService ${service?.type}`,
      message: error,
      level: LEVELS.error
    });
    throw error;
  }
}

/**
 * @description Type guard function that checks if a value is a function. This is a simple utility
 * used internally by FCL for type checking and validation.
 *
 * @param d The value to check
 * @returns True if the value is a function, false otherwise
 *
 * @example
 * // Check if a value is a function
 * const callback = () => console.log("Hello")
 * const notCallback = "string"
 *
 * console.log(isFn(callback)) // true
 * console.log(isFn(notCallback)) // false
 */
const isFn = d => typeof d === "function";
const NAME = "CURRENT_USER";
const UPDATED = "CURRENT_USER/UPDATED";
const SNAPSHOT = "SNAPSHOT";
const SET_CURRENT_USER = "SET_CURRENT_USER";
const DEL_CURRENT_USER = "DEL_CURRENT_USER";
const DATA = `{
  "f_type": "User",
  "f_vsn": "1.0.0",
  "addr":null,
  "cid":null,
  "loggedIn":null,
  "expiresAt":null,
  "services":[]
}`;
const getStoredUser = async storage => {
  const fallback = JSON.parse(DATA);
  const stored = await storage.get(NAME);
  if (stored != null && fallback["f_vsn"] !== stored["f_vsn"]) {
    storage.removeItem(NAME);
    return fallback;
  }
  return stored || fallback;
};
const makeHandlers = context => {
  // Wrapper for backwards compatibility
  const getStorageProvider = async () => {
    if (context.getStorageProvider) return await context.getStorageProvider();
    return await context.config.first(["fcl.storage", "fcl.storage.default"], undefined);
  };
  return {
    [INIT]: async ctx => {
      if (typeof window === "undefined") {
        console.warn(`
        %cFCL Warning
        ============================
        "currentUser" is only available in the browser.
        For more info, please see the docs: https://docs.onflow.org/fcl/
        ============================
        `, "font-weight:bold;font-family:monospace;");
      }
      ctx.merge(JSON.parse(DATA));
      const storage = await getStorageProvider();
      if (storage.can) {
        const user = await getStoredUser(storage);
        if (notExpired(user)) ctx.merge(user);
      }
    },
    [SUBSCRIBE]: (ctx, letter) => {
      ctx.subscribe(letter.from);
      ctx.send(letter.from, UPDATED, {
        ...ctx.all()
      });
    },
    [UNSUBSCRIBE]: (ctx, letter) => {
      ctx.unsubscribe(letter.from);
    },
    [SNAPSHOT]: async (ctx, letter) => {
      letter.reply({
        ...ctx.all()
      });
    },
    [SET_CURRENT_USER]: async (ctx, letter, data) => {
      ctx.merge(data);
      const storage = await getStorageProvider();
      if (storage.can) storage.put(NAME, ctx.all());
      ctx.broadcast(UPDATED, {
        ...ctx.all()
      });
    },
    [DEL_CURRENT_USER]: async (ctx, letter) => {
      ctx.merge(JSON.parse(DATA));
      const storage = await getStorageProvider();
      if (storage.can) storage.put(NAME, ctx.all());
      ctx.broadcast(UPDATED, {
        ...ctx.all()
      });
    }
  };
};
const spawnCurrentUser = context => {
  spawn(makeHandlers(context), context.actorName);
};
function notExpired(user) {
  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();
}
async function getAccountProofData(context) {
  let accountProofDataResolver = await context.config.get("fcl.accountProof.resolver");
  if (accountProofDataResolver == null) return;
  if (!isFn(accountProofDataResolver)) {
    log({
      title: "Account Proof Data Resolver must be a function",
      message: `Check fcl.accountProof.resolver configuration.
                Expected: fcl.accountProof.resolver: async () => { ... }
                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}
                `,
      level: LEVELS.warn
    });
    return;
  }
  const accountProofData = {
    ...(await accountProofDataResolver())
  };
  const origin = window?.location?.origin;
  if (accountProofData.appIdentifier) {
    if (origin) {
      log.deprecate({
        pkg: "FCL",
        subject: "appIdentifier in fcl.accountProof.resolver",
        message: "Manually set app identifiers in the account proof resolver function are now deprecated.  These are now automatically set to the application origin URL by FCL",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-appIdentifier-field-in-account-proof-resolver"
      });
      invariant(typeof accountProofData.appIdentifier === "string", "appIdentifier must be a string");
    }
  } else {
    invariant(origin, "The appIdentifier (origin) could not be inferred from the window.location.origin.  Please set the appIdentifier manually in the fcl.accountProof.resolver function.");
    accountProofData.appIdentifier = origin;
  }
  invariant(/^[0-9a-f]+$/i.test(accountProofData.nonce), "Nonce must be a hex string");
  return accountProofData;
}
const makeConfig = async _ref => {
  let {
    discoveryAuthnInclude,
    discoveryAuthnExclude,
    discoveryFeaturesSuggested
  } = _ref;
  return {
    client: {
      discoveryAuthnInclude,
      discoveryAuthnExclude,
      discoveryFeaturesSuggested,
      clientServices: await makeDiscoveryServices(),
      supportedStrategies: getServiceRegistry().getStrategies()
    }
  };
};

/**
 * @description Factory function to create the authenticate method
 * @param config Current User Configuration
 */
const createAuthenticate = context =>
/**
 * @description Calling this method will authenticate the current user via any wallet that supports FCL. Once called, FCL will initiate communication with the configured `discovery.wallet` endpoint which lets the user select a wallet to authenticate with. Once the wallet provider has authenticated the user, FCL will set the values on the current user object for future use and authorization.
 *
 * This method can only be used in web browsers.
 *
 * `discovery.wallet` value must be set in the configuration before calling this method. See FCL Configuration.
 *
 * The default discovery endpoint will open an iframe overlay to let the user choose a supported wallet.
 *
 * `authenticate` can also take a service returned from discovery with `fcl.authenticate(\{ service \})`.
 *
 * @param opts Authentication options
 * @param opts.service Optional service to use for authentication. A service returned from discovery can be passed here.
 * @param opts.redir Optional redirect flag. Defaults to false.
 * @param opts.forceReauth Optional force re-authentication flag. Defaults to false.
 * @returns Promise that resolves to the authenticated CurrentUser object or undefined
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * fcl
 *   .config()
 *   .put('accessNode.api', 'https://rest-testnet.onflow.org')
 *   .put('discovery.wallet', 'https://fcl-discovery.onflow.org/testnet/authn');
 * // anywhere on the page
 * fcl.authenticate();
 */
async function () {
  let {
    service,
    redir = false,
    forceReauth = false
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (service && !service?.provider?.is_installed && service?.provider?.requires_install) {
    window.location.href = service?.provider?.install_link;
    return;
  }
  return new Promise(async (resolve, reject) => {
    spawnCurrentUser(context);
    const opts = {
      redir
    };
    const user = await createSnapshot(context)();
    const refreshService = serviceOfType(user.services, "authn-refresh");
    let accountProofData;
    if (user.loggedIn && !forceReauth) {
      if (refreshService) {
        try {
          const response = await execService(context, {
            service: refreshService,
            msg: accountProofData,
            opts,
            platform: context.platform,
            user
          });
          send$1(context.actorName, SET_CURRENT_USER, await buildUser(response));
        } catch (error) {
          log({
            title: `${error.name} Could not refresh wallet authentication.`,
            message: error.message,
            level: LEVELS.error
          });
        } finally {
          return resolve(await createSnapshot(context)());
        }
      } else {
        return resolve(user);
      }
    }
    try {
      accountProofData = await getAccountProofData(context);
    } catch (error) {
      log({
        title: `${error.name} On Authentication: Could not resolve account proof data.`,
        message: error.message,
        level: LEVELS.error
      });
      return reject(error);
    }
    try {
      const discoveryService = await getDiscoveryService(context, service);
      const response = await execService(context, {
        service: discoveryService,
        msg: accountProofData,
        config: await makeConfig(discoveryService),
        opts,
        platform: context.platform,
        execStrategy: context.discovery?.execStrategy,
        user
      });
      send$1(context.actorName, SET_CURRENT_USER, await buildUser(response));
    } catch (error) {
      log({
        title: `${error} On Authentication`,
        message: error,
        level: LEVELS.error
      });
    } finally {
      resolve(await createSnapshot(context)());
    }
  });
};

/**
 * @description Factory function to create the unauthenticate method
 * @param config Current User Configuration
 */
function createUnauthenticate(context) {
  /**
   * @description Logs out the current user and sets the values on the current user object to null.
   *
   * This method can only be used in web browsers.
   *
   * The current user must be authenticated first.
   *
   * @example
   * import * as fcl from '@onflow/fcl';
   * fcl.config().put('accessNode.api', 'https://rest-testnet.onflow.org');
   * // first authenticate to set current user
   * fcl.authenticate();
   * // ... somewhere else & sometime later
   * fcl.unauthenticate();
   * // fcl.currentUser.loggedIn === null
   */
  return function unauthenticate() {
    spawnCurrentUser(context);
    send$1(context.actorName, DEL_CURRENT_USER);
  };
}
const normalizePreAuthzResponse = authz => ({
  f_type: "PreAuthzResponse",
  f_vsn: "1.0.0",
  proposer: (authz || {}).proposer,
  payer: (authz || {}).payer || [],
  authorization: (authz || {}).authorization || []
});

/**
 * @description Factory function to create the resolvePreAuthz method
 * @param config Current User Configuration
 */
const createResolvePreAuthz = context => (authz, _ref2) => {
  let {
    user
  } = _ref2;
  const resp = normalizePreAuthzResponse(authz);
  const axs = [];
  if (resp.proposer != null) axs.push(["PROPOSER", resp.proposer]);
  for (let az of resp.payer || []) axs.push(["PAYER", az]);
  for (let az of resp.authorization || []) axs.push(["AUTHORIZER", az]);
  var result = axs.map(_ref3 => {
    let [role, az] = _ref3;
    return {
      tempId: [az.identity.address, az.identity.keyId].join("|"),
      addr: az.identity.address,
      keyId: az.identity.keyId,
      signingFunction(signable) {
        return execService(context, {
          service: az,
          msg: signable,
          platform: context.platform,
          user
        });
      },
      role: {
        proposer: role === "PROPOSER",
        payer: role === "PAYER",
        authorizer: role === "AUTHORIZER"
      }
    };
  });
  return result;
};

/**
 * @description Factory function to create the authorization method
 * @param config Current User Configuration
 */
const createAuthorization = context =>
/**
 * @description Produces the needed authorization details for the current user to submit transactions to Flow
 * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.
 *
 * @param account Account object
 * @returns Account object with signing function
 * */
async account => {
  spawnCurrentUser(context);
  return {
    ...account,
    tempId: "CURRENT_USER",
    async resolve(account, preSignable) {
      const user = await createAuthenticate(context)({
        redir: true
      });
      const authz = serviceOfType(user.services, "authz");
      const preAuthz = serviceOfType(user.services, "pre-authz");
      if (preAuthz) return createResolvePreAuthz(context)(await execService(context, {
        service: preAuthz,
        msg: preSignable,
        platform: context.platform,
        user
      }), {
        user: user
      });
      if (authz) {
        return {
          ...account,
          tempId: "CURRENT_USER",
          resolve: null,
          addr: sansPrefix(authz.identity.address),
          keyId: authz.identity.keyId,
          sequenceNum: null,
          signature: null,
          async signingFunction(signable) {
            return normalizeCompositeSignature(await execService(context, {
              service: authz,
              msg: signable,
              opts: {
                includeOlderJsonRpcCall: true
              },
              platform: context.platform,
              user
            }));
          }
        };
      }
      throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER");
    }
  };
};

/**
 * @description Factory function to create the subscribe method
 * @param context Current User Context
 */
function createSubscribe(context) {
  /**
   * @description The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.
   *
   * @param callback The callback will be called with the current user as the first argument when the current user is set or removed.
   * @returns Function to unsubscribe from user state changes
   *
   * @example
   * import React, { useState, useEffect } from 'react';
   * import * as fcl from '@onflow/fcl';
   *
   * export function AuthCluster() {
   *   const [user, setUser] = useState({ loggedIn: null });
   *   useEffect(() => fcl.currentUser.subscribe(setUser), []); // sets the callback for FCL to use
   *
   *   if (user.loggedIn) {
   *     return (
   *       <div>
   *         <span>{user?.addr ?? 'No Address'}</span>
   *         <button onClick={fcl.unauthenticate}>Log Out</button>
   *       </div>
   *     );
   *   } else {
   *     return (
   *       <div>
   *         <button onClick={fcl.logIn}>Log In</button>{' '}
   *         <button onClick={fcl.signUp}>Sign Up</button>
   *       </div>
   *     );
   *   }
   * }
   */
  return function subscribe(callback) {
    spawnCurrentUser(context);
    const EXIT = "@EXIT";
    const self = spawn(async ctx => {
      ctx.send(context.actorName, SUBSCRIBE);
      while (1) {
        const letter = await ctx.receive();
        if (letter.tag === EXIT) {
          ctx.send(context.actorName, UNSUBSCRIBE);
          return;
        }
        callback(letter.data);
      }
    });
    return () => send$1(self, EXIT);
  };
}

/**
 * @description Factory function to create the snapshot method
 * @param context Current User Context
 */
function createSnapshot(context) {
  /**
   * @description Returns the current user object. This is the same object that is set and available on `fcl.currentUser.subscribe(callback)`.
   *
   * @returns Promise that resolves to the current user object
   *
   * @example
   * // returns the current user object
   * const user = fcl.currentUser.snapshot();
   *
   * // subscribes to the current user object and logs to console on changes
   * fcl.currentUser.subscribe(console.log);
   */
  return function snapshot() {
    spawnCurrentUser(context);
    return send$1(context.actorName, SNAPSHOT, null, {
      expectReply: true,
      timeout: 0
    });
  };
}

/**
 * @description Resolves the current user as an argument
 * @param config Current User Configuration
 */
const createResolveArgument = config => async () => {
  const {
    addr
  } = await createAuthenticate(config)();
  return arg(withPrefix(addr), t$1.Address);
};
const makeSignable = msg => {
  invariant(/^[0-9a-f]+$/i.test(msg), "Message must be a hex string");
  return {
    message: msg
  };
};

/**
 * @description Factory function to create the signUserMessage method
 * @param config Current User Configuration
 */
const createSignUserMessage = context =>
/**
 * @description A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.
 *
 * This method requires the current user's wallet to support a signing service endpoint. Currently, only Blocto is compatible with this feature by default.
 *
 * @param msg A hexadecimal string to be signed
 * @returns An Array of CompositeSignatures: \{`addr`, `keyId`, `signature`\}
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 *
 * export const signMessage = async () => {
 *   const MSG = Buffer.from('FOO').toString('hex');
 *   try {
 *     return await currentUser.signUserMessage(MSG);
 *   } catch (error) {
 *     console.log(error);
 *   }
 * };
 */
async msg => {
  spawnCurrentUser(context);
  const user = await createAuthenticate(context)({
    redir: true
  });
  const signingService = serviceOfType(user.services, "user-signature");
  invariant(signingService, "Current user must have authorized a signing service.");
  try {
    const response = await execService(context, {
      service: signingService,
      msg: makeSignable(msg),
      platform: context.platform,
      user
    });
    if (Array.isArray(response)) {
      return response.map(compSigs => normalizeCompositeSignature(compSigs));
    } else {
      return [normalizeCompositeSignature(response)];
    }
  } catch (error) {
    return error;
  }
};
const _createUser = context => {
  const currentUser = {
    authenticate: createAuthenticate(context),
    unauthenticate: createUnauthenticate(context),
    authorization: createAuthorization(context),
    signUserMessage: createSignUserMessage(context),
    subscribe: createSubscribe(context),
    snapshot: createSnapshot(context),
    resolveArgument: createResolveArgument(context)
  };
  return Object.assign(() => {
    return {
      ...currentUser
    };
  }, {
    ...currentUser
  });
};
const createUser = context => {
  return _createUser({
    ...context,
    getStorageProvider: async () => context.storage,
    discovery: context.discovery,
    actorName: `${NAME}_${v4()}`
  });
};

/**
 * @description Creates and configures the Current User service for managing user authentication and
 * authorization in Flow applications. This is the core service for handling user sessions, wallet
 * connections, transaction signing, and user data management. The service provides both callable
 * function interface and object methods for maximum flexibility.
 *
 * @param config Configuration object for the current user service
 * @param config.platform Platform identifier (e.g., "web", "mobile", "extension")
 * @param config.discovery Optional discovery configuration for wallet services
 * @param config.getStorageProvider Optional function to provide custom storage implementation
 *
 * @returns Current user service object with authentication and authorization methods
 *
 * @example
 * // Basic setup and authentication
 * import * as fcl from "@onflow/fcl"
 *
 * // Configure FCL
 * fcl.config({
 *   "accessNode.api": "https://rest-testnet.onflow.org",
 *   "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn"
 * })
 *
 * // Create current user service
 * const currentUser = fcl.getCurrentUser({
 *   platform: "web"
 * })
 *
 * // Authenticate user
 * const user = await currentUser.authenticate()
 * console.log("Authenticated user:", user.addr)
 *
 * // Subscribe to authentication state changes
 * const currentUser = fcl.getCurrentUser({ platform: "web" })
 *
 * const unsubscribe = currentUser.subscribe((user) => {
 *   if (user.loggedIn) {
 *     console.log("User logged in:", user.addr)
 *     document.getElementById("login-btn").style.display = "none"
 *     document.getElementById("logout-btn").style.display = "block"
 *   } else {
 *     console.log("User logged out")
 *     document.getElementById("login-btn").style.display = "block"
 *     document.getElementById("logout-btn").style.display = "none"
 *   }
 * })
 *
 * // Clean up subscription
 * window.addEventListener("beforeunload", () => unsubscribe())
 *
 * // Sign transactions with user authorization
 * const currentUser = fcl.getCurrentUser({ platform: "web" })
 *
 * const txId = await fcl.mutate({
 *   cadence: `
 *     transaction(amount: UFix64, to: Address) {
 *       prepare(signer: AuthAccount) {
 *         // Transfer tokens logic here
 *       }
 *     }
 *   `,
 *   args: (arg, t) => [
 *     arg("10.0", t.UFix64),
 *     arg("0x01", t.Address)
 *   ],
 *   authz: currentUser.authorization
 * })
 *
 * // Sign custom messages
 * const currentUser = fcl.getCurrentUser({ platform: "web" })
 *
 * const message = Buffer.from("Hello, Flow!").toString("hex")
 * const signatures = await currentUser.signUserMessage(message)
 *
 * console.log("Message signatures:", signatures)
 */
const getCurrentUser = cfg => {
  const partialContext = createPartialGlobalFCLContext();

  // Wrapper for backwards compatibility
  const getStorageProvider = async () => {
    if (cfg.getStorageProvider) return await cfg.getStorageProvider();
    return await config.first(["fcl.storage", "fcl.storage.default"], undefined);
  };
  return _createUser({
    ...partialContext,
    getStorageProvider,
    platform: cfg.platform,
    actorName: NAME,
    discovery: cfg.discovery
  });
};

/**
 * @description Creates a URL object from a service endpoint with additional parameters including
 * the application origin and service-specific parameters. This function is used internally by
 * FCL strategies to construct the complete URL for service communication.
 *
 * @param service The service object containing endpoint and optional parameters
 * @returns URL object with all parameters appended as query string parameters
 *
 * @example
 * // Create URL from service
 * const service = {
 *   endpoint: "https://wallet.example.com/authn",
 *   params: {
 *     appName: "MyApp",
 *     nonce: "abc123"
 *   }
 * }
 * const url = serviceEndpoint(service)
 * console.log(url.toString())
 * // https://wallet.example.com/authn?l6n=https://myapp.com&appName=MyApp&nonce=abc123
 */
function serviceEndpoint(service) {
  const url = new URL$1(service.endpoint);
  if (window?.location?.origin) {
    url.searchParams.append("l6n", window.location.origin);
  }
  if (service.params != null) {
    for (let [key, value] of Object.entries(service.params || {})) {
      url.searchParams.append(key, value);
    }
  }
  return url;
}

/**
 * @description Makes an HTTP request to a service endpoint with the specified options.
 * This utility function handles the common patterns for communicating with wallet services
 * including proper headers, body serialization, and JSON response parsing.
 *
 * @param service The service configuration containing endpoint and headers
 * @param opts Optional request configuration including method, data, and headers
 * @returns Promise resolving to the parsed JSON response
 *
 * @example
 * // Fetch from a service endpoint
 * const response = await fetchService(service, {
 *   method: "POST",
 *   data: { transaction: "..." },
 *   headers: { "Authorization": "Bearer token" }
 * })
 */
function fetchService(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const method = opts.method || "POST";
  const body = method === "GET" ? undefined : JSON.stringify(opts.data || service.data || {});
  return fetch(serviceEndpoint(service), {
    method: method,
    headers: {
      ...(service.headers || {}),
      ...(opts.headers || {}),
      "Content-Type": "application/json"
    },
    body: body
  }).then(d => d.json());
}

/**
 * @description Normalizes a polling response to ensure compatibility with FCL format
 *
 * @param resp The polling response to normalize
 * @returns The normalized polling response or null
 *
 * @example
 * const resp = normalizePollingResponse({
 *   f_type: "PollingResponse",
 *   f_vsn: "1.0.0",
 *   status: "PENDING", // PENDING | APPROVED | DECLINED | REDIRECT
 *   reason: null,      // Reason for Declining Transaction
 *   data: null,        // Return value for APPROVED
 *   updates: BackChannelRpc,
 *   local: Frame,
 * })
 */
function normalizePollingResponse(resp) {
  if (resp == null) return null;
  if (!resp["f_vsn"]) {
    return {
      ...POLLING_RESPONSE_PRAGMA,
      status: resp.status ?? "APPROVED",
      reason: resp.reason ?? null,
      data: resp.compositeSignature || resp.data || {
        ...resp
      } || {},
      updates: normalizeBackChannelRpc(resp.authorizationUpdates),
      local: normalizeFrame((resp.local || [])[0])
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}

const OPTIONS = {
  "HTTP/GET": "GET",
  "HTTP/POST": "POST"
};
const serviceMethod = service => {
  invariant(OPTIONS[service.method], "Invalid Service Method for type back-channel-rpc", {
    service
  });
  return OPTIONS[service.method];
};

/**
 * @description Continuously polls a service endpoint until it receives an APPROVED or DECLINED
 * response. This function handles the asynchronous nature of wallet interactions by repeatedly
 * checking for status updates with appropriate delays.
 *
 * @param service The service configuration containing the polling endpoint
 * @param checkCanContinue Optional function to control whether polling should continue
 * @returns Promise resolving to the final response data when approved or rejected
 *
 * @example
 * // Poll a service for completion
 * const result = await poll(pollingService, () => !userCancelled)
 * console.log(result) // Final response data
 */
async function poll(service) {
  let checkCanContinue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => true;
  invariant(service, "Missing Polling Service", {
    service
  });
  const canContinue = checkCanContinue();
  if (!canContinue) throw new Error("Externally Halted");
  let resp;
  try {
    if (typeof document !== "undefined" && document.visibilityState === "hidden") {
      await new Promise(r => setTimeout(r, 500));
      return poll(service, checkCanContinue);
    }
    resp = await fetchService(service, {
      method: serviceMethod(service)
    }).then(normalizePollingResponse);
  } catch (error) {
    throw error;
  }
  switch (resp?.status) {
    case "APPROVED":
      return resp.data;
    case "DECLINED":
      throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
    default:
      await new Promise(r => setTimeout(r, 500));
      return poll(resp?.updates, checkCanContinue);
  }
}

/**
 * @description Creates an HTTP POST strategy executor that handles wallet service communication
 * via HTTP POST requests. This function manages the full lifecycle including polling for
 * responses, handling local views, and managing user interactions.
 *
 * @param execLocal Function to execute local view rendering and user interaction
 * @returns HTTP POST strategy function that can be used to execute services
 *
 * @example
 * // Create an HTTP POST executor
 * const httpPostExec = getExecHttpPost(async (view, { serviceEndpoint, onClose }) => {
 *   // Render local view and return cleanup function
 *   return [viewData, () => cleanup()]
 * })
 */
const getExecHttpPost = execLocal => async _ref => {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  const resp = await fetchService(service, {
    data: {
      fclVersion: VERSION,
      service: {
        params: service.params,
        data: service.data,
        type: service.type
      },
      config,
      ...body
    }
  }).then(normalizePollingResponse);
  if (resp?.status === "APPROVED") {
    return resp.data;
  } else if (resp?.status === "DECLINED") {
    throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
  } else if (resp?.status === "REDIRECT") {
    return resp;
  } else if (resp?.status === "PENDING") {
    // these two flags are required to run polling one more time before it stops
    let canContinue = true;
    let shouldContinue = true;
    const [_, unmount] = await execLocal(normalizeLocalView(resp.local), {
      serviceEndpoint,
      onClose: () => shouldContinue = false
    });
    const close = () => {
      try {
        unmount();
        shouldContinue = false;
      } catch (error) {
        console.error("Frame Close Error", error);
      }
    };

    /**
     * this function is run once per poll call.
     * Offsetting canContinue flag to make sure that
     * the polling is performed one extra time after canContinue flag is set to false
     * to prevent halting on Android when a browser calls window.close
     * before FCL receives a successful result from polling
     *
     * @returns {boolean}
     */
    const checkCanContinue = () => {
      const offsetCanContinue = canContinue;
      canContinue = shouldContinue;
      return offsetCanContinue;
    };
    return poll(resp.updates, checkCanContinue).then(serviceResponse => {
      close();
      return serviceResponse;
    }).catch(error => {
      console.error(error);
      close();
      throw error;
    });
  } else {
    console.error(`Auto Decline: Invalid Response`, {
      service,
      resp
    });
    throw new Error(`Auto Decline: Invalid Response`);
  }
};

const CLOSE_EVENT = "FCL:VIEW:CLOSE";
const READY_EVENT = "FCL:VIEW:READY";
const RESPONSE_EVENT = "FCL:VIEW:RESPONSE";
const CUSTOM_RPC = "FCL:VIEW:CUSTOM_RPC";
const _ = e => typeof e === "string" && e.toLowerCase();
const IGNORE = new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]);
const deprecate = (was, want) => console.warn("DEPRECATION NOTICE", `Received ${was}, please use ${want} for this and future versions of FCL`);

/**
 * @description Creates a message handler for processing window messages from wallet service
 * frames or popups. This handler manages the communication protocol between FCL and wallet
 * services, including ready states, responses, and cleanup operations.
 *
 * @param params Configuration object containing callback functions and utilities
 * @returns Message event handler function that can be attached to window message listeners
 *
 * @example
 * // Create a message handler for wallet communication
 * const handler = buildMessageHandler({
 *   close: () => cleanup(),
 *   send: (msg) => postMessage(msg),
 *   onReady: (e, utils) => initializeWallet(utils),
 *   onResponse: (e, utils) => handleResponse(e.data),
 *   onMessage: (e, utils) => processMessage(e),
 *   onCustomRpc: (payload, utils) => handleRpc(payload)
 * })
 * window.addEventListener("message", handler)
 */
const buildMessageHandler = _ref => {
  let {
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource
  } = _ref;
  let source;
  return e => {
    try {
      source = getSource?.() || source;
    } catch (_) {
      // If getSource isn't working correctly, we should reset source
      // to prevent desync between the source and the actual source
      source = null;
    }
    try {
      if (typeof e.data !== "object") return;
      if (IGNORE.has(e.data.type)) return;
      if (source != null && e.source !== source) return;
      if (_(e.data.type) === _(CLOSE_EVENT)) close();
      if (_(e.data.type) === _(READY_EVENT)) {
        onReady(e, {
          send,
          close
        });
        source ||= e.source;
      }
      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {
        send,
        close
      });
      if (_(e.data.type) === _(CUSTOM_RPC)) onCustomRpc(e.data.payload, {
        send,
        close
      });
      onMessage(e, {
        send,
        close
      });

      // Backwards Compatible
      if (_(e.data.type) === _("FCL:FRAME:READY")) {
        deprecate(e.data.type, READY_EVENT);
        onReady(e, {
          send,
          close
        });
        source ||= e.source;
      }
      if (_(e.data.type) === _("FCL:FRAME:RESPONSE")) {
        deprecate(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send,
          close
        });
      }
      if (_(e.data.type) === _("FCL:FRAME:CLOSE")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close();
      }
      //
      if (_(e.data.type) === _("FCL::CHALLENGE::RESPONSE")) {
        deprecate(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send,
          close
        });
      }
      if (_(e.data.type) === _("FCL::AUTHZ_READY")) {
        deprecate(e.data.type, READY_EVENT);
        onReady(e, {
          send,
          close
        });
        source ||= e.source;
      }
      if (_(e.data.type) === _("FCL::CHALLENGE::CANCEL")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close();
      }
      if (_(e.data.type) === _("FCL::CANCEL")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close();
      }
    } catch (error) {
      console.error("Frame Callback Error", error);
      close();
    }
  };
};

// Define a compatibility config interface for backward compatibility

/**
 * FCL Context contains the core infrastructure dependencies
 */

/**
 * Factory function to create an FCL context
 */
function createFCLContext(config) {
  let contracts;
  if (config.flowJson) {
    invariant(!!config.flowNetwork, "If flowJson is provided, flowNetwork must also be specified.");
    const cleanedNetwork = config.flowNetwork.toLowerCase().replace(/^local$/, "emulator");
    invariant(cleanedNetwork === "mainnet" || cleanedNetwork === "testnet" || cleanedNetwork === "emulator", `Invalid flowNetwork: ${config.flowNetwork}. Must be one of: mainnet, testnet, emulator.`);
    contracts = getContracts(config.flowJson, cleanedNetwork);
  }
  const sdk = createSdkClient({
    accessNodeUrl: config.accessNodeUrl,
    transport: config.transport,
    computeLimit: config.computeLimit,
    customResolver: config.customResolver,
    customDecoders: config.customDecoders,
    contracts: contracts
  });
  const configService = createConfigService(config);
  const currentUser = createUser({
    platform: config.platform,
    storage: config.storage,
    config: configService,
    discovery: {
      execStrategy: config.discovery?.execStrategy
    },
    sdk
  });
  return {
    storage: config.storage,
    currentUser: currentUser,
    sdk: sdk,
    config: configService,
    platform: config.platform
  };
}
function createConfigService(config) {
  // Create internal config store based on provided typed config
  const configStore = new Map([["platform", config.platform], ["discovery.wallet", config.discoveryWallet], ["discovery.wallet.method", config.discoveryWalletMethod], ["discovery.authn.endpoint", config.discoveryAuthnEndpoint], ["flow.network", config.flowNetwork], ["accessNode.api", config.accessNodeUrl], ["fcl.limit", config.computeLimit], ["app.detail.title", config.appDetailTitle], ["app.detail.icon", config.appDetailIcon], ["app.detail.description", config.appDetailDescription], ["app.detail.url", config.appDetailUrl], ["service.OpenID.scopes", config.serviceOpenIdScopes]]);

  // Filter out undefined values
  for (const [key, value] of configStore.entries()) {
    if (value === undefined) {
      configStore.delete(key);
    }
  }

  // Create subscribers registry
  const subscribers = new Set();

  // Create compatibility config layer
  const configService = {
    get: async (key, fallback) => {
      return configStore.has(key) ? configStore.get(key) : fallback;
    },
    put: async (key, value) => {
      configStore.set(key, value);
      subscribers.forEach(fn => fn(configStore));
      return configService;
    },
    update: async (key, updateFn) => {
      const oldValue = configStore.get(key);
      const newValue = updateFn(oldValue);
      configStore.set(key, newValue);
      subscribers.forEach(fn => fn(configStore));
      return configService;
    },
    delete: async key => {
      configStore.delete(key);
      subscribers.forEach(fn => fn(configStore));
      return configService;
    },
    where: async pattern => {
      const result = {};
      for (const [key, value] of configStore.entries()) {
        if (pattern.test(key)) {
          result[key] = value;
        }
      }
      return result;
    },
    first: async (keys, defaultValue) => {
      if (typeof keys === "string") keys = [keys];
      for (const key of keys) {
        if (configStore.has(key)) {
          return configStore.get(key);
        }
      }
      return defaultValue;
    },
    subscribe: callback => {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    all: async () => {
      return Object.fromEntries(configStore.entries());
    }
  };
  return configService;
}

function createFlowClientCore(params) {
  const context = createFCLContext({
    ...params,
    transport: params.transport || httpTransport
  });
  return {
    // Global services
    currentUser: context.currentUser,
    // Execution methods
    mutate: createMutate(context),
    query: createQuery(context),
    queryRaw: createQueryRaw(context),
    verifyUserSignatures: createVerifyUserSignatures(context),
    getChainId: createGetChainId(context),
    // Streaming helpers
    tx: createTransaction(context),
    events: createEvents(context),
    // Authentication methods
    authenticate: context.currentUser.authenticate,
    unauthenticate: context.currentUser.unauthenticate,
    signUserMessage: context.currentUser.signUserMessage,
    // Utility methods
    serialize: createSerialize(context),
    // Re-export the SDK methods
    ...context.sdk
  };
}

// Set chain id default on access node change
watchForChainIdChanges();

export { index$1 as AppUtils, CORE_STRATEGIES, FCL_REDIRECT_URL_PARAM_NAME, FCL_RESPONSE_PARAM_NAME, index as InteractionTemplateUtils, TransactionError, URL$1 as URL, VERSION, index$2 as WalletUtils, buildMessageHandler, createFlowClientCore, discovery, events, execStrategy, getChainId, getCurrentUser, getExecHttpPost, getMutate, initServiceRegistry, isReactNative, normalizePollingResponse, pluginRegistry, query, queryRaw, serialize, serviceEndpoint, setIsReactNative, transaction as tx, verifyUserSignatures };
//# sourceMappingURL=fcl-core.module.js.map
