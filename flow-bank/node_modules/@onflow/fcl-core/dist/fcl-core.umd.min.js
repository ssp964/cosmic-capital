!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@onflow/sdk"),require("@onflow/types"),require("@onflow/util-invariant"),require("cross-fetch"),require("@onflow/util-logger"),require("@onflow/config"),require("@onflow/util-address"),require("@onflow/rlp"),require("@onflow/typedefs"),require("@onflow/util-actor"),require("@onflow/transport-http"),require("@improbable-eng/grpc-web"),require("sha3"),require("@onflow/util-template"),require("@onflow/util-semver"),require("uuid")):"function"==typeof define&&define.amd?define(["exports","@onflow/sdk","@onflow/types","@onflow/util-invariant","cross-fetch","@onflow/util-logger","@onflow/config","@onflow/util-address","@onflow/rlp","@onflow/typedefs","@onflow/util-actor","@onflow/transport-http","@improbable-eng/grpc-web","sha3","@onflow/util-template","@onflow/util-semver","uuid"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["onflowFcl-core"]={},e.sdk,e.t,e.utilInvariant,e.fetchTransport,e.logger,e.config,e.utilAddress,e.rlp,e.typedefs,e.utilActor,e.transportHttp,e.grpcWeb,e.sha3,e.utilTemplate,e.semver,e.uuid)}(this,(function(e,t,n,r,a,o,i,s,c,l,u,d,f,p,g,m,y){"use strict";function v(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var b=v(t),w=v(n),h=v(o),E=v(c),P=v(m);const S="1.21.0",I=e=>t=>typeof t===e,T=e=>null!=e,k=I("object"),C=I("string"),A=I("function"),R=I("number");function O(e){return A(e)?e(b.arg,w):[]}async function N(e,t,n){r.invariant(T(n),`${t}(opts) -- opts is required`),r.invariant(k(n),`${t}(opts) -- opts must be an object`),r.invariant(!(n.cadence&&n.template),`${t}({ template, cadence }) -- cannot pass both cadence and template`),r.invariant(T(n.cadence||n?.template),`${t}({ cadence }) -- cadence is required`),r.invariant(C(n.cadence)||n?.template,`${t}({ cadence }) -- cadence must be a string`),r.invariant(await e.config.get("accessNode.api"),`${t}(opts) -- Required value for "accessNode.api" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`)}async function j(e){let t,{url:n}=e;r.invariant(void 0!==n,"retrieve({ url }) -- url must be defined");try{t=await a(n)}catch(e){throw new Error("httpDocumentResolver Error: Failed to retrieve document.")}return t.ok?await t.json():null}const _=new Map([["http",j],["https",j]]);async function x(e){let{network:t,template:n}=e;r.invariant("1.1.0"===n.f_version,"deriveCadenceByNetwork110({ template }) -- template must be version 1.1.0");const a={};return n?.data?.dependencies.forEach((e=>{e.contracts.forEach((e=>{const n=e.contract;e.networks.forEach((e=>{e.network===t&&(a[n]=e.address)})),r.invariant(void 0!==a[n],`deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${t} ${n}`)}))})),r.invariant(Object.keys(a).length===n?.data?.dependencies.length,`deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${a}`),r.invariant(Object.keys(a).length===Object.values(a).length,`deriveCadenceByNetwork110 -- Could not find all addresses for network ${t} dependencies:  ${a}`),r.invariant(!!n?.data?.cadence?.body,`no cadence found -- Could not replace import dependencies: ${a}`),function(e){let{cadence:t,networkDependencies:n}=e;return Object.keys(n).reduce(((e,t)=>{const r=n[t],a=new RegExp(`import "\\b${t}\\b"`,"g");return e.replace(a,`import ${t} from ${r}`)}),t)}({cadence:n?.data?.cadence?.body,networkDependencies:a})}async function U(e){let{network:t,template:n}=e;switch(r.invariant(null!=t,"deriveCadenceByNetwork({ network }) -- network must be defined"),r.invariant("string"==typeof t,"deriveCadenceByNetwork({ network }) -- network must be a string"),r.invariant(null!=n,"deriveCadenceByNetwork({ template }) -- template must be defined"),r.invariant("object"==typeof n,"deriveCadenceByNetwork({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate"),n.f_version){case"1.1.0":return await x({network:t,template:n});case"1.0.0":return await async function(e){let{network:t,template:n}=e;return r.invariant("1.0.0"===n.f_version,"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0"),Object.keys(n?.data?.dependencies).map((e=>{const a=Object.values(n?.data?.dependencies?.[e]);r.invariant(void 0!==a,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`),r.invariant(a.length>0,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`);const o=a[0],i=o?.[t];return r.invariant(i,`deriveCadenceByNetwork100 -- Could not find ${t} network information for dependency: ${e}`),[e,i?.address]})).reduce(((e,t)=>{let[n,r]=t;const a=new RegExp("(\\b"+n+"\\b)","g");return e.replace(a,r)}),n.data.cadence)}({network:t,template:n});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}function L(){return{config:i.config(),sdk:{send:t.send,decode:t.decode,subscribe:t.subscribe,subscribeRaw:t.subscribeRaw,account:t.account,block:t.block,resolve:t.resolve}}}let D={},F=!1;function M(e){return async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=await e.config.get("flow.network"),a=await e.config.get("env");a&&!F&&(o.log.deprecate({pkg:"FCL",subject:'Using the "env" configuration key for specifying the flow network',message:"Configuring to specify flow network is no longer required",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"}),F=!0);const i=n.node||await e.config.get("accessNode.api");if(!i){if(r)return r;if(a)return a;throw new Error('Either the "accessNode.api" config key or opts.node must be set')}if(D[i])try{return await D[i]}catch{}D[i]||(D[i]=async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(await e.sdk.send([t.getNetworkParameters()],n).then(e.sdk.decode)).chainId}(e,n).catch((e=>{throw D[i]=null,e})));try{return await D[i]}catch(e){if(r)return r;if(a)return a;throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`)}}}const B=M(L());async function $(e,t){C(t?.template)&&(t.template=await async function(e,t){let{url:n}=t;r.invariant(void 0!==n,"retrieve({ url }) -- url must be defined"),r.invariant("string"==typeof n,"retrieve({ url }) -- url must be a string");const a=await e.config.where(/^document\.resolver\./);Object.keys(a).map((e=>{const t=a[e],n=e.replace(/^document\.resolver\./,"");_.set(n,t)}));const o=/^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(n);r.invariant(o,"Failed to parse URL");const i=o[1];r.invariant(o,"Failed to parse URL protocol");const s=_.get(i);return r.invariant(s,`No resolver found for protcol=${i}`),await s({url:n})}(e,{url:t?.template}));const n=t.cadence||await U({template:t.template,network:await M(e)(t)});return t.cadence=n,t}function z(e){return async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await async function(e,t){return N(e,"query",t)}(e,t),t=await $(e,t),e.sdk.send([b.script(t.cadence),b.args(O(t.args||[])),b.atLatestBlock(t.isSealed??!1),t.limit&&"number"==typeof t.limit&&b.limit(t.limit)])}}const q=z(L());function V(e){return async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return z(e)(t).then(e.sdk.decode)}}const H=V(L()),W="fcl_redirect_url",K="fclResponseJson",G={"HTTP/RPC":"HTTP/RPC","HTTP/POST":"HTTP/POST","IFRAME/RPC":"IFRAME/RPC","POP/RPC":"POP/RPC","TAB/RPC":"TAB/RPC","EXT/RPC":"EXT/RPC","DEEPLINK/RPC":"DEEPLINK/RPC"},J=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{};const n=n=>{const{data:r,origin:a}=n;"object"==typeof r&&null!=typeof r&&r.type===e&&t((e=>(e.deprecated&&console.warn("DEPRECATION NOTICE",e.deprecated.message),delete e?.body?.interaction,e))(r),{origin:a})};return window.addEventListener("message",n),()=>window.removeEventListener("message",n)},Y=(e,t)=>{const n={...t,type:e},r=new URLSearchParams(window.location.search).get(W);if(r){const e=new URL(r);e.searchParams.append(K,JSON.stringify(n)),window.location.href=e.href}else if(window.location!==window.parent.location)window.parent.postMessage({...t,type:e},"*");else{if(!window.opener)throw new Error("Unable to communicate with parent FCL instance");window.opener.postMessage({...t,type:e},"*")}},X={f_type:"Service",f_vsn:"1.0.0"},Z={f_type:"Identity",f_vsn:"1.0.0"},Q={f_type:"USER",f_vsn:"1.0.0"},ee={f_type:"PollingResponse",f_vsn:"1.0.0"},te={f_type:"CompositeSignature",f_vsn:"1.0.0"};const ne=e=>{return t=e,n=8,c.Buffer.from(t.padStart(2*n,"0"),"hex");var t,n},re=e=>c.Buffer.from(e,"hex"),ae=function(e){let{address:t,nonce:n,appIdentifier:a}=e,o=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];r.invariant(!!t,"Encode Message For Provable Authn Error: address must be defined"),r.invariant(!!n,"Encode Message For Provable Authn Error: nonce must be defined"),r.invariant(!!a,"Encode Message For Provable Authn Error: appIdentifier must be defined"),r.invariant(n.length>=64,"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");const i=(l=c.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"),u=32,c.Buffer.from(l.padEnd(2*u,"0"),"hex"));var l,u;return o?c.Buffer.concat([i,c.encode([a,ne(s.sansPrefix(t)),re(n)])]).toString("hex"):c.encode([a,ne(s.sansPrefix(t)),re(n)]).toString("hex")};var oe=Object.freeze({__proto__:null,CompositeSignature:class{constructor(e,t,n){this.f_type=te.f_type,this.f_vsn=te.f_vsn,this.addr=s.withPrefix(e),this.keyId=Number(t),this.signature=n}},approve:e=>{Y("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"APPROVED",reason:null,data:e})},close:()=>{Y("FCL:VIEW:CLOSE")},decline:e=>{Y("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"DECLINED",reason:e,data:null})},encodeAccountProof:ae,encodeMessageFromSignable:t.encodeMessageFromSignable,injectExtService:function(e){"authn"===e.type&&null!=e.endpoint?(Array.isArray(window.fcl_extensions)||(window.fcl_extensions=[]),window.fcl_extensions.push(e)):console.warn("Authn service is required")},onMessageFromFCL:J,ready:function(e){J("FCL:VIEW:READY:RESPONSE",e),Y("FCL:VIEW:READY")},redirect:e=>{Y("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"REDIRECT",reason:null,data:e})},sendMsgToFCL:Y});const ie=e=>{if(e.appIdentifier){const{appIdentifier:t,address:n,nonce:a,signatures:o}=e;return r.invariant(C(t),"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string"),r.invariant(C(n)&&16===s.sansPrefix(n).length,"verifyAccountProof({ address }) -- address must be a valid address"),r.invariant(/^[0-9a-f]+$/i.test(a),"nonce must be a hex string"),r.invariant(Array.isArray(o)&&o.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(o.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}{const{message:t,address:n,compSigs:a}=e;return r.invariant(/^[0-9a-f]+$/i.test(t),"Signed message must be a hex string"),r.invariant(C(n)&&16===s.sansPrefix(n).length,"verifyUserSignatures({ address }) -- address must be a valid address"),r.invariant(Array.isArray(a)&&a.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(a.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}},se=async(e,t,n)=>{const a="ACCOUNT_PROOF"===t?"verifyAccountProofSignatures":"verifyUserSignatures",o=await M(e)(n),i=n.fclCryptoContract||{testnet:"0x74daa6f9c7ef24b1",mainnet:"0xb4b82a1c9d21d284",previewnet:"0x40b5b8b2ce81ea4a"}[o];return r.invariant(i,`${a}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${o}. Please manually specify the FCLCrypto contract address.`),`\n      import FCLCrypto from ${i}\n\n      access(all) fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${a}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `};function ce(e){return async function(t,n){let{address:r,nonce:a,signatures:o}=n,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ie({appIdentifier:t,address:r,nonce:a,signatures:o});const c=ae({address:r,nonce:a,appIdentifier:t},!1),l=[],u=[];for(const e of o)l.push(e.signature),u.push(e.keyId.toString());return V(e)({cadence:await se(e,"ACCOUNT_PROOF",i),args:(e,t)=>[e(s.withPrefix(r),t.Address),e(c,t.String),e(u,t.Array(t.Int)),e(l,t.Array(t.String))]})}}function le(e){return async function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=s.withPrefix(n[0].addr);ie({message:t,address:a,compSigs:n});const o=[],i=[];for(const e of n)o.push(e.signature),i.push(e.keyId.toString());return V(e)({cadence:await se(e,"USER_SIGNATURE",r),args:(e,n)=>[e(a,n.Address),e(t,n.String),e(i,n.Array(n.Int)),e(o,n.Array(n.String))]})}}const ue=ce(L()),de=le(L());var fe=Object.freeze({__proto__:null,verifyAccountProof:ue,verifyUserSignatures:de});const pe=o.log.deprecate({pkg:"FCL",subject:"fcl.verifyUserSignatures()",message:"Please use fcl.AppUtils.verifyUserSignatures()",callback:function(e,t){return de(e,t)}});function ge(e){return async function(n){const r=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).resolve||e.sdk.resolve;return Array.isArray(n)&&(n=await t.pipe(t.interaction(),n)),JSON.stringify(t.createSignableVoucher(await r(n)),null,2)}}const me=ge(L()),ye=/\[Error Code: (\d+)\]/;class ve extends Error{constructor(e,t){super(e),this.code=t,this.type=l.FvmErrorCode[t]}static fromErrorMessage(e){const t=e.match(ye),n=t?parseInt(t[1],10):void 0;return new ve(e,n||l.FvmErrorCode.UNKNOWN_ERROR)}}async function be(e,t){return Object.fromEntries(Object.entries(await e.config.where(t)).map((e=>{let[n,r]=e;return[n.replace(t,""),r]})))}const we=e=>5===e.status,he=e=>e.status>=4,Ee=e=>e.status>=3,Pe=e=>e.status>=2,Se=e=>e.status>=1,Ie=(e,t)=>{if(e===t)return!0;if("object"!=typeof e||"object"!=typeof t)return!1;if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const n in e)if(!Ie(e[n],t[n]))return!1;return!0},Te=(e,t)=>!Ie(e,t),ke=e=>{if("object"==typeof e&&(e=e.transactionId),null==e)throw new Error("transactionId required");return e},Ce=/^[0-9a-fA-F]{64}$/,Ae="POLL",Re="TIMEOUT",Oe=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{[u.INIT]:async t=>{setTimeout((()=>t.sendSelf(Re)),e.txNotFoundTimeout),t.sendSelf(Ae)},[u.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,u.UPDATED,e.all())},[u.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[u.SNAPSHOT]:async(e,t)=>{t.reply(e.all())},[Re]:async t=>{0===Object.keys(t.all()).length&&t.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${e.txNotFoundTimeout}ms)`))},[Ae]:async n=>{const r=()=>setTimeout((()=>n.sendSelf(Ae)),e.pollRate);let a;const o=n.all();try{a=await(async e=>t.send([t.getTransactionStatus(e)]).then(t.decode))(n.self())}catch(e){const t=e instanceof d.HTTPRequestError&&404===e.statusCode,a=e.code===f.grpc.Code.NotFound;return t||a?r():n.fatalError(e)}he(a)||r(),Te(o,a)&&n.broadcast(u.UPDATED,a),n.merge(a)}}},Ne=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>u.spawn(Oe(e),ke(t))};function je(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{txNotFoundTimeout:12500,pollRate:1e3};if(!Ce.test(ke(e)))throw new Error("Invalid transactionId");function n(n){return u.subscriber(ke(e),Ne(t),n)}function r(e){return function(){const t=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).suppress||!1;return new Promise(((r,a)=>{const o=n(((n,i)=>{if(!i&&!n.statusCode||t)e(n)&&(r(n),o());else if(null!=i)a(i),o();else if(1===n.statusCode){const e=ve.fromErrorMessage(n.errorMessage);a(e),o()}}))}))}}return{snapshot:function(){return u.snapshoter(e,Ne(t))},subscribe:n,onceFinalized:r(Pe),onceExecuted:r(Ee),onceSealed:r(he)}}je.isUnknown=e=>e.status>=0,je.isPending=Se,je.isFinalized=Pe,je.isExecuted=Ee,je.isSealed=he,je.isExpired=we;const _e="local",xe=new Map;function Ue(e){function n(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{txNotFoundTimeout:12500,pollRate:1e3};if(!Ce.test(ke(n)))throw new Error("Invalid transactionId");function a(){let a=xe.get(n);return a||(a=function(e,n,r){const a=new Set;let o={blockId:"",status:l.TransactionExecutionStatus.UNKNOWN,statusCode:0,errorMessage:"",events:[],statusString:""};async function i(){await M(e)()===_e?(console.warn("Events are not supported on the Flow emulator, falling back to legacy polling."),c()):s()}function s(){const r=e.sdk.subscribe({topic:l.SubscriptionTopic.TRANSACTION_STATUSES,args:{transactionId:n},onData:e=>{Te(o,e)&&(o=e,u(e)),he(e)&&new Promise((e=>setTimeout(e,0))).then((()=>{he(e)&&r.unsubscribe()}))},onError:e=>{e instanceof t.SubscriptionsNotSupportedError?(console.warn("Failed to subscribe to transaction status updates using real-time streaming (are you using the deprecated GRPC transport?), falling back to polling."),c()):d(e)}})}function c(){const e=je(n,r).subscribe(((t,n)=>{n?d(n):t&&Te(o,t)&&(o=t,u(t),he(t)&&new Promise((e=>setTimeout(e,0))).then((()=>{e()})))}))}function u(e){for(const t of a)try{t.onData(e)}catch(e){console.error("Error in transaction observer",e)}}function d(e){for(const t of a)try{t.onError(e)}catch(e){console.error("Error in transaction observer",e)}}return i().catch(d),{subscribe(e,t){const n={onData:e,onError:t||(()=>{})};return a.add(n),e(o),{unsubscribe:()=>a.delete(n)}},get value(){return o}}}(e,n,r),xe.set(n,a)),a}function o(e,t){const n=a(),{unsubscribe:r}=n.subscribe(e,t);return()=>r()}function i(e){return function(){const t=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{suppress:!1}).suppress||!1;return new Promise(((n,r)=>{const a=o((t=>{if(1===t.statusCode){const e=ve.fromErrorMessage(t.errorMessage);r(e),a()}else e(t)&&(n(t),a())}),(e=>{t||(r(e),a())}))}))}}return{snapshot:function(){return Promise.resolve(a().value)},subscribe:o,onceFinalized:i(Pe),onceExecuted:i(Ee),onceSealed:i(he)}}return n.isUnknown=t.isUnknown,n.isPending=Se,n.isFinalized=Pe,n.isExecuted=Ee,n.isSealed=he,n.isExpired=we,n}const Le=Ue(L());const De="TICK",Fe="hwm",Me=async(e,t)=>setTimeout((()=>t.sendSelf(De)),await e.config.get("fcl.eventPollRate",1e4));const Be=(e,n)=>u.spawn(function(e){return{[De]:async n=>{if(!n.hasSubs())return;let r=n.get(Fe);if(null==r)n.put(Fe,await e.sdk.block()),n.put(De,await Me(e,n));else{let a=await e.sdk.block();if(n.put(Fe,a),r.height<a.height){const o=await e.sdk.send([t.getEventsAtBlockHeightRange(n.self(),r.height+1,a.height)]).then(e.sdk.decode);for(let e of o)n.broadcast("UPDATED",e)}n.put(De,await Me(e,n))}},[u.SUBSCRIBE]:async(t,n)=>{t.hasSubs()||t.put(De,await Me(e,t)),t.subscribe(n.from)},[u.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from),e.hasSubs()||(clearTimeout(e.get(De)),e.delete(De),e.delete(Fe))}}}(e),n);function $e(e){return function(n){let r;return r="string"==typeof n?{eventTypes:[n]}:n||{},{subscribe:function(a){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>{console.error("Unhandled error in event subscription:",e)},i=()=>{},s=()=>{};function c(){if("string"!=typeof n)throw new Error("Legacy fcl.events fallback only supports string filters (single event type)");s=function(e){return function(t){return{subscribe:n=>u.subscriber(t,(t=>Be(e,t)),n)}}}(e)(n).subscribe(((e,t)=>{t?o(t):e&&a(e)}))}const d=async function(){"local"===await M(e)()?(console.warn("Events are not supported on the Flow emulator, falling back to legacy polling."),c()):function(){const{unsubscribe:n}=e.sdk.subscribe({topic:l.SubscriptionTopic.EVENTS,args:r,onData:e=>{a(e)},onError:e=>{e instanceof t.SubscriptionsNotSupportedError?(console.warn("Failed to subscribe to events using real-time streaming (are you using the deprecated GRPC transport?), falling back to legacy polling."),c()):o(e)}});i=n}()}().catch((e=>{o(e)}));return()=>{d.finally((()=>{i(),s()}))}}}}}const ze=$e(L()),qe=()=>{throw new Error("Platform specific Core Strategies are not initialized")},Ve={[G["EXT/RPC"]]:qe,[G["HTTP/POST"]]:qe,[G["IFRAME/RPC"]]:qe,[G["POP/RPC"]]:qe,[G["TAB/RPC"]]:qe,[G["EXT/RPC"]]:qe},He=["ServicePlugin"],We=["discovery-service"],Ke=e=>{let{coreStrategies:t}=e,n=new Set,a=new Map(Object.entries(t));const i=e=>n=new Set([...e]);return Object.freeze({add:e=>{if(r.invariant(We.includes(e.type),`Service Plugin type ${e.type} is not supported`),"discovery-service"===e.type){const{discoveryServices:t,serviceStrategy:n}=(e=>{const{services:t=[],serviceStrategy:n}=e;r.invariant(Array.isArray(t),"Services must be an array");for(const e of t)r.invariant(T(e.f_type)&&"Service"===e.f_type,"Service is required"),r.invariant(T(e.type)&&"authn"===e.type,`Service must be type authn. Received ${e.type}`),r.invariant(e.method in G||n.method===e.method,`Service method ${e.method} is not supported`);return r.invariant(T(n),"Service strategy is required"),r.invariant(T(n.method)&&C(n.method),"Service strategy method is required"),r.invariant(T(n.exec)&&A(n.exec),"Service strategy exec function is required"),{discoveryServices:t,serviceStrategy:n}})(e);i(t),a.has(n.method)?o.log({title:"Add Service Plugin",message:`Service strategy for ${n.method} already exists`,level:o.LEVELS.warn}):a.set(n.method,n.exec)}},getServices:()=>[...n],getStrategy:e=>a.get(e),getStrategies:()=>[...a.keys()]})};let Ge;const Je=()=>void 0!==Ge,Ye=e=>{let{coreStrategies:t}=e;if(Je())return Ge;const n=Ke({coreStrategies:t});return Ge=n,n},Xe=()=>Je()?Ge:(console.warn("Registry is not initalized, it will be initialized with stub core strategies"),Ye({coreStrategies:Ve})),Ze=(()=>{const e=new Map;return Object.freeze({add:t=>{const n=(e=>{let t;r.invariant(!!e,"No plugins supplied"),t=Array.isArray(e)?[...e]:[e];for(const e of t)r.invariant(T(e.name),"Plugin name is required"),r.invariant(T(e.f_type),"Plugin f_type is required"),r.invariant(He.includes(e.f_type),`Plugin type ${e.f_type} is not supported`);return t})(t);for(const t of n)e.set(t.name,t),"ServicePlugin"===t.f_type&&Ge.add(t)},getPlugins:()=>e})})(),Qe=async()=>[...window?.fcl_extensions||[],...Xe().getServices()];let et=!1;function tt(){return et}const nt=globalThis.URL;let rt=class extends nt{constructor(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];super(e,t,...r),tt()&&this._url&&!e.toString().endsWith("/")&&this._url.endsWith("/")&&(this._url=this._url.slice(0,-1))}};const at="authn",ot="SNAPSHOT",it="UPDATED",st="UPDATE_RESULTS",ct=async e=>{try{const t=await async function(e){let{context:t,types:n}=e;const a=await t.config.get("discovery.authn.endpoint");r.invariant(Boolean(a),'"discovery.authn.endpoint" in config must be defined.');const o=await t.config.get("discovery.authn.include",[]),i=await t.config.get("discovery.authn.exclude",[]),s=new rt(a);return fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:n,fclVersion:S,include:o,exclude:i,features:{suggested:await t.config.get("discovery.features.suggested",[])},clientServices:await Qe(),supportedStrategies:Xe().getStrategies(),userAgent:window?.navigator?.userAgent,network:await B()})}).then((e=>e.json()))}({context:e,types:[at]});u.send(at,st,{results:t})}catch(e){o.log({title:`${e.name} Error fetching Discovery API services.`,message:e.message,level:o.LEVELS.error})}};function lt(e){return{[u.INIT]:async t=>{var n,r;n="undefined"==typeof window,r='"fcl.discovery" is only available in the browser.',n&&console.warn(`\n      %cFCL Warning\n      ============================\n      ${r}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `,"font-weight:bold;font-family:monospace;"),"complete"===document.readyState?ct(e):window.addEventListener("load",(()=>{ct(e)}))},[st]:(e,t,n)=>{e.merge(n),e.broadcast(it,{...e.all()})},[u.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,it,{...e.all()})},[u.UNSUBSCRIBE]:(e,t)=>e.unsubscribe(t.from),[ot]:async(e,t)=>t.reply({...e.all()})}}const ut=e=>u.spawn(lt(e),at);function dt(e){return{subscribe:t=>u.subscriber(at,(()=>ut(e)),t),snapshot:()=>u.snapshoter(at,(()=>ut(e))),update:()=>{"complete"===document.readyState&&ct(e)}}}const ft={authn:dt(L())};function pt(e){const t=new p.SHA3(256);return t.update(c.Buffer.from(e,"utf8")),t.digest("hex")}function gt(e){let{contractName:t,address:n}=e;return{contractName:t,address:n,contract:""}}function mt(e){const t=[],n=e.match(/import ((\w|,| )+)* from 0x\w+/g)||[];for(const e of n){const n=/import ((\w+|, |)*) from (0x\w+)/g.exec(e),r=/((?:\w+)+),?/g,a=n?.[1].match(r)||[];for(const e of a)t.push(gt({address:n?.[3],contractName:e.replace(/,/g,"")}))}return t}function yt(e){return async function(n){let{address:r,contractName:a}=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=r,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=a,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof a,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[gt({contractName:a,address:r})];for(const n of i){const r=await e.sdk.send([t.getAccount(await e.config.get(n.address,n.address))],o).then(e.sdk.decode);if(n.contract=r.contracts?.[n.contractName],!n.contract)throw console.error("Did not find expected contract",n,r),new Error("Did not find expected contract");const a=mt(n.contract);i.push(...a)}const s=i.map((e=>pt(e.contract)));return pt((await Promise.all(s)).join(""))}}const vt=yt(L());async function bt(e,t,n){const r=[];for(const a of n){const n=[pt(a.network)],{address:o,dependency_pin_block_height:i}=a;if(a.dependency_pin){const r=await yt(e)({address:o,contractName:t,blockHeight:i});n.push(pt(r))}r.push(n)}return r}async function wt(e,t){const n=[];for(let r=0;r<t.length;r++){const a=t[r],o=[];for(let t=0;t<a?.contracts.length;t++){const n=a?.contracts[t],r=n?.contract;o.push(pt(r));const i=await bt(e,r,n?.networks);o.push(i)}n.push(o)}return n}function ht(e){return async function(t){let{template:n}=t;r.invariant(!!n,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),r.invariant("1.1.0"===n.f_version,"generateTemplateId({ template }) -- template object must be an version 1.1.0");const a=n.data,o=await Promise.all(a.messages.map((async e=>[pt(e.key),await Promise.all(e.i18n.map((async e=>[pt(e.tag),pt(e.translation)])))]))),i=await Promise.all(a?.parameters.sort(((e,t)=>e.index-t.index)).map((async e=>[pt(e.label),[pt(String(e.index)),pt(e.type),await Promise.all(e.messages.map((async e=>[pt(e.key),await Promise.all(e.i18n.map((async e=>[pt(e.tag),pt(e.translation)])))])))]]))),s=[await wt(e,a?.dependencies)],l=c.encode([pt(n?.f_type),pt(n?.f_version),pt(a?.type),pt(a?.interface),o,pt(a?.cadence?.body),[s],i]).toString("hex");return pt(l)}}const Et=ht(L());async function Pt(e){let{template:t}=e;switch(r.invariant(!!t,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof t,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===t.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),t.f_version){case"1.1.0":return await Et({template:t});case"1.0.0":return await async function(e){let{template:t}=e;r.invariant(!!t,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof t,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===t.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),r.invariant("1.0.0"===t.f_version,"generateTemplateId({ template }) -- template object must be an version 1.0.0");const n=t.data,a=await Promise.all(Object.keys(n.messages).map((async e=>[pt(e),await Promise.all(Object.keys(n.messages?.[e]?.i18n).map((async t=>[pt(t),pt(n.messages?.[e]?.i18n?.[t])])))]))),o=await Promise.all(Object.keys(n?.dependencies).map((async e=>[pt(e),await Promise.all(Object.keys(n?.dependencies?.[e]).map((async t=>[pt(t),await Promise.all(Object.keys(n?.dependencies?.[e]?.[t]).map((async r=>[pt(r),[pt(n?.dependencies?.[e]?.[t]?.[r].address),pt(n?.dependencies?.[e]?.[t]?.[r].contract),pt(n?.dependencies?.[e]?.[t]?.[r].fq_address),pt(n?.dependencies?.[e]?.[t]?.[r].pin),pt(String(n?.dependencies?.[e]?.[t]?.[r].pin_block_height))]])))])))]))),i=await Promise.all(Object.keys(n?.arguments).map((async e=>[pt(e),[pt(String(n?.arguments?.[e].index)),pt(n?.arguments?.[e].type),pt(n?.arguments?.[e].balance||""),await Promise.all(Object.keys(n?.arguments?.[e].messages).map((async t=>[pt(t),await Promise.all(Object.keys(n?.arguments?.[e].messages?.[t].i18n).map((async r=>[pt(r),pt(n?.arguments?.[e].messages?.[t].i18n?.[r])])))])))]]))),s=c.encode([pt("InteractionTemplate"),pt("1.0.0"),pt(n?.type),pt(n?.interface),a,pt(n?.cadence),o,i]).toString("hex");return pt(s)}({template:t});default:throw new Error("generateTemplateId Error: Unsupported template version")}}function St(e){return async function(n){let{address:r,contractName:a}=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=r,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=a,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof a,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[gt({contractName:a,address:r})];for(const n of i){const r=await e.sdk.send([t.getAccount(await e.config.get(n.address,n.address))],o).then(e.sdk.decode);if(n.contract=r.contracts?.[n.contractName],!n.contract)throw console.error("Did not find expected contract",n,r),new Error("Did not find expected contract");const a=mt(n.contract);i.push(...a)}const s=i.map((e=>pt(e.contract)));return pt(s.join(""))}}const It=St(L());async function Tt(e){let{version:n,address:r,contractName:a}=e;switch(t.invariant(null!=r,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=a,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof a,"generateDependencyPin({ contractName }) -- contractName must be a string"),n){case"1.1.0":return await vt({address:r,contractName:a});case"1.0.0":return await It({address:r,contractName:a});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}async function kt(e){let{template:n,blockHeight:r,network:a}=e;switch(t.invariant(null!=n,"generateDependencyPin({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateDependencyPin({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateDependencyPin({ template }) -- template must be an InteractionTemplate"),t.invariant(null!=a,"generateDependencyPin({ network }) network must be defined"),t.invariant(null!=r,"generateDependencyPin({ blockHeight }) blockHeight must be defined"),t.invariant("number"==typeof r,"generateDependencyPin({ blockHeight }) blockHeight must be a number"),n.f_version){case"1.0.0":const e=Object.keys(n.data.dependencies);for(let t of e){const e=n.data.dependencies[t],r=Object.keys(e);for(let e of r){const r=n.data.dependencies[t][e][a];if(void 0===r)continue;const i=await Tt({address:r.address,contractName:r.contract});if(i!==r.pin)return o.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                address: ${r.address} | contract: ${r.contract}\n                                computed: ${i}\n                                template: ${r.pin}\n                            `,level:o.LEVELS.debug}),!1}}return!0;case"1.1.0":let t=!1;for(let e=0;e<n.data?.dependencies.length;e++){const r=n.data?.dependencies[e];for(let e=0;e<r?.contracts.length;e++){const i=r?.contracts[e];for(let e=0;e<i?.networks.length;e++){const r=i?.networks[e];if(r.network===a){const e=await Tt({version:n.f_version,address:r.address,contractName:i.contract});if(e!==r.dependency_pin.pin)return o.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                    address: ${r.address} | contract: ${i.contract}\n                                    computed: ${e}\n                                    template: ${r.pin}\n                                `,level:o.LEVELS.debug}),!1;t=!0}}}}return t;default:throw new Error("verifyDependencyPinsSame Error: Unsupported template version")}}var Ct=Object.freeze({__proto__:null,deriveCadenceByNetwork:U,generateDependencyPin:Tt,generateDependencyPinAtLatestSealedBlock:async function(e){let{version:n,address:r,contractName:a}=e,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await t.block({sealed:!0},o),Tt({version:n,address:r,contractName:a})},generateTemplateId:Pt,getInteractionTemplateAudits:async function(e,n){let{template:r,auditors:a}=n,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.invariant(null!=r,"getInteractionTemplateAudits({ template }) -- template must be defined"),t.invariant("InteractionTemplate"===r.f_type,"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");let s=await Pt({template:r});if(s!==r.id)throw o.log({title:"getInteractionTemplateAudits Debug Error",message:`Could not recompute and match template ID\n                computed: ${s}\n                template: ${r.id}\n            `,level:o.LEVELS.debug}),new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");switch(r.f_version){case"1.1.0":case"1.0.0":const n=a||await e.config.get("flow.auditors");t.invariant(n,"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set"),t.invariant(Array.isArray(n),"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");let r=i.flowInteractionAuditContract;if(!r){const n=await M(e)(i);t.invariant("mainnet"===n||"testnet"===n,"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'"),r="mainnet"===n?"0xfd100e39d50a13e6":"0xf78bfc12d0a786dc"}const o=await V(e)({cadence:`\n        import FlowInteractionTemplateAudit from ${r}\n        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,args:(e,t)=>[e(s,t.String),e(n,t.Array(t.Address))]});return o;default:throw new Error("getInteractionTemplateAudits Error: Unsupported template version")}},getTemplateArgumentMessage:function(e){let{localization:n="en-US",argumentLabel:r,messageKey:a,template:o}=e;switch(t.invariant(a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string"),t.invariant(r,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined"),t.invariant("string"==typeof r,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string"),t.invariant(n,"getTemplateArgumentMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateArgumentMessage({ localization }) -- localization must be a string"),t.invariant(null!=o,"getTemplateArgumentMessage({ template }) -- template must be defined"),t.invariant("object"==typeof o,"getTemplateArgumentMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===o.f_type,"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate"),o.f_version){case"1.1.0":const e=o?.data?.parameters?.find((e=>e.label===r));if(!e)return;const t=e?.messages?.find((e=>e.key===a));if(!t)return;const i=t?.i18n?.find((e=>e.tag===n));if(!i)return;return i.translation;case"1.0.0":return o?.data?.arguments?.[r]?.messages?.[a]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}},getTemplateMessage:function(e){let{localization:t="en-US",messageKey:n,template:a}=e;switch(r.invariant(n,"getTemplateMessage({ messageKey }) -- messageKey must be defined"),r.invariant("string"==typeof n,"getTemplateMessage({ messageKey }) -- messageKey must be a string"),r.invariant(t,"getTemplateMessage({ localization }) -- localization must be defined"),r.invariant("string"==typeof t,"getTemplateMessage({ localization }) -- localization must be a string"),r.invariant(null!=a,"getTemplateMessage({ template }) -- template must be defined"),r.invariant("object"==typeof a,"getTemplateMessage({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===a.f_type,"getTemplateMessage({ template }) -- template object must be an InteractionTemplate"),a.f_version){case"1.1.0":const e=a?.data?.messages?.find((e=>e.key===n));if(!e)return;const r=e?.i18n?.find((e=>e.tag===t));if(!r)return;return r.translation;case"1.0.0":return a?.data?.messages?.[n]?.i18n?.[t];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}},verifyDependencyPinsSame:kt,verifyDependencyPinsSameAtLatestSealedBlock:async function(e){let{template:n,network:r}=e;const a=await t.block({sealed:!0}),o=a?.height;return kt({template:n,network:r,blockHeight:o})},verifyGeneratedTemplateId:async function(e){let{template:t}=e;return t.id===await Pt({template:t})}});const At=e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await async function(e,t){return N(e,"mutate",t)}(e,t),t=await $(e,t);const n=await e.config.get("fcl.authz",e.currentUser.authorization);return e.sdk.send([b.transaction(t.cadence),b.args(O(t.args||[])),t.limit&&R(t.limit)&&b.limit(t.limit),b.proposer(t.proposer||t.authz||n),b.payer(t.payer||t.authz||n),b.authorizations(t.authorizations||[t.authz||n])]).then(e.sdk.decode)}catch(e){throw e}};function Rt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...te,addr:s.sansPrefix(e.addr||e.address),signature:e.signature||e.sig,keyId:e.keyId}}function Ot(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{old:e,...X,type:"frame",endpoint:e.endpoint,params:e.params||{},data:e.data||{}}}function Nt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...X,type:"back-channel-rpc",endpoint:e.endpoint,method:e.method,params:e.params||{},data:e.data||{}}}function jt(e){return null==e?null:(null==e.method&&(e={...e,type:"local-view",method:"VIEW/IFRAME"}),e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...X,type:e.type||"local-view",method:e.method,endpoint:e.endpoint,data:e.data||{},params:e.params||{}})}function _t(e,t){return e.map((e=>function(e,t){try{return xt[e.type](e,t)}catch(t){return console.error(`Unrecognized FCL Service Type [${e.type}]`,e,t),e}}(e,t))).filter(Boolean)}const xt={"back-channel-rpc":Nt,"pre-authz":function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...X,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Z,address:s.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authz:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...X,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Z,address:s.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authn:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...X,type:e.type,uid:e.id,endpoint:e.authn,id:e.pid,provider:{address:s.withPrefix(e.addr),name:e.name,icon:e.icon}}},frame:Ot,"open-id":function(e){return null==e?null:"1.0.0"===e.f_vsn?e:null},"user-signature":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid user-signature service");return"1.0.0"===e.f_vsn?e:null},"local-view":jt,"account-proof":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("FCL Normalizer Error: Invalid account-proof service");return"1.0.0"===e.f_vsn?e:null},"authn-refresh":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid authn-refresh service");return"1.0.0"===e.f_vsn?e:null}};function Ut(){let e=arguments.length>1?arguments[1]:void 0;return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).reduce(((t,n)=>n.type===e&&(!t||P.compare(n.f_vsn,t.f_vsn)>0)?n:t),null)}function Lt(e){return E.encode([e.provider?.address||e.provider?.name||"UNSPECIFIED",e.id]).toString("hex")}async function Dt(e){var t=_t(function(){return[...arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],...arguments.length>1&&void 0!==arguments[1]?arguments[1]:[]]}((e=function(e){return e.addr=e.addr?s.withPrefix(e.addr):null,e.paddr=e.paddr?s.withPrefix(e.paddr):null,e}(e)).services||[],await async function(e,t){if(null==e||null==t)return[];const n=new rt(e);n.searchParams.append("code",t);const r=await fetch(n,{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>e.json()));if(Array.isArray(r))return r;const a=[];if(Array.isArray(r.authorizations))for(let e of r.authorizations)a.push({type:"authz",keyId:r.keyId,...e});return null!=r.provider&&a.push({type:"authn",id:"wallet-provider#authn",...r.provider}),a}(e.hks,e.code)));const n=Ut(t,"authn");return{...Q,addr:s.withPrefix(e.addr),cid:Lt(n),loggedIn:!0,services:t,expiresAt:e.expires}}const Ft="undefined"==typeof window;const Mt=globalThis.AbortController||require("abort-controller"),Bt=async e=>{let{service:t,body:n,config:r,abortSignal:a,customRpc:o,user:i,opts:s}=e;return Xe().getStrategy(t.method)({service:t,body:n,config:r,abortSignal:a,customRpc:o,opts:s,user:i})};async function $t(e,t){let{service:n,msg:a={},config:i={},opts:s={},platform:c,abortSignal:l=(new Mt).signal,execStrategy:u,user:d}=t;!function(){if(Ft)return;Xe().getStrategies().includes("WC/RPC")||h.log({title:"FCL WalletConnect Service Plugin",level:h.LEVELS.error,message:"All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information."})}(),a.data=n.data;const f={services:await be(e,/^service\./),app:await be(e,/^app\.detail\./),client:{...i.client,platform:c,fclVersion:S,fclLibrary:"https://github.com/onflow/fcl-js",hostname:window?.location?.hostname??null,network:await M(e)(s)}};try{const t=await(u||Bt)({service:n,body:a,config:f,opts:s,user:d,abortSignal:l});return"REDIRECT"===t.status?(r.invariant(n.type===t.data.type,"Cannot shift recursive service type in execService"),await $t(e,{service:t.data,msg:a,config:f,opts:s,abortSignal:l,platform:c,user:d})):t}catch(e){throw o.log({title:`Error on execService ${n?.type}`,message:e,level:o.LEVELS.error}),e}}const zt="CURRENT_USER",qt="CURRENT_USER/UPDATED",Vt="SNAPSHOT",Ht="SET_CURRENT_USER",Wt="DEL_CURRENT_USER",Kt='{\n  "f_type": "User",\n  "f_vsn": "1.0.0",\n  "addr":null,\n  "cid":null,\n  "loggedIn":null,\n  "expiresAt":null,\n  "services":[]\n}',Gt=e=>{const t=async()=>e.getStorageProvider?await e.getStorageProvider():await e.config.first(["fcl.storage","fcl.storage.default"],void 0);return{[u.INIT]:async e=>{"undefined"==typeof window&&console.warn('\n        %cFCL Warning\n        ============================\n        "currentUser" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        ',"font-weight:bold;font-family:monospace;"),e.merge(JSON.parse(Kt));const n=await t();if(n.can){const t=await(async e=>{const t=JSON.parse(Kt),n=await e.get(zt);return null!=n&&t.f_vsn!==n.f_vsn?(e.removeItem(zt),t):n||t})(n);(function(e){return null==e.expiresAt||0===e.expiresAt||e.expiresAt>Date.now()})(t)&&e.merge(t)}},[u.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,qt,{...e.all()})},[u.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[Vt]:async(e,t)=>{t.reply({...e.all()})},[Ht]:async(e,n,r)=>{e.merge(r);const a=await t();a.can&&a.put(zt,e.all()),e.broadcast(qt,{...e.all()})},[Wt]:async(e,n)=>{e.merge(JSON.parse(Kt));const r=await t();r.can&&r.put(zt,e.all()),e.broadcast(qt,{...e.all()})}}},Jt=e=>{u.spawn(Gt(e),e.actorName)};const Yt=async e=>{let{discoveryAuthnInclude:t,discoveryAuthnExclude:n,discoveryFeaturesSuggested:r}=e;return{client:{discoveryAuthnInclude:t,discoveryAuthnExclude:n,discoveryFeaturesSuggested:r,clientServices:await Qe(),supportedStrategies:Xe().getStrategies()}}},Xt=e=>async function(){let{service:t,redir:n=!1,forceReauth:a=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!t||t?.provider?.is_installed||!t?.provider?.requires_install)return new Promise((async(i,s)=>{Jt(e);const c={redir:n},l=await tn(e)(),d=Ut(l.services,"authn-refresh");let f;if(l.loggedIn&&!a){if(!d)return i(l);try{const t=await $t(e,{service:d,msg:f,opts:c,platform:e.platform,user:l});u.send(e.actorName,Ht,await Dt(t))}catch(e){o.log({title:`${e.name} Could not refresh wallet authentication.`,message:e.message,level:o.LEVELS.error})}finally{return i(await tn(e)())}}try{f=await async function(e){let t=await e.config.get("fcl.accountProof.resolver");if(null==t)return;if("function"!=typeof t)return void o.log({title:"Account Proof Data Resolver must be a function",message:`Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof t}\n                `,level:o.LEVELS.warn});const n={...await t()},a=window?.location?.origin;return n.appIdentifier?a&&(o.log.deprecate({pkg:"FCL",subject:"appIdentifier in fcl.accountProof.resolver",message:"Manually set app identifiers in the account proof resolver function are now deprecated.  These are now automatically set to the application origin URL by FCL",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-appIdentifier-field-in-account-proof-resolver"}),r.invariant("string"==typeof n.appIdentifier,"appIdentifier must be a string")):(r.invariant(a,"The appIdentifier (origin) could not be inferred from the window.location.origin.  Please set the appIdentifier manually in the fcl.accountProof.resolver function."),n.appIdentifier=a),r.invariant(/^[0-9a-f]+$/i.test(n.nonce),"Nonce must be a hex string"),n}(e)}catch(e){return o.log({title:`${e.name} On Authentication: Could not resolve account proof data.`,message:e.message,level:o.LEVELS.error}),s(e)}try{const n=await async function(e,t){const n=await e.config.get("discovery.authn.include",[]),a=await e.config.get("discovery.authn.exclude",[]),o=await e.config.get("discovery.features.suggested",[]),i=await e.config.first(["discovery.wallet.method","discovery.wallet.method.default"],void 0),s=t?.method?t.method:i,c=t?.endpoint??await e.config.first(["discovery.wallet","challenge.handshake"],void 0);return r.invariant(c,'\n    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.\n    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"\n    '),{...t,type:"authn",endpoint:c,method:s,discoveryAuthnInclude:n,discoveryAuthnExclude:a,discoveryFeaturesSuggested:o}}(e,t),a=await $t(e,{service:n,msg:f,config:await Yt(n),opts:c,platform:e.platform,execStrategy:e.discovery?.execStrategy,user:l});u.send(e.actorName,Ht,await Dt(a))}catch(e){o.log({title:`${e} On Authentication`,message:e,level:o.LEVELS.error})}finally{i(await tn(e)())}}));window.location.href=t?.provider?.install_link};function Zt(e){return function(){Jt(e),u.send(e.actorName,Wt)}}const Qt=e=>async t=>(Jt(e),{...t,tempId:"CURRENT_USER",async resolve(t,n){const r=await Xt(e)({redir:!0}),a=Ut(r.services,"authz"),o=Ut(r.services,"pre-authz");if(o)return(e=>(t,n)=>{let{user:r}=n;const a=(e=>({f_type:"PreAuthzResponse",f_vsn:"1.0.0",proposer:(e||{}).proposer,payer:(e||{}).payer||[],authorization:(e||{}).authorization||[]}))(t),o=[];null!=a.proposer&&o.push(["PROPOSER",a.proposer]);for(let e of a.payer||[])o.push(["PAYER",e]);for(let e of a.authorization||[])o.push(["AUTHORIZER",e]);return o.map((t=>{let[n,a]=t;return{tempId:[a.identity.address,a.identity.keyId].join("|"),addr:a.identity.address,keyId:a.identity.keyId,signingFunction:t=>$t(e,{service:a,msg:t,platform:e.platform,user:r}),role:{proposer:"PROPOSER"===n,payer:"PAYER"===n,authorizer:"AUTHORIZER"===n}}}))})(e)(await $t(e,{service:o,msg:n,platform:e.platform,user:r}),{user:r});if(a)return{...t,tempId:"CURRENT_USER",resolve:null,addr:s.sansPrefix(a.identity.address),keyId:a.identity.keyId,sequenceNum:null,signature:null,signingFunction:async t=>Rt(await $t(e,{service:a,msg:t,opts:{includeOlderJsonRpcCall:!0},platform:e.platform,user:r}))};throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER")}});function en(e){return function(t){Jt(e);const n="@EXIT",r=u.spawn((async r=>{for(r.send(e.actorName,u.SUBSCRIBE);;){const a=await r.receive();if(a.tag===n)return void r.send(e.actorName,u.UNSUBSCRIBE);t(a.data)}}));return()=>u.send(r,n)}}function tn(e){return function(){return Jt(e),u.send(e.actorName,Vt,null,{expectReply:!0,timeout:0})}}const nn=e=>async()=>{const{addr:n}=await Xt(e)();return t.arg(s.withPrefix(n),t.t.Address)},rn=e=>(r.invariant(/^[0-9a-f]+$/i.test(e),"Message must be a hex string"),{message:e}),an=e=>async t=>{Jt(e);const n=await Xt(e)({redir:!0}),a=Ut(n.services,"user-signature");r.invariant(a,"Current user must have authorized a signing service.");try{const r=await $t(e,{service:a,msg:rn(t),platform:e.platform,user:n});return Array.isArray(r)?r.map((e=>Rt(e))):[Rt(r)]}catch(e){return e}},on=e=>{const t={authenticate:Xt(e),unauthenticate:Zt(e),authorization:Qt(e),signUserMessage:an(e),subscribe:en(e),snapshot:tn(e),resolveArgument:nn(e)};return Object.assign((()=>({...t})),{...t})};function sn(e){const t=new rt(e.endpoint);if(window?.location?.origin&&t.searchParams.append("l6n",window.location.origin),null!=e.params)for(let[n,r]of Object.entries(e.params||{}))t.searchParams.append(n,r);return t}function cn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=t.method||"POST",r="GET"===n?void 0:JSON.stringify(t.data||e.data||{});return fetch(sn(e),{method:n,headers:{...e.headers||{},...t.headers||{},"Content-Type":"application/json"},body:r}).then((e=>e.json()))}function ln(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...ee,status:e.status??"APPROVED",reason:e.reason??null,data:e.compositeSignature||e.data||{...e}||{},updates:Nt(e.authorizationUpdates),local:Ot((e.local||[])[0])}}const un={"HTTP/GET":"GET","HTTP/POST":"POST"},dn=e=>(r.invariant(un[e.method],"Invalid Service Method for type back-channel-rpc",{service:e}),un[e.method]);async function fn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>!0;r.invariant(e,"Missing Polling Service",{service:e});if(!t())throw new Error("Externally Halted");let n;try{if("undefined"!=typeof document&&"hidden"===document.visibilityState)return await new Promise((e=>setTimeout(e,500))),fn(e,t);n=await cn(e,{method:dn(e)}).then(ln)}catch(e){throw e}switch(n?.status){case"APPROVED":return n.data;case"DECLINED":throw new Error(`Declined: ${n.reason||"No reason supplied."}`);default:return await new Promise((e=>setTimeout(e,500))),fn(n?.updates,t)}}const pn="FCL:VIEW:CLOSE",gn="FCL:VIEW:READY",mn="FCL:VIEW:RESPONSE",yn=e=>"string"==typeof e&&e.toLowerCase(),vn=new Set(["monetizationstart","monetizationpending","monetizationprogress","monetizationstop"]),bn=(e,t)=>console.warn("DEPRECATION NOTICE",`Received ${e}, please use ${t} for this and future versions of FCL`);function wn(e){let n;if(e.flowJson){r.invariant(!!e.flowNetwork,"If flowJson is provided, flowNetwork must also be specified.");const t=e.flowNetwork.toLowerCase().replace(/^local$/,"emulator");r.invariant("mainnet"===t||"testnet"===t||"emulator"===t,`Invalid flowNetwork: ${e.flowNetwork}. Must be one of: mainnet, testnet, emulator.`),n=i.getContracts(e.flowJson,t)}const a=t.createSdkClient({accessNodeUrl:e.accessNodeUrl,transport:e.transport,computeLimit:e.computeLimit,customResolver:e.customResolver,customDecoders:e.customDecoders,contracts:n}),o=function(e){const t=new Map([["platform",e.platform],["discovery.wallet",e.discoveryWallet],["discovery.wallet.method",e.discoveryWalletMethod],["discovery.authn.endpoint",e.discoveryAuthnEndpoint],["flow.network",e.flowNetwork],["accessNode.api",e.accessNodeUrl],["fcl.limit",e.computeLimit],["app.detail.title",e.appDetailTitle],["app.detail.icon",e.appDetailIcon],["app.detail.description",e.appDetailDescription],["app.detail.url",e.appDetailUrl],["service.OpenID.scopes",e.serviceOpenIdScopes]]);for(const[e,n]of t.entries())void 0===n&&t.delete(e);const n=new Set,r={get:async(e,n)=>t.has(e)?t.get(e):n,put:async(e,a)=>(t.set(e,a),n.forEach((e=>e(t))),r),update:async(e,a)=>{const o=a(t.get(e));return t.set(e,o),n.forEach((e=>e(t))),r},delete:async e=>(t.delete(e),n.forEach((e=>e(t))),r),where:async e=>{const n={};for(const[r,a]of t.entries())e.test(r)&&(n[r]=a);return n},first:async(e,n)=>{"string"==typeof e&&(e=[e]);for(const n of e)if(t.has(n))return t.get(n);return n},subscribe:e=>(n.add(e),()=>{n.delete(e)}),all:async()=>Object.fromEntries(t.entries())};return r}(e),s=(c={platform:e.platform,storage:e.storage,config:o,discovery:{execStrategy:e.discovery?.execStrategy},sdk:a},on({...c,getStorageProvider:async()=>c.storage,discovery:c.discovery,actorName:`${zt}_${y.v4()}`}));var c;return{storage:e.storage,currentUser:s,sdk:a,config:o,platform:e.platform}}var hn;hn||(hn=L()),hn.config.subscribe((()=>{M(hn)({enableRequestLogging:!1}).catch((()=>{}))})),Object.defineProperty(e,"TestUtils",{enumerable:!0,get:function(){return t.TestUtils}}),Object.defineProperty(e,"account",{enumerable:!0,get:function(){return t.account}}),Object.defineProperty(e,"arg",{enumerable:!0,get:function(){return t.arg}}),Object.defineProperty(e,"args",{enumerable:!0,get:function(){return t.args}}),Object.defineProperty(e,"atBlockHeight",{enumerable:!0,get:function(){return t.atBlockHeight}}),Object.defineProperty(e,"atBlockId",{enumerable:!0,get:function(){return t.atBlockId}}),Object.defineProperty(e,"authorization",{enumerable:!0,get:function(){return t.authorization}}),Object.defineProperty(e,"authorizations",{enumerable:!0,get:function(){return t.authorizations}}),Object.defineProperty(e,"block",{enumerable:!0,get:function(){return t.block}}),Object.defineProperty(e,"build",{enumerable:!0,get:function(){return t.build}}),Object.defineProperty(e,"createSignableVoucher",{enumerable:!0,get:function(){return t.createSignableVoucher}}),Object.defineProperty(e,"decode",{enumerable:!0,get:function(){return t.decode}}),Object.defineProperty(e,"flowEmulator",{enumerable:!0,get:function(){return t.flowEmulator}}),Object.defineProperty(e,"flowMainnet",{enumerable:!0,get:function(){return t.flowMainnet}}),Object.defineProperty(e,"flowTestnet",{enumerable:!0,get:function(){return t.flowTestnet}}),Object.defineProperty(e,"getAccount",{enumerable:!0,get:function(){return t.getAccount}}),Object.defineProperty(e,"getBlock",{enumerable:!0,get:function(){return t.getBlock}}),Object.defineProperty(e,"getBlockHeader",{enumerable:!0,get:function(){return t.getBlockHeader}}),Object.defineProperty(e,"getCollection",{enumerable:!0,get:function(){return t.getCollection}}),Object.defineProperty(e,"getEvents",{enumerable:!0,get:function(){return t.getEvents}}),Object.defineProperty(e,"getEventsAtBlockHeightRange",{enumerable:!0,get:function(){return t.getEventsAtBlockHeightRange}}),Object.defineProperty(e,"getEventsAtBlockIds",{enumerable:!0,get:function(){return t.getEventsAtBlockIds}}),Object.defineProperty(e,"getNetworkParameters",{enumerable:!0,get:function(){return t.getNetworkParameters}}),Object.defineProperty(e,"getNodeVersionInfo",{enumerable:!0,get:function(){return t.getNodeVersionInfo}}),Object.defineProperty(e,"getTransaction",{enumerable:!0,get:function(){return t.getTransaction}}),Object.defineProperty(e,"getTransactionStatus",{enumerable:!0,get:function(){return t.getTransactionStatus}}),Object.defineProperty(e,"invariant",{enumerable:!0,get:function(){return t.invariant}}),Object.defineProperty(e,"isBad",{enumerable:!0,get:function(){return t.isBad}}),Object.defineProperty(e,"isOk",{enumerable:!0,get:function(){return t.isOk}}),Object.defineProperty(e,"limit",{enumerable:!0,get:function(){return t.limit}}),Object.defineProperty(e,"nodeVersionInfo",{enumerable:!0,get:function(){return t.nodeVersionInfo}}),Object.defineProperty(e,"param",{enumerable:!0,get:function(){return t.param}}),Object.defineProperty(e,"params",{enumerable:!0,get:function(){return t.params}}),Object.defineProperty(e,"payer",{enumerable:!0,get:function(){return t.payer}}),Object.defineProperty(e,"ping",{enumerable:!0,get:function(){return t.ping}}),Object.defineProperty(e,"pipe",{enumerable:!0,get:function(){return t.pipe}}),Object.defineProperty(e,"proposer",{enumerable:!0,get:function(){return t.proposer}}),Object.defineProperty(e,"ref",{enumerable:!0,get:function(){return t.ref}}),Object.defineProperty(e,"script",{enumerable:!0,get:function(){return t.script}}),Object.defineProperty(e,"send",{enumerable:!0,get:function(){return t.send}}),Object.defineProperty(e,"subscribe",{enumerable:!0,get:function(){return t.subscribe}}),Object.defineProperty(e,"subscribeEvents",{enumerable:!0,get:function(){return t.subscribeEvents}}),Object.defineProperty(e,"subscribeRaw",{enumerable:!0,get:function(){return t.subscribeRaw}}),Object.defineProperty(e,"transaction",{enumerable:!0,get:function(){return t.transaction}}),Object.defineProperty(e,"validator",{enumerable:!0,get:function(){return t.validator}}),Object.defineProperty(e,"voucherIntercept",{enumerable:!0,get:function(){return t.voucherIntercept}}),Object.defineProperty(e,"voucherToTxId",{enumerable:!0,get:function(){return t.voucherToTxId}}),Object.defineProperty(e,"why",{enumerable:!0,get:function(){return t.why}}),e.t=w,Object.defineProperty(e,"config",{enumerable:!0,get:function(){return i.config}}),Object.defineProperty(e,"display",{enumerable:!0,get:function(){return s.display}}),Object.defineProperty(e,"sansPrefix",{enumerable:!0,get:function(){return s.sansPrefix}}),Object.defineProperty(e,"withPrefix",{enumerable:!0,get:function(){return s.withPrefix}}),Object.defineProperty(e,"cadence",{enumerable:!0,get:function(){return g.template}}),Object.defineProperty(e,"cdc",{enumerable:!0,get:function(){return g.template}}),e.AppUtils=fe,e.CORE_STRATEGIES=G,e.FCL_REDIRECT_URL_PARAM_NAME=W,e.FCL_RESPONSE_PARAM_NAME=K,e.InteractionTemplateUtils=Ct,e.TransactionError=ve,e.URL=rt,e.VERSION=S,e.WalletUtils=oe,e.buildMessageHandler=e=>{let t,{close:n,send:r,onReady:a,onResponse:o,onMessage:i,onCustomRpc:s,getSource:c}=e;return e=>{try{t=c?.()||t}catch(e){t=null}try{if("object"!=typeof e.data)return;if(vn.has(e.data.type))return;if(null!=t&&e.source!==t)return;yn(e.data.type)===yn(pn)&&n(),yn(e.data.type)===yn(gn)&&(a(e,{send:r,close:n}),t||=e.source),yn(e.data.type)===yn(mn)&&o(e,{send:r,close:n}),yn(e.data.type)===yn("FCL:VIEW:CUSTOM_RPC")&&s(e.data.payload,{send:r,close:n}),i(e,{send:r,close:n}),yn(e.data.type)===yn("FCL:FRAME:READY")&&(bn(e.data.type,gn),a(e,{send:r,close:n}),t||=e.source),yn(e.data.type)===yn("FCL:FRAME:RESPONSE")&&(bn(e.data.type,mn),o(e,{send:r,close:n})),yn(e.data.type)===yn("FCL:FRAME:CLOSE")&&(bn(e.data.type,pn),n()),yn(e.data.type)===yn("FCL::CHALLENGE::RESPONSE")&&(bn(e.data.type,mn),o(e,{send:r,close:n})),yn(e.data.type)===yn("FCL::AUTHZ_READY")&&(bn(e.data.type,gn),a(e,{send:r,close:n}),t||=e.source),yn(e.data.type)===yn("FCL::CHALLENGE::CANCEL")&&(bn(e.data.type,pn),n()),yn(e.data.type)===yn("FCL::CANCEL")&&(bn(e.data.type,pn),n())}catch(e){console.error("Frame Callback Error",e),n()}}},e.createFlowClientCore=function(e){const t=wn({...e,transport:e.transport||d.httpTransport});return{currentUser:t.currentUser,mutate:At(t),query:V(t),queryRaw:z(t),verifyUserSignatures:le(t),getChainId:M(t),tx:Ue(t),events:$e(t),authenticate:t.currentUser.authenticate,unauthenticate:t.currentUser.unauthenticate,signUserMessage:t.currentUser.signUserMessage,serialize:ge(t),...t.sdk}},e.discovery=ft,e.events=ze,e.execStrategy=Bt,e.getChainId=B,e.getCurrentUser=e=>{const t=L();return on({...t,getStorageProvider:async()=>e.getStorageProvider?await e.getStorageProvider():await i.config.first(["fcl.storage","fcl.storage.default"],void 0),platform:e.platform,actorName:zt,discovery:e.discovery})},e.getExecHttpPost=e=>async t=>{let{service:n,body:r,config:a,opts:o}=t;const i=await cn(n,{data:{fclVersion:S,service:{params:n.params,data:n.data,type:n.type},config:a,...r}}).then(ln);if("APPROVED"===i?.status)return i.data;if("DECLINED"===i?.status)throw new Error(`Declined: ${i.reason||"No reason supplied."}`);if("REDIRECT"===i?.status)return i;if("PENDING"===i?.status){let t=!0,n=!0;const[r,a]=await e(jt(i.local),{serviceEndpoint:sn,onClose:()=>n=!1}),o=()=>{try{a(),n=!1}catch(e){console.error("Frame Close Error",e)}},s=()=>{const e=t;return t=n,e};return fn(i.updates,s).then((e=>(o(),e))).catch((e=>{throw console.error(e),o(),e}))}throw console.error("Auto Decline: Invalid Response",{service:n,resp:i}),new Error("Auto Decline: Invalid Response")},e.getMutate=e=>{const t={...L(),currentUser:e};return At(t)},e.initServiceRegistry=Ye,e.isReactNative=tt,e.normalizePollingResponse=ln,e.pluginRegistry=Ze,e.query=H,e.queryRaw=q,e.serialize=me,e.serviceEndpoint=sn,e.setIsReactNative=function(e){et=e},e.tx=Le,e.verifyUserSignatures=pe,Object.keys(l).forEach((function(t){"default"===t||Object.prototype.hasOwnProperty.call(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:function(){return l[t]}})}))}));
//# sourceMappingURL=fcl-core.umd.min.js.map
