{"version":3,"file":"fcl-core.umd.min.js","sources":["../src/VERSION.ts","../src/utils/is.ts","../src/exec/utils/normalize-args.ts","../src/exec/utils/pre.ts","../src/document/document.ts","../src/interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network-1.1.0.ts","../src/interaction-template-utils/utils/replace-string-imports.ts","../src/interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network.ts","../src/interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network-1.0.0.ts","../src/context/global.ts","../src/utils/chain-id/get-chain-id.ts","../src/utils/chain-id/fetch-chain-id.ts","../src/exec/utils/prep-template-opts.ts","../src/exec/query-raw.ts","../src/exec/query.ts","../src/utils/constants.ts","../src/wallet-utils/on-message-from-fcl.ts","../src/wallet-utils/send-msg-to-fcl.ts","../src/normalizers/service/__vsn.ts","../src/wallet-utils/encode-account-proof.ts","../src/wallet-utils/CompositeSignature.ts","../src/wallet-utils/inject-ext-service.ts","../src/app-utils/verify-signatures.ts","../src/exec/verify.ts","../src/serialize/index.ts","../src/transaction/transaction-error.ts","../src/default-config.ts","../src/transaction/utils.ts","../src/transaction/constants.ts","../src/transaction/legacy-polling.js","../src/transaction/transaction.ts","../src/events/legacy-events.ts","../src/events/index.ts","../src/current-user/exec-service/plugins.ts","../src/discovery/utils.ts","../src/utils/is-react-native.ts","../src/utils/url.ts","../src/discovery/services/authn.ts","../src/discovery/services.ts","../src/discovery/index.ts","../src/interaction-template-utils/utils/hash.ts","../src/interaction-template-utils/utils/generate-import.ts","../src/interaction-template-utils/utils/find-imports.ts","../src/interaction-template-utils/generate-dependency-pin/generate-dependency-pin-1.1.0.ts","../src/interaction-template-utils/generate-template-id/generate-template-id-1.1.0.ts","../src/interaction-template-utils/generate-template-id/generate-template-id.ts","../src/interaction-template-utils/generate-template-id/generate-template-id-1.0.0.ts","../src/interaction-template-utils/generate-dependency-pin/generate-dependency-pin-1.0.0.ts","../src/interaction-template-utils/generate-dependency-pin/generate-dependency-pin.ts","../src/interaction-template-utils/verify-dependency-pin-same-at-block.ts","../src/interaction-template-utils/get-interaction-template-audits.ts","../src/interaction-template-utils/get-template-argument-message.ts","../src/interaction-template-utils/get-template-message.ts","../src/exec/mutate.ts","../src/normalizers/service/composite-signature.ts","../src/normalizers/service/frame.ts","../src/normalizers/service/back-channel-rpc.ts","../src/normalizers/service/local-view.ts","../src/normalizers/service/service.ts","../src/normalizers/service/pre-authz.ts","../src/normalizers/service/authz.ts","../src/normalizers/service/authn.ts","../src/normalizers/service/open-id.ts","../src/normalizers/service/user-signature.ts","../src/normalizers/service/account-proof.ts","../src/normalizers/service/authn-refresh.ts","../src/current-user/service-of-type.ts","../src/current-user/build-user.ts","../src/current-user/merge-services.ts","../src/current-user/fetch-services.ts","../src/current-user/exec-service/wc-check.ts","../src/current-user/exec-service/index.ts","../src/current-user/index.ts","../src/current-user/exec-service/strategies/utils/service-endpoint.ts","../src/current-user/exec-service/strategies/utils/fetch-service.ts","../src/normalizers/service/polling-response.ts","../src/current-user/exec-service/strategies/utils/poll.ts","../src/current-user/exec-service/strategies/utils/buildMessageHandler.ts","../src/context/index.ts","../src/utils/chain-id/chain-id-watcher.ts","../src/client.ts","../src/current-user/exec-service/strategies/http-post.ts"],"sourcesContent":["declare const PACKAGE_CURRENT_VERSION: string | undefined\n\nexport const VERSION: string = PACKAGE_CURRENT_VERSION || \"TESTVERSION\"\n","const is =\n  <T>(type: string) =>\n  (d: any): d is T =>\n    typeof d === type\n\n/**\n * @description Checks if a value is required (not null or undefined). This is a type guard that\n * ensures the value is not null or undefined, useful for validation and filtering operations.\n *\n * @param d The value to check for null or undefined\n * @returns True if the value is not null or undefined, false otherwise\n *\n * @example\n * // Filter out null/undefined values from an array\n * import * as fcl from \"@onflow/fcl\"\n *\n * const values = [1, null, \"hello\", undefined, true]\n * const requiredValues = values.filter(fcl.isRequired)\n * console.log(requiredValues) // [1, \"hello\", true]\n */\nexport const isRequired = (d: any): d is NonNullable<any> => d != null\n\n/**\n * @description Type guard that checks if a value is an object. This is useful for runtime type checking\n * and ensuring type safety when working with dynamic data.\n *\n * @param d The value to check\n * @returns True if the value is an object, false otherwise\n *\n * @example\n * // Check if a value is an object\n * import * as fcl from \"@onflow/fcl\"\n *\n * const obj = { name: \"Flow\" }\n * const notObj = \"string\"\n * console.log(fcl.isObject(obj)) // true\n * console.log(fcl.isObject(notObj)) // false\n */\nexport const isObject = is<object>(\"object\")\n\n/**\n * @description Type guard that checks if a value is a string. Useful for validating input types\n * and ensuring type safety in your applications.\n *\n * @param d The value to check\n * @returns True if the value is a string, false otherwise\n *\n * @example\n * // Validate string input\n * import * as fcl from \"@onflow/fcl\"\n *\n * const text = \"Hello, Flow!\"\n * const notText = 123\n * console.log(fcl.isString(text)) // true\n * console.log(fcl.isString(notText)) // false\n */\nexport const isString = is<string>(\"string\")\n\n/**\n * @description Type guard that checks if a value is a function. This is particularly useful\n * when working with callbacks, event handlers, or optional function parameters.\n *\n * @param d The value to check\n * @returns True if the value is a function, false otherwise\n *\n * @example\n * // Check if a callback is provided\n * import * as fcl from \"@onflow/fcl\"\n *\n * const callback = () => console.log(\"Hello\")\n * const notCallback = \"string\"\n * console.log(fcl.isFunc(callback)) // true\n * console.log(fcl.isFunc(notCallback)) // false\n */\nexport const isFunc = is<Function>(\"function\")\n\n/**\n * @description Type guard that checks if a value is a number. This includes both integers\n * and floating-point numbers, but excludes NaN and Infinity.\n *\n * @param d The value to check\n * @returns True if the value is a number, false otherwise\n *\n * @example\n * // Validate numeric input\n * import * as fcl from \"@onflow/fcl\"\n *\n * const num = 42\n * const notNum = \"42\"\n * console.log(fcl.isNumber(num)) // true\n * console.log(fcl.isNumber(notNum)) // false\n */\nexport const isNumber = is<number>(\"number\")\n","import {isFunc} from \"../../utils/is\"\nimport * as sdk from \"@onflow/sdk\"\nimport * as t from \"@onflow/types\"\nimport type {ArgsFn} from \"../args\"\n\n/**\n * @description Normalizes function or array arguments into a standard array format for use with\n * Flow transactions and scripts. If the input is a function, it executes the function with\n * sdk.arg and types as parameters. Otherwise, returns an empty array.\n *\n * @param ax Arguments function, array, or undefined value to normalize\n * @returns Normalized array of arguments ready for use with Flow transactions/scripts\n *\n * @example\n * // Using with function-style arguments\n * const argsFn = (arg, t) => [\n *   arg(\"Hello\", t.String),\n *   arg(42, t.Int)\n * ]\n * const normalized = normalizeArgs(argsFn)\n * // Returns: [{value: \"Hello\", xform: ...}, {value: 42, xform: ...}]\n */\nexport function normalizeArgs(ax: ArgsFn | any[] | undefined): any[] {\n  if (isFunc(ax)) return (ax as ArgsFn)(sdk.arg, t)\n  return []\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {isRequired, isObject, isString} from \"../../utils/is\"\nimport {FCLContext} from \"../../context\"\n\nexport interface PreOptions {\n  cadence?: string\n  template?: any\n}\n\nasync function pre(\n  context: Pick<FCLContext, \"config\">,\n  type: string,\n  opts: PreOptions\n): Promise<void> {\n  // prettier-ignore\n  invariant(isRequired(opts), `${type}(opts) -- opts is required`)\n  // prettier-ignore\n  invariant(isObject(opts), `${type}(opts) -- opts must be an object`)\n  // prettier-ignore\n  invariant(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`)\n  // prettier-ignore\n  invariant(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`)\n  // // prettier-ignore\n  invariant(\n    isString(opts.cadence) || opts?.template,\n    `${type}({ cadence }) -- cadence must be a string`\n  )\n  // prettier-ignore\n  invariant(\n    await context.config.get(\"accessNode.api\"),\n    `${type}(opts) -- Required value for \"accessNode.api\" not defined in config. See: ${\"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration\"}`\n  )\n}\n\n/**\n * @description Validates and prepares options for Flow transaction execution (mutations). This function\n * performs comprehensive validation of the provided options to ensure they meet the requirements for\n * executing transactions on the Flow blockchain, including checking for required configuration values.\n *\n * @param opts Options object containing either Cadence code or template references for the transaction\n * @param opts.cadence Optional Cadence transaction code string\n * @param opts.template Optional interaction template object or reference\n * @returns Promise that resolves when validation passes\n * @throws Error if validation fails or required configuration is missing\n *\n * @example\n * // Validate transaction options with Cadence code\n * await preMutate({\n *   cadence: \"transaction { execute { log(\\\"Hello Flow!\\\") } }\"\n * })\n *\n * // Validate transaction options with template\n * await preMutate({\n *   template: transferFlowTemplate\n * })\n */\nexport async function preMutate(\n  context: {\n    config: FCLContext[\"config\"]\n  },\n  opts: PreOptions\n): Promise<void> {\n  return pre(context, \"mutate\", opts)\n}\n\n/**\n * @description Validates and prepares options for Flow script execution (queries). This function\n * performs comprehensive validation of the provided options to ensure they meet the requirements for\n * executing scripts on the Flow blockchain, including checking for required configuration values.\n *\n * @param opts Options object containing either Cadence code or template references for the script\n * @param opts.cadence Optional Cadence script code string\n * @param opts.template Optional interaction template object or reference\n * @returns Promise that resolves when validation passes\n * @throws Error if validation fails or required configuration is missing\n *\n * @example\n * // Validate script options with Cadence code\n * await preQuery({\n *   cadence: \"access(all) fun main(): String { return \\\"Hello Flow!\\\" }\"\n * })\n *\n * // Validate script options with template\n * await preQuery({\n *   template: getAccountTemplate\n * })\n */\nexport async function preQuery(\n  context: Pick<FCLContext, \"config\">,\n  opts: PreOptions\n): Promise<void> {\n  return pre(context, \"query\", opts)\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport fetchTransport from \"cross-fetch\"\nimport {ConfigService, FCLContext} from \"../context\"\n\ninterface DocumentResolverParams {\n  url: string\n}\n\nexport interface RetrieveParams {\n  url: string\n}\n\nasync function httpDocumentResolver({\n  url,\n}: DocumentResolverParams): Promise<any> {\n  invariant(\n    typeof url !== \"undefined\",\n    \"retrieve({ url }) -- url must be defined\"\n  )\n\n  let res: Response\n  try {\n    res = await fetchTransport(url)\n  } catch (e) {\n    throw new Error(\"httpDocumentResolver Error: Failed to retrieve document.\")\n  }\n\n  let document = res.ok ? await res.json() : null\n\n  return document\n}\n\nconst DOCUMENT_RESOLVERS: Map<string, typeof httpDocumentResolver> = new Map([\n  [\"http\", httpDocumentResolver],\n  [\"https\", httpDocumentResolver],\n])\n\n/**\n * @description Retrieves a document from a URL using protocol-specific resolvers. This function\n * supports HTTP/HTTPS by default and can be extended with custom resolvers through FCL configuration.\n * It's used internally by FCL to fetch interaction templates and other external documents.\n *\n * @param params The retrieval parameters\n * @param params.url The URL of the document to retrieve\n * @returns Promise that resolves to the retrieved document (typically a JSON object)\n * @throws {Error} If URL is invalid, protocol is unsupported, or retrieval fails\n *\n * @example\n * // Retrieve an interaction template\n * const template = await retrieve({\n *   url: \"https://flix.flow.com/v1.0/templates/transfer-flow-tokens\"\n * })\n * console.log(\"Template:\", template)\n */\nexport async function retrieve(\n  context: Pick<FCLContext, \"config\">,\n  {url}: RetrieveParams\n): Promise<any> {\n  invariant(\n    typeof url !== \"undefined\",\n    \"retrieve({ url }) -- url must be defined\"\n  )\n  invariant(\n    typeof url === \"string\",\n    \"retrieve({ url }) -- url must be a string\"\n  )\n\n  const documentResolversFromConfig = await context.config.where(\n    /^document\\.resolver\\./\n  )\n  Object.keys(documentResolversFromConfig).map(key => {\n    const resolverFromConfig = documentResolversFromConfig[key]\n    const resolverProtocol = key.replace(/^document\\.resolver\\./, \"\")\n    DOCUMENT_RESOLVERS.set(\n      resolverProtocol,\n      resolverFromConfig as typeof httpDocumentResolver\n    )\n  })\n\n  const urlParts: any = /^(.*):\\/\\/([A-Za-z0-9\\-\\.]+)(:[0-9]+)?(.*)$/.exec(url)\n  invariant(urlParts, \"Failed to parse URL\")\n  const protocol = urlParts[1]\n  invariant(urlParts, \"Failed to parse URL protocol\")\n\n  const resolver: any = DOCUMENT_RESOLVERS.get(protocol)\n  invariant(resolver, `No resolver found for protcol=${protocol}`)\n\n  let document = await resolver({url})\n\n  return document\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {replaceStringImports} from \"../utils/replace-string-imports\"\nimport type {InteractionTemplate110} from \"../interaction-template\"\n\nexport interface DeriveCadenceByNetwork110Params {\n  network: string\n  template: InteractionTemplate110\n}\n\n/**\n * @description Fills import addresses in Cadence for network\n *\n * @param params\n * @param params.network Network to derive Cadence for\n * @param params.template Interaction Template to derive Cadence from\n * @returns Promise that resolves with the derived Cadence code\n */\nexport async function deriveCadenceByNetwork110({\n  network,\n  template,\n}: DeriveCadenceByNetwork110Params): Promise<string> {\n  invariant(\n    template.f_version === \"1.1.0\",\n    \"deriveCadenceByNetwork110({ template }) -- template must be version 1.1.0\"\n  )\n\n  // get network dependencies from template dependencies, use new string import format\n  const networkDependencies: Record<string, string> = {}\n\n  template?.data?.dependencies.forEach(dependency => {\n    dependency.contracts.forEach(contract => {\n      const contractName = contract.contract\n      contract.networks.forEach(net => {\n        if (net.network === network) {\n          networkDependencies[contractName] = net.address\n        }\n      })\n\n      invariant(\n        networkDependencies[contractName] !== undefined,\n        `deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${network} ${contractName}`\n      )\n    })\n  })\n\n  invariant(\n    Object.keys(networkDependencies).length ===\n      template?.data?.dependencies.length,\n    `deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${networkDependencies}`\n  )\n\n  invariant(\n    Object.keys(networkDependencies).length ===\n      Object.values(networkDependencies).length,\n    `deriveCadenceByNetwork110 -- Could not find all addresses for network ${network} dependencies:  ${networkDependencies}`\n  )\n\n  invariant(\n    !!template?.data?.cadence?.body,\n    `no cadence found -- Could not replace import dependencies: ${networkDependencies}`\n  )\n\n  return replaceStringImports({\n    cadence: template?.data?.cadence?.body,\n    networkDependencies,\n  })\n}\n","export interface ReplaceStringImportsParams {\n  cadence: string\n  networkDependencies: Record<string, string>\n}\n\n/**\n * @description Replaces string imports with the actual contract address\n *\n * @param params\n * @param params.cadence The Cadence code\n * @param params.networkDependencies Network dependencies mapping\n * @returns Cadence code with replaced imports\n */\nexport function replaceStringImports({\n  cadence,\n  networkDependencies,\n}: ReplaceStringImportsParams): string {\n  return Object.keys(networkDependencies).reduce((c, contractName) => {\n    const address = networkDependencies[contractName]\n    const regex = new RegExp(`import \"\\\\b${contractName}\\\\b\"`, \"g\")\n    return c.replace(regex, `import ${contractName} from ${address}`)\n  }, cadence)\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {deriveCadenceByNetwork100} from \"./derive-cadence-by-network-1.0.0\"\nimport {deriveCadenceByNetwork110} from \"./derive-cadence-by-network-1.1.0\"\nimport type {InteractionTemplate} from \"../interaction-template\"\n\nexport interface DeriveCadenceByNetworkParams {\n  network: string\n  template: InteractionTemplate\n}\n\n/**\n * @description Fills import addresses in Cadence for network\n *\n * @param params\n * @param params.network Network to derive Cadence for\n * @param params.template Interaction Template to derive Cadence from\n * @returns Promise that resolves with the derived Cadence code\n */\nexport async function deriveCadenceByNetwork({\n  network,\n  template,\n}: DeriveCadenceByNetworkParams): Promise<string> {\n  invariant(\n    network != undefined,\n    \"deriveCadenceByNetwork({ network }) -- network must be defined\"\n  )\n  invariant(\n    typeof network === \"string\",\n    \"deriveCadenceByNetwork({ network }) -- network must be a string\"\n  )\n\n  invariant(\n    template != undefined,\n    \"deriveCadenceByNetwork({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"deriveCadenceByNetwork({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      return await deriveCadenceByNetwork110({network, template})\n    case \"1.0.0\":\n      return await deriveCadenceByNetwork100({network, template})\n    default:\n      throw new Error(\n        \"deriveCadenceByNetwork Error: Unsupported template version\"\n      )\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport type {InteractionTemplate100} from \"../interaction-template\"\n\nexport interface DeriveCadenceByNetwork100Params {\n  network: string\n  template: InteractionTemplate100\n}\n\n/**\n * @description Fills import addresses in Cadence for network\n *\n * @param params\n * @param params.network Network to derive Cadence for\n * @param params.template Interaction Template to derive Cadence from\n * @returns Promise that resolves with the derived Cadence code\n */\nexport async function deriveCadenceByNetwork100({\n  network,\n  template,\n}: DeriveCadenceByNetwork100Params): Promise<string> {\n  invariant(\n    template.f_version === \"1.0.0\",\n    \"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0\"\n  )\n\n  const networkDependencies: [string, string][] = Object.keys(\n    template?.data?.dependencies\n  ).map((dependencyPlaceholder: string): [string, string] => {\n    const dependencyNetworkContracts = Object.values(\n      template?.data?.dependencies?.[dependencyPlaceholder]\n    )\n\n    invariant(\n      dependencyNetworkContracts !== undefined,\n      `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`\n    )\n\n    invariant(\n      dependencyNetworkContracts.length > 0,\n      `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`\n    )\n\n    const dependencyContract = dependencyNetworkContracts[0]\n    const dependencyContractForNetwork = dependencyContract?.[network]\n\n    invariant(\n      dependencyContractForNetwork as any,\n      `deriveCadenceByNetwork100 -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`\n    )\n\n    return [dependencyPlaceholder, dependencyContractForNetwork?.address]\n  })\n\n  return networkDependencies.reduce(\n    (cadence: string, [placeholder, address]: [string, string]) => {\n      const regex = new RegExp(\"(\\\\b\" + placeholder + \"\\\\b)\", \"g\")\n      return cadence.replace(regex, address)\n    },\n    template.data.cadence\n  )\n}\n","import {FCLContext} from \"./index\"\nimport {config as _config} from \"@onflow/config\"\nimport {\n  send,\n  decode,\n  subscribe,\n  subscribeRaw,\n  account,\n  block,\n  resolve,\n} from \"@onflow/sdk\"\n\n/**\n * Note to self:\n * Create the partial context\n * Then you need to make functions take only the necessary parts of the context\n * This way you can avoid the issue where the subtype does not satisfy the args\n */\n\n/**\n * Create a global FCL Context based on the current global config.\n *\n * Some configuration values are still curried to the context as a backward compatibility measure.\n */\nexport function createPartialGlobalFCLContext(): Pick<\n  FCLContext,\n  \"config\" | \"sdk\"\n> {\n  return {\n    config: _config(),\n    sdk: {\n      send,\n      decode,\n      subscribe,\n      subscribeRaw,\n      account,\n      block,\n      resolve,\n    },\n  }\n}\n","import {fetchChainId} from \"./fetch-chain-id\"\nimport {log} from \"@onflow/util-logger\"\nimport {FCLContext} from \"../../context\"\nimport {createPartialGlobalFCLContext} from \"../../context/global\"\n\n// Cache of chainId promises for each access node value\n// key: access node, value: chainId promise\nlet chainIdCache: Record<string, Promise<string> | null> = {}\n\nlet hasWarnedFlowNetwork: boolean = false\nlet hasWarnedEnv: boolean = false\n\nexport interface GetChainIdOptions {\n  node?: unknown\n  enableRequestLogging?: boolean\n  [key: string]: any\n}\n\nexport function createGetChainId(context: {\n  config: FCLContext[\"config\"]\n  sdk: FCLContext[\"sdk\"]\n}) {\n  /**\n   * @description\n   * Gets the chain ID if its set, otherwise gets the chain ID from the access node\n   *\n   * @param opts Optional configuration parameters\n   * @param opts.node Override the access node URL for this request instead of using the configured one\n   * @param opts.enableRequestLogging Enable logging for the chain ID request\n   * @returns Promise that resolves to the chain ID string (e.g., \"mainnet\", \"testnet\", \"local\")\n   * @throws If the chain ID cannot be determined from configuration or access node\n   *\n   * @example\n   * // Get chain ID using configured access node\n   * import * as fcl from \"@onflow/fcl\"\n   *\n   * const chainId = await fcl.getChainId()\n   * console.log(\"Connected to:\", chainId) // \"testnet\" or \"mainnet\"\n   */\n  async function getChainId(opts: GetChainIdOptions = {}): Promise<string> {\n    let flowNetworkCfg: string | null = await context.config.get(\"flow.network\")\n    let envCfg: string | null = await context.config.get(\"env\")\n\n    /* \n    TODO: Add deprecation warning for flow.network config key\n    Remove this if statement when deprecation is complete\n\n    config.load() depends on flow.network config key even though this deprecation\n    warning has been available since https://github.com/onflow/fcl-js/pull/1420\n    it has effectively never been shown because of an issue in the implementation\n    of getChainId()\n\n    Showing this warning is the correct and intended behavior, but it would lead to\n    mixed messaging for users since config.load() depends on flow.network config key\n\n    We need to remove the dependency on flow.network config key from config.load()\n    before we can show this warning.\n  */\n    if (false && flowNetworkCfg && !hasWarnedFlowNetwork) {\n      log.deprecate({\n        pkg: \"FCL\",\n        subject:\n          'Using the \"flow.network\" configuration key for specifying the flow network',\n        message: \"Configuring flow.network is no longer required\",\n        transition:\n          \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-flow.network-config-key\",\n      })\n      hasWarnedFlowNetwork = true\n    }\n\n    if (envCfg && !hasWarnedEnv) {\n      log.deprecate({\n        pkg: \"FCL\",\n        subject:\n          'Using the \"env\" configuration key for specifying the flow network',\n        message: \"Configuring to specify flow network is no longer required\",\n        transition:\n          \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key\",\n      })\n      hasWarnedEnv = true\n    }\n\n    const accessNode = opts.node || (await context.config.get(\"accessNode.api\"))\n    if (!accessNode) {\n      // Fall back to deprecated flow.network and env config keys\n      // This probably should have been done before trying to fetch the chainId from the access node\n      // However, this was the behaviour with the initial implementation of getChainId()\n      if (flowNetworkCfg) {\n        return flowNetworkCfg\n      } else if (envCfg) {\n        return envCfg\n      }\n\n      throw new Error(\n        `Either the \"accessNode.api\" config key or opts.node must be set`\n      )\n    }\n\n    // Try using cached chainId first if it exists and access node is the same\n    if (chainIdCache[accessNode as string]) {\n      try {\n        return await chainIdCache[accessNode as string]!\n      } catch {}\n    }\n\n    // If no cached chainId, value is stale, or last attempt failed, try getting chainId from access node\n    // Check if another getChainId() call has already started a new promise, if not, start a new one\n    // There may have been concurrent calls to getChainId() while the first call was waiting for the response\n    if (!chainIdCache[accessNode as string]) {\n      chainIdCache[accessNode as string] = fetchChainId(context, opts).catch(\n        (error: Error) => {\n          // If there was an error, reset the promise so that the next call will try again\n          chainIdCache[accessNode as string] = null\n          throw error\n        }\n      )\n    }\n\n    // Use newly created promise\n    try {\n      return await chainIdCache[accessNode as string]!\n    } catch (e: any) {\n      // Fall back to deprecated flow.network and env config keys\n      // This probably should have been done before trying to fetch the chainId from the access node\n      // However, this was the behaviour with the initial implementation of getChainId()\n      if (flowNetworkCfg) {\n        return flowNetworkCfg\n      } else if (envCfg) {\n        return envCfg\n      }\n\n      throw new Error(\n        `Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`\n      )\n    }\n  }\n\n  return getChainId\n}\n\n/**\n * @description Clears the internal chain ID cache used by getChainId function. This is primarily useful\n * for testing scenarios where you need to reset the cached chain ID values, or when switching between\n * different access nodes and want to ensure fresh chain ID fetching.\n *\n * @example\n * // Clear cache during testing\n * import * as fcl from \"@onflow/fcl\"\n *\n * // Clear cache\n * fcl.clearChainIdCache()\n *\n * // Now getChainId will fetch fresh data\n * const chainId = await fcl.getChainId()\n */\nexport function clearChainIdCache(): void {\n  chainIdCache = {}\n}\n\nexport const getChainId = /* @__PURE__ */ createGetChainId(\n  createPartialGlobalFCLContext()\n)\n","import {getNetworkParameters} from \"@onflow/sdk\"\nimport {FCLContext} from \"../../context\"\n\n/**\n * @description Fetches the chain ID from the Flow network by querying the network parameters.\n * The chain ID is a unique identifier for the specific Flow network (mainnet, testnet, etc.)\n * and is essential for ensuring transactions are executed on the correct network.\n *\n * @param opts Optional configuration object that can contain network access settings and other parameters\n * @returns Promise that resolves to the chain ID string (e.g., \"flow-mainnet\", \"flow-testnet\")\n *\n * @example\n * // Fetch chain ID from the configured network\n * const chainId = await fetchChainId()\n * console.log(chainId) // \"flow-mainnet\" or \"flow-testnet\"\n */\nexport async function fetchChainId(\n  context: Pick<FCLContext, \"sdk\">,\n  opts: Record<string, any> = {}\n): Promise<string> {\n  const response = await context.sdk\n    .send([getNetworkParameters()], opts)\n    .then(context.sdk.decode)\n  return response.chainId\n}\n","import {retrieve} from \"../../document/document\"\nimport {deriveCadenceByNetwork} from \"../../interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network\"\nimport {isString} from \"../../utils/is\"\nimport {FCLContext} from \"../../context\"\nimport {createGetChainId} from \"../../utils\"\n\nexport interface TemplateOptions {\n  cadence?: string\n  template?: any\n}\n\n/**\n * @description Prepares and processes template options for Flow transactions and scripts. This function handles\n * the resolution of interaction templates by either fetching them from a URL or using provided template data,\n * and derives the appropriate Cadence code based on the current network configuration.\n *\n * @param opts Template options object that can contain either direct Cadence code or template references\n * @param opts.cadence Optional Cadence code string to use directly\n * @param opts.template Optional template object or URL string. If a URL string is provided, the template will be fetched\n * @returns Promise that resolves to the processed template options with resolved Cadence code\n *\n * @example\n * // Prepare template with direct Cadence code\n * const opts = await prepTemplateOpts({\n *   cadence: \"transaction { execute { log(\\\"Hello Flow!\\\") } }\"\n * })\n *\n * // Prepare template from URL\n * const opts = await prepTemplateOpts({\n *   template: \"https://flix.flow.com/v1/templates/transfer-flow\"\n * })\n *\n * // Prepare template with template object\n * const opts = await prepTemplateOpts({\n *   template: {\n *     f_type: \"InteractionTemplate\",\n *     f_version: \"1.1.0\",\n *     id: \"transfer-flow\",\n *     data: { cadence: { \"flow-mainnet\": \"transaction { ... }\" } }\n *   }\n * })\n */\nexport async function prepTemplateOpts(\n  context: Pick<FCLContext, \"config\" | \"sdk\">,\n  opts: TemplateOptions\n): Promise<TemplateOptions> {\n  if (isString(opts?.template)) {\n    opts.template = await retrieve(context, {url: opts?.template})\n  }\n\n  const cadence =\n    opts.cadence ||\n    (await deriveCadenceByNetwork({\n      template: opts.template,\n      network: await createGetChainId(context)(opts),\n    }))\n\n  opts.cadence = cadence\n\n  return opts\n}\n","import * as sdk from \"@onflow/sdk\"\nimport type {ArgsFn} from \"./args\"\nimport {normalizeArgs} from \"./utils/normalize-args\"\nimport {preQuery} from \"./utils/pre\"\nimport {prepTemplateOpts} from \"./utils/prep-template-opts\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nexport interface QueryOptions {\n  cadence?: string\n  args?: ArgsFn\n  template?: any\n  isSealed?: boolean\n  limit?: number\n}\n\nexport function createQueryRaw(context: Pick<FCLContext, \"sdk\" | \"config\">) {\n  /**\n   * @description Allows you to submit scripts to query the blockchain and get raw response data.\n   *\n   * @param opts Query Options and configuration\n   * @param opts.cadence Cadence Script used to query Flow\n   * @param opts.args Arguments passed to cadence script\n   * @param opts.template Interaction Template for a script\n   * @param opts.isSealed Block Finality\n   * @param opts.limit Compute Limit for Query\n   * @returns A promise that resolves to the raw query result\n   *\n   * @example\n   * import * as fcl from '@onflow/fcl';\n   *\n   * const result = await fcl.queryRaw({\n   *   cadence: `\n   *     access(all) fun main(a: Int, b: Int, addr: Address): Int {\n   *       log(addr)\n   *       return a + b\n   *     }\n   *   `,\n   *   args: (arg, t) => [\n   *     arg(7, t.Int), // a: Int\n   *     arg(6, t.Int), // b: Int\n   *     arg('0xba1132bc08f82fe2', t.Address), // addr: Address\n   *   ],\n   * });\n   */\n  async function queryRaw(opts: QueryOptions = {}): Promise<any> {\n    await preQuery(context, opts)\n    opts = await prepTemplateOpts(context, opts)\n\n    return context.sdk.send([\n      sdk.script(opts.cadence!),\n      sdk.args(normalizeArgs(opts.args || [])),\n      sdk.atLatestBlock(opts.isSealed ?? false),\n      opts.limit &&\n        typeof opts.limit === \"number\" &&\n        (sdk.limit(opts.limit!) as any),\n    ])\n  }\n\n  return queryRaw\n}\n\nexport const queryRaw = /* @__PURE__ */ createQueryRaw(\n  createPartialGlobalFCLContext()\n)\n","import {createQueryRaw, QueryOptions} from \"./query-raw\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nexport function createQuery(context: Pick<FCLContext, \"sdk\" | \"config\">) {\n  /**\n   * @description Allows you to submit scripts to query the blockchain.\n   *\n   * @param opts Query options configuration\n   * @param opts.cadence A valid cadence script (required)\n   * @param opts.args Any arguments to the script if needed should be supplied via a function that returns an array of arguments\n   * @param opts.limit Compute (Gas) limit for query.\n   * @param opts.template Interaction Template for a script\n   * @param opts.isSealed Block Finality\n   * @returns A JSON representation of the response\n   *\n   * @example\n   * import * as fcl from '@onflow/fcl';\n   *\n   * const result = await fcl.query({\n   *   cadence: `\n   *     access(all) fun main(a: Int, b: Int, addr: Address): Int {\n   *       log(addr)\n   *       return a + b\n   *     }\n   *   `,\n   *   args: (arg, t) => [\n   *     arg(7, t.Int), // a: Int\n   *     arg(6, t.Int), // b: Int\n   *     arg('0xba1132bc08f82fe2', t.Address), // addr: Address\n   *   ],\n   * });\n   * console.log(result); // 13\n   */\n  async function query(opts: QueryOptions = {}): Promise<any> {\n    return createQueryRaw(context)(opts).then(context.sdk.decode)\n  }\n\n  return query\n}\n\nexport const query = /* @__PURE__ */ createQuery(\n  createPartialGlobalFCLContext()\n)\n","export const FCL_REDIRECT_URL_PARAM_NAME: string = \"fcl_redirect_url\"\nexport const FCL_RESPONSE_PARAM_NAME: string = \"fclResponseJson\"\n\nexport const CORE_STRATEGIES: Record<string, string> = {\n  \"HTTP/RPC\": \"HTTP/RPC\",\n  \"HTTP/POST\": \"HTTP/POST\",\n  \"IFRAME/RPC\": \"IFRAME/RPC\",\n  \"POP/RPC\": \"POP/RPC\",\n  \"TAB/RPC\": \"TAB/RPC\",\n  \"EXT/RPC\": \"EXT/RPC\",\n  \"DEEPLINK/RPC\": \"DEEPLINK/RPC\",\n}\n","/**\n * @description Sets up a message listener to receive messages from the parent FCL application. This\n * function is used by wallet services to listen for specific message types from FCL and respond\n * accordingly. It handles message filtering, data sanitization, and provides context about the\n * message origin for security purposes.\n *\n * @param messageType The specific message type to listen for (e.g., \"FCL:VIEW:READY:RESPONSE\")\n * @param cb Callback function executed when a matching message is received\n * @param cb.data The message data received from FCL, with deprecated fields removed\n * @param cb.context Context object providing security information\n * @param cb.context.origin The origin URL of the FCL application sending the message\n *\n * @returns Function to remove the event listener and stop listening for messages\n *\n * @example\n * // Listen for authentication requests from FCL\n * import { onMessageFromFCL } from \"@onflow/fcl\"\n *\n * const removeListener = onMessageFromFCL(\"FCL:VIEW:READY:RESPONSE\", (data, context) => {\n *   console.log(\"FCL is ready for communication\")\n *   console.log(\"Message from:\", context.origin)\n *   console.log(\"Ready data:\", data)\n *\n *   // Verify origin for security\n *   if (context.origin === \"https://myapp.com\") {\n *     initializeWalletServices()\n *   } else {\n *     console.warn(\"Unexpected origin:\", context.origin)\n *   }\n * })\n *\n * // Stop listening when wallet service closes\n * window.addEventListener(\"beforeunload\", () => {\n *   removeListener()\n * })\n */\nexport const onMessageFromFCL = (\n  messageType: string,\n  cb: (data: any, context: {origin: string}) => void = () => {}\n): (() => void) => {\n  const buildData = (data: any): any => {\n    if (data.deprecated)\n      console.warn(\"DEPRECATION NOTICE\", data.deprecated.message)\n    delete data?.body?.interaction\n\n    return data\n  }\n\n  const internal = (e: MessageEvent): void => {\n    const {data, origin} = e\n    if (typeof data !== \"object\") return\n    if (typeof data == null) return\n    if (data.type !== messageType) return\n\n    cb(buildData(data), {origin})\n  }\n\n  window.addEventListener(\"message\", internal)\n  return () => window.removeEventListener(\"message\", internal)\n}\n","import {\n  FCL_REDIRECT_URL_PARAM_NAME,\n  FCL_RESPONSE_PARAM_NAME,\n} from \"../utils/constants\"\nimport {onMessageFromFCL} from \"./on-message-from-fcl\"\n\nexport interface PollingResponse {\n  f_type: \"PollingResponse\"\n  f_vsn: \"1.0.0\"\n  status: \"APPROVED\" | \"DECLINED\" | \"REDIRECT\"\n  reason: string | null\n  data: any\n}\n\n/**\n * @description Sends messages from a wallet or service back to the parent FCL application. This function\n * handles communication between wallet UIs (running in iframes, popups, or redirects) and the main FCL\n * application. It automatically detects the communication method (redirect, iframe, or popup) and sends\n * the message accordingly.\n *\n * @param type The message type identifier (e.g., \"FCL:VIEW:RESPONSE\", \"FCL:VIEW:READY\")\n * @param msg Optional message payload containing response data\n * @param msg.f_type FCL message format type, should be \"PollingResponse\"\n * @param msg.f_vsn FCL message format version, should be \"1.0.0\"\n * @param msg.status Response status\n * @param msg.reason Reason for the response (especially for DECLINED status)\n * @param msg.data Actual response data (signatures, account info, etc.)\n *\n * @throws When unable to communicate with parent FCL instance\n *\n * @example\n * // Send approval response with signature data\n * import { sendMsgToFCL } from \"@onflow/fcl\"\n *\n * sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n *   f_type: \"CompositeSignature\",\n *   f_vsn: \"1.0.0\",\n *   addr: \"0x1234567890abcdef\",\n *   keyId: 0,\n *   signature: \"abc123...\"\n * })\n */\nexport const sendMsgToFCL = (type: string, msg?: PollingResponse): void => {\n  const data = {...msg, type}\n\n  const urlParams = new URLSearchParams(window.location.search)\n  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME)\n  if (redirectUrl) {\n    const url = new URL(redirectUrl)\n    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data))\n    window.location.href = url.href\n  } else if (window.location !== window.parent.location) {\n    window.parent.postMessage({...msg, type}, \"*\")\n  } else if (window.opener) {\n    window.opener.postMessage({...msg, type}, \"*\")\n  } else {\n    throw new Error(\"Unable to communicate with parent FCL instance\")\n  }\n}\n\n/**\n * @description Initiates the communication handshake between a wallet service and FCL. This function\n * listens for the \"FCL:VIEW:READY:RESPONSE\" message from FCL and automatically sends \"FCL:VIEW:READY\"\n * to indicate the wallet service is ready to receive requests. This is typically the first function\n * called when a wallet service loads.\n *\n * @param cb Callback function executed when FCL responds with ready confirmation\n * @param cb.data Data received from FCL ready response\n * @param cb.context Context object containing origin information\n * @param cb.context.origin Origin of the FCL application\n * @param msg Optional message payload to include with ready signal\n *\n * @example\n * // Basic wallet service initialization\n * import { ready } from \"@onflow/fcl\"\n *\n * ready((data, context) => {\n *   console.log(\"FCL is ready to communicate\")\n *   console.log(\"FCL origin:\", context.origin)\n *   console.log(\"Ready data:\", data)\n *\n *   // Wallet service is now ready to handle authentication requests\n *   initializeWalletUI()\n * })\n */\nexport const ready = (\n  cb: (data: any, context: {origin: string}) => void,\n  msg: PollingResponse = {} as PollingResponse\n): void => {\n  onMessageFromFCL(\"FCL:VIEW:READY:RESPONSE\", cb)\n  sendMsgToFCL(\"FCL:VIEW:READY\")\n}\n\n/**\n * @description Closes the wallet service window/iframe and notifies FCL that the service is shutting down.\n * This should be called when the user cancels an operation or when the wallet service needs to close itself.\n *\n * Sends \"FCL:VIEW:CLOSE\".\n */\nexport const close = (): void => {\n  sendMsgToFCL(\"FCL:VIEW:CLOSE\")\n}\n\n/**\n * @description Sends an approval response to FCL with the provided data. This indicates that the user\n * has approved the requested operation (authentication, transaction signing, etc.) and includes the\n * resulting data (signatures, account information, etc.).\n *\n * Sends \"FCL:VIEW:RESPONSE\". with status \"APPROVED\".\n *\n * @param data The approval data to send back to FCL (signatures, account info, etc.)\n *\n * @example\n * // Approve authentication with account data\n * import { approve } from \"@onflow/fcl\"\n *\n * const accountData = {\n *   f_type: \"AuthnResponse\",\n *   f_vsn: \"1.0.0\",\n *   addr: \"0x1234567890abcdef\",\n *   services: [\n *     {\n *       f_type: \"Service\",\n *       f_vsn: \"1.0.0\",\n *       type: \"authz\",\n *       method: \"HTTP/POST\",\n *       endpoint: \"https://wallet.example.com/authz\"\n *     }\n *   ]\n * }\n *\n * approve(accountData)\n */\nexport const approve = (data: any): void => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"APPROVED\",\n    reason: null,\n    data: data,\n  })\n}\n\n/**\n * @description Sends a decline response to FCL indicating that the user has rejected or cancelled\n * the requested operation. This should be called when the user explicitly cancels an operation\n * or when an error prevents the operation from completing.\n *\n * Sends \"FCL:VIEW:RESPONSE\". with status \"DECLINED\".\n *\n * @param reason Human-readable reason for declining the request\n *\n * @example\n * // Decline when user cancels authentication\n * import { decline } from \"@onflow/fcl\"\n *\n * document.getElementById('cancel-btn').addEventListener('click', () => {\n *   decline(\"User cancelled authentication\")\n * })\n */\nexport const decline = (reason: string): void => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"DECLINED\",\n    reason: reason,\n    data: null,\n  })\n}\n\n/**\n * @description Sends a redirect response to FCL indicating that the operation requires a redirect\n * to complete. This is used when the wallet service needs to redirect the user to another URL\n * (such as a native app deep link or external service).\n *\n * Sends \"FCL:VIEW:RESPONSE\". with status \"REDIRECT\".\n *\n * @param data Redirect data containing the target URL and any additional parameters\n *\n * @example\n * // Redirect to native wallet app\n * import { redirect } from \"@onflow/fcl\"\n *\n * redirect({\n *   f_type: \"RedirectResponse\",\n *   f_vsn: \"1.0.0\",\n *   url: \"flow-wallet://sign?transaction=abc123\",\n *   callback: \"https://myapp.com/callback\"\n * })\n */\nexport const redirect = (data: any): void => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"REDIRECT\",\n    reason: null,\n    data: data,\n  })\n}\n","export const SERVICE_PRAGMA = {\n  f_type: \"Service\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const IDENTITY_PRAGMA = {\n  f_type: \"Identity\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const PROVIDER_PRAGMA = {\n  f_type: \"Provider\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const USER_PRAGMA = {\n  f_type: \"USER\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const POLLING_RESPONSE_PRAGMA = {\n  f_type: \"PollingResponse\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const COMPOSITE_SIGNATURE_PRAGMA = {\n  f_type: \"CompositeSignature\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const OPEN_ID_PRAGMA = {\n  f_type: \"OpenId\",\n  f_vsn: \"1.0.0\",\n}\n","import {sansPrefix} from \"@onflow/util-address\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {Buffer, encode as rlpEncode} from \"@onflow/rlp\"\n\nexport interface AccountProofData {\n  address?: string\n  nonce?: string\n  appIdentifier?: string\n}\n\nconst rightPaddedHexBuffer = (value: string, pad: number): Buffer =>\n  Buffer.from(value.padEnd(pad * 2, \"0\"), \"hex\")\n\nconst leftPaddedHexBuffer = (value: string, pad: number): Buffer =>\n  Buffer.from(value.padStart(pad * 2, \"0\"), \"hex\")\n\nconst addressBuffer = (addr: string): Buffer => leftPaddedHexBuffer(addr, 8)\n\nconst nonceBuffer = (nonce: string): Buffer => Buffer.from(nonce, \"hex\")\n\n/**\n * @description Encodes account proof data for cryptographic signing on the Flow blockchain. This function\n * creates a standardized message format that combines the application identifier, account address,\n * and nonce into a format suitable for cryptographic signing. The encoded message can then be signed\n * by the account's private key to create an account proof.\n *\n * @param data Object containing the account proof components\n * @param data.address The Flow account address for which to create the proof\n * @param data.nonce A random hexadecimal string (minimum 32 bytes/64 hex chars) to prevent replay attacks\n * @param data.appIdentifier A unique identifier for your application to prevent cross-app replay attacks\n * @param includeDomainTag Whether to include the FCL domain tag in the encoding\n *\n * @returns The encoded message as a hexadecimal string ready for signing\n *\n * @throws If required parameters are missing or invalid, or if nonce is too short\n *\n * @example\n * // Basic account proof encoding\n * import { encodeAccountProof } from \"@onflow/fcl\"\n *\n * const accountProofData = {\n *   address: \"0x1234567890abcdef\",\n *   nonce: \"75f8587e5bd982ec9289c5be1f9426bd12b4c1de9c7a7e4d8c5f9e8b2a7c3f1e9\", // 64 hex chars (32 bytes)\n *   appIdentifier: \"MyAwesomeApp\"\n * }\n *\n * const encodedMessage = encodeAccountProof(accountProofData)\n * console.log(\"Encoded message:\", encodedMessage)\n */\nexport const encodeAccountProof = (\n  {address, nonce, appIdentifier}: AccountProofData,\n  includeDomainTag: boolean = true\n): string => {\n  invariant(\n    !!address,\n    \"Encode Message For Provable Authn Error: address must be defined\"\n  )\n  invariant(\n    !!nonce,\n    \"Encode Message For Provable Authn Error: nonce must be defined\"\n  )\n  invariant(\n    !!appIdentifier,\n    \"Encode Message For Provable Authn Error: appIdentifier must be defined\"\n  )\n\n  invariant(\n    nonce!.length >= 64,\n    \"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes\"\n  )\n\n  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(\n    Buffer.from(\"FCL-ACCOUNT-PROOF-V0.0\").toString(\"hex\"),\n    32\n  )\n\n  if (includeDomainTag) {\n    return Buffer.concat([\n      ACCOUNT_PROOF_DOMAIN_TAG,\n      rlpEncode([\n        appIdentifier,\n        addressBuffer(sansPrefix(address!)),\n        nonceBuffer(nonce!),\n      ]),\n    ]).toString(\"hex\")\n  }\n\n  return rlpEncode([\n    appIdentifier,\n    addressBuffer(sansPrefix(address!)),\n    nonceBuffer(nonce!),\n  ]).toString(\"hex\")\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {COMPOSITE_SIGNATURE_PRAGMA} from \"../normalizers/service/__vsn\"\n\n/**\n * @description Creates a new CompositeSignature instance. CompositeSignature is a standardized\n * signature format used in the Flow ecosystem to represent cryptographic signatures along with\n * the signing account information. It includes the signature data, the account address, and\n * the key ID used for signing.\n *\n * @param addr Flow account address that created the signature (will be normalized with 0x prefix)\n * @param keyId The key ID/index used to create the signature (will be converted to number)\n * @param signature The cryptographic signature as a hexadecimal string\n *\n * @property f_type FCL type identifier, always \"CompositeSignature\"\n * @property f_vsn FCL version identifier for the signature format\n * @property addr Flow account address with 0x prefix\n * @property keyId Key ID used for signing (as number)\n * @property signature Signature data as hex string\n *\n * @example\n * // Create a composite signature for transaction signing\n * import { CompositeSignature } from \"@onflow/fcl\"\n *\n * const compSig = new CompositeSignature(\n *   \"1234567890abcdef\", // will be normalized to \"0x1234567890abcdef\"\n *   0,                  // key ID\n *   \"abc123def456...\"   // signature hex string\n * )\n *\n * console.log(compSig)\n * // {\n * //   f_type: \"CompositeSignature\",\n * //   f_vsn: \"1.0.0\",\n * //   addr: \"0x1234567890abcdef\",\n * //   keyId: 0,\n * //   signature: \"abc123def456...\"\n * // }\n */\nexport class CompositeSignature {\n  f_type: string\n  f_vsn: string\n  addr: string\n  keyId: number\n  signature: string\n\n  constructor(addr: string, keyId: number | string, signature: string) {\n    this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type\n    this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn\n    this.addr = withPrefix(addr)\n    this.keyId = Number(keyId)\n    this.signature = signature\n  }\n}\n","import type {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Injects an external authentication service into the global FCL extensions array.\n * This function is used by wallet providers to register their authentication services with FCL,\n * making them available for user authentication. The service must be of type \"authn\" and have\n * a valid endpoint.\n *\n * @param service The authentication service to inject. Must have type \"authn\" and a valid endpoint\n *\n * @example\n * // Register a wallet authentication service\n * const walletService = {\n *   type: \"authn\",\n *   endpoint: \"https://example-wallet.com/fcl/authn\",\n *   method: \"HTTP/POST\",\n *   identity: { address: \"0x123...\" },\n *   provider: { name: \"Example Wallet\" }\n * }\n * fcl.WalletUtils.injectExtService(walletService)\n */\nexport function injectExtService(service: Service): void {\n  if (service.type === \"authn\" && service.endpoint != null) {\n    if (!Array.isArray((window as any).fcl_extensions)) {\n      ;(window as any).fcl_extensions = []\n    }\n    ;(window as any).fcl_extensions.push(service)\n  } else {\n    console.warn(\"Authn service is required\")\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {withPrefix, sansPrefix} from \"@onflow/util-address\"\nimport {createQuery} from \"../exec/query\"\nimport {encodeAccountProof} from \"../wallet-utils\"\nimport {isString} from \"../utils/is\"\nimport {CompositeSignature} from \"@onflow/typedefs\"\nimport {createGetChainId} from \"../utils\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nexport interface AccountProofData {\n  address: string\n  nonce: string\n  signatures: CompositeSignature[]\n}\n\nexport interface VerifySignaturesScriptOptions {\n  fclCryptoContract?: string\n}\n\nexport interface ValidateArgsInput {\n  appIdentifier?: string\n  address?: string\n  nonce?: string\n  signatures?: CompositeSignature[]\n  message?: string\n  compSigs?: CompositeSignature[]\n}\n\nconst ACCOUNT_PROOF = \"ACCOUNT_PROOF\"\nconst USER_SIGNATURE = \"USER_SIGNATURE\"\n\n/**\n * @description Validates input arguments for signature verification functions (both account proof and user signature verification).\n * This function performs comprehensive validation of parameters to ensure they meet the requirements for cryptographic\n * signature verification on the Flow blockchain. It handles two different validation scenarios: account proof validation\n * (when appIdentifier is provided) and user signature validation (when message is provided).\n *\n * @param args Object containing the arguments to validate. The validation behavior depends on which properties are present:\n * - For account proof validation: appIdentifier, address, nonce, and signatures are required\n * - For user signature validation: message, address, and compSigs are required\n * @param args.appIdentifier Optional unique identifier for the application (triggers account proof validation mode)\n * @param args.address Flow account address that should be exactly 16 characters (without 0x prefix)\n * @param args.nonce Hexadecimal string representing a cryptographic nonce (for account proof validation)\n * @param args.signatures Array of CompositeSignature objects for account proof validation\n * @param args.message Hexadecimal string representing the signed message (for user signature validation)\n * @param args.compSigs Array of CompositeSignature objects for user signature validation\n *\n * @returns Always returns true if validation passes, otherwise throws an error\n *\n * @throws Throws an invariant error if any validation check fails, with specific error messages for each validation failure\n *\n * @example\n * // Validate account proof arguments\n * const accountProofArgs = {\n *   appIdentifier: \"MyApp\",\n *   address: \"1234567890abcdef\",\n *   nonce: \"75f8587e5bd982ec9289c5be1f9426bd\",\n *   signatures: [{\n *     f_type: \"CompositeSignature\",\n *     f_vsn: \"1.0.0\",\n *     addr: \"0x1234567890abcdef\",\n *     keyId: 0,\n *     signature: \"abc123def456...\"\n *   }]\n * }\n *\n * const isValid = validateArgs(accountProofArgs) // Returns true or throws\n *\n * // Validate user signature arguments\n * const userSigArgs = {\n *   message: \"48656c6c6f20576f726c64\", // \"Hello World\" in hex\n *   address: \"1234567890abcdef\",\n *   compSigs: [{\n *     f_type: \"CompositeSignature\",\n *     f_vsn: \"1.0.0\",\n *     addr: \"0x1234567890abcdef\",\n *     keyId: 0,\n *     signature: \"def456abc123...\"\n *   }]\n * }\n *\n * const isValid = validateArgs(userSigArgs) // Returns true or throws\n */\nexport const validateArgs = (args: ValidateArgsInput): boolean => {\n  if (args.appIdentifier) {\n    const {appIdentifier, address, nonce, signatures} = args\n    invariant(\n      isString(appIdentifier),\n      \"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string\"\n    )\n    invariant(\n      isString(address) && sansPrefix(address!).length === 16,\n      \"verifyAccountProof({ address }) -- address must be a valid address\"\n    )\n    invariant(/^[0-9a-f]+$/i.test(nonce!), \"nonce must be a hex string\")\n    invariant(\n      Array.isArray(signatures) &&\n        signatures.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"),\n      \"Must include an Array of CompositeSignatures to verify\"\n    )\n    invariant(\n      signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]),\n      \"User signatures to be verified must be from a single account address\"\n    )\n    return true\n  } else {\n    const {message, address, compSigs} = args\n    invariant(\n      /^[0-9a-f]+$/i.test(message!),\n      \"Signed message must be a hex string\"\n    )\n    invariant(\n      isString(address) && sansPrefix(address!).length === 16,\n      \"verifyUserSignatures({ address }) -- address must be a valid address\"\n    )\n    invariant(\n      Array.isArray(compSigs) &&\n        compSigs.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"),\n      \"Must include an Array of CompositeSignatures to verify\"\n    )\n    invariant(\n      compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]),\n      \"User signatures to be verified must be from a single account address\"\n    )\n    return true\n  }\n}\n\n// TODO: pass in option for contract but we're connected to testnet\n// log address + network -> in sync?\nconst getVerifySignaturesScript = async (\n  context: Pick<FCLContext, \"config\" | \"sdk\">,\n  sig: string,\n  opts: VerifySignaturesScriptOptions\n): Promise<string> => {\n  const verifyFunction =\n    sig === \"ACCOUNT_PROOF\"\n      ? \"verifyAccountProofSignatures\"\n      : \"verifyUserSignatures\"\n\n  const network = await createGetChainId(context)(opts)\n\n  const contractAddresses: any = {\n    testnet: \"0x74daa6f9c7ef24b1\",\n    mainnet: \"0xb4b82a1c9d21d284\",\n    previewnet: \"0x40b5b8b2ce81ea4a\",\n  }\n  const fclCryptoContract = opts.fclCryptoContract || contractAddresses[network]\n\n  invariant(\n    fclCryptoContract as any,\n    `${verifyFunction}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${network}. Please manually specify the FCLCrypto contract address.`\n  )\n\n  return `\n      import FCLCrypto from ${fclCryptoContract}\n\n      access(all) fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `\n}\n\nexport function createVerifyAccountProof(\n  context: Pick<FCLContext, \"config\" | \"sdk\">\n) {\n  /**\n   * @description Verifies the authenticity of an account proof signature on the Flow blockchain.\n   * Account proofs are cryptographic signatures used to prove ownership of a Flow account without\n   * revealing private keys. This function validates that the provided signatures were indeed created\n   * by the private keys associated with the specified Flow account address.\n   *\n   * @param appIdentifier A unique identifier for your application. This is typically\n   * your app's name or domain and is included in the signed message to prevent replay attacks\n   * across different applications.\n   * @param accountProofData Object containing the account proof data to verify\n   * @param accountProofData.address The Flow account address that allegedly signed the proof\n   * @param accountProofData.nonce A random hexadecimal string (minimum 32 bytes, 64 hex chars)\n   * used to prevent replay attacks. Should be unique for each proof request.\n   * @param accountProofData.signatures Array of composite signatures to verify\n   * against the account's public keys\n   * @param opts Optional configuration parameters\n   * @param opts.fclCryptoContract Override address for the FCLCrypto contract if not using\n   * the default for the current network\n   *\n   * @returns Promise that resolves to true if all signatures are valid, false otherwise.\n   *\n   * @returns `true` if verified or `false`\n   *\n   * @example\n   * import * as fcl from \"@onflow/fcl\"\n   *\n   * const accountProofData = {\n   *   address: \"0x123\",\n   *   nonce: \"F0123\"\n   *   signatures: [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n   * }\n   *\n   * const isValid = await fcl.AppUtils.verifyAccountProof(\n   *   \"AwesomeAppId\",\n   *   accountProofData,\n   *   {fclCryptoContract}\n   * )\n   */\n  async function verifyAccountProof(\n    appIdentifier: string,\n    {address, nonce, signatures}: AccountProofData,\n    opts: VerifySignaturesScriptOptions = {}\n  ): Promise<boolean> {\n    validateArgs({appIdentifier, address, nonce, signatures})\n    const message = encodeAccountProof({address, nonce, appIdentifier}, false)\n\n    const signaturesArr: string[] = []\n    const keyIndices: string[] = []\n\n    for (const el of signatures) {\n      signaturesArr.push(el.signature)\n      keyIndices.push(el.keyId.toString())\n    }\n\n    return createQuery(context)({\n      cadence: await getVerifySignaturesScript(context, ACCOUNT_PROOF, opts),\n      args: (arg: any, t: any) => [\n        arg(withPrefix(address), t.Address),\n        arg(message, t.String),\n        arg(keyIndices, t.Array(t.Int)),\n        arg(signaturesArr, t.Array(t.String)),\n      ],\n    })\n  }\n\n  return verifyAccountProof\n}\n\nexport function createVerifyUserSignatures(\n  context: Pick<FCLContext, \"config\" | \"sdk\">\n) {\n  /**\n   * @description Verifies user signatures for arbitrary messages on the Flow blockchain. This function\n   * validates that the provided signatures were created by the private keys associated with the specified\n   * Flow account when signing the given message. This is useful for authenticating users or validating\n   * signed data outside of transaction contexts.\n   *\n   * @param message The message that was signed, encoded as a hexadecimal string. The original\n   * message should be converted to hex before passing to this function.\n   * @param compSigs Array of composite signatures to verify. All signatures\n   * must be from the same account address.\n   * @param compSigs[].f_type Must be \"CompositeSignature\"\n   * @param compSigs[].f_vsn Must be \"1.0.0\"\n   * @param compSigs[].addr The Flow account address that created the signature\n   * @param compSigs[].keyId The key ID used to create the signature\n   * @param compSigs[].signature The actual signature data\n   * @param opts Optional configuration parameters\n   * @param opts.fclCryptoContract Override address for the FCLCrypto contract\n   *\n   * @returns Promise that resolves to true if all signatures are valid, false otherwise\n   *\n   * @throws If parameters are invalid, signatures are from different accounts, or network issues occur\n   *\n   * @example\n   * // Basic message signature verification\n   * import * as fcl from \"@onflow/fcl\"\n   *\n   * const originalMessage = \"Hello, Flow blockchain!\"\n   * const hexMessage = Buffer.from(originalMessage).toString(\"hex\")\n   *\n   * const signatures = [{\n   *   f_type: \"CompositeSignature\",\n   *   f_vsn: \"1.0.0\",\n   *   addr: \"0x1234567890abcdef\",\n   *   keyId: 0,\n   *   signature: \"abc123def456...\" // signature from user's wallet\n   * }]\n   *\n   * const isValid = await fcl.AppUtils.verifyUserSignatures(\n   *   hexMessage,\n   *   signatures\n   * )\n   */\n  async function verifyUserSignatures(\n    message: string,\n    compSigs: CompositeSignature[],\n    opts: VerifySignaturesScriptOptions = {}\n  ): Promise<boolean> {\n    const address = withPrefix(compSigs[0].addr)\n    validateArgs({message, address, compSigs})\n\n    const signaturesArr: string[] = []\n    const keyIndices: string[] = []\n\n    for (const el of compSigs) {\n      signaturesArr.push(el.signature)\n      keyIndices.push(el.keyId.toString())\n    }\n\n    return createQuery(context)({\n      cadence: await getVerifySignaturesScript(context, USER_SIGNATURE, opts),\n      args: (arg, t) => [\n        arg(address, t.Address),\n        arg(message, t.String),\n        arg(keyIndices, t.Array(t.Int)),\n        arg(signaturesArr, t.Array(t.String)),\n      ],\n    })\n  }\n\n  return verifyUserSignatures\n}\n\nexport const verifyAccountProof = /* @__PURE__ */ createVerifyAccountProof(\n  createPartialGlobalFCLContext()\n)\nexport const verifyUserSignatures = /* @__PURE__ */ createVerifyUserSignatures(\n  createPartialGlobalFCLContext()\n)\n","import {log} from \"@onflow/util-logger\"\nimport {verifyUserSignatures as verify} from \"../app-utils\"\n\n/**\n * @description Verify a valid signature/s for an account on Flow.\n * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead\n */\nexport const verifyUserSignatures = log.deprecate({\n  pkg: \"FCL\",\n  subject: \"fcl.verifyUserSignatures()\",\n  message: \"Please use fcl.AppUtils.verifyUserSignatures()\",\n  callback: function verifyUserSignatures(message: any, compSigs: any) {\n    return verify(message, compSigs)\n  },\n})\n","import {\n  createSignableVoucher,\n  interaction,\n  InteractionBuilderFn,\n  pipe,\n} from \"@onflow/sdk\"\nimport {Interaction} from \"@onflow/typedefs\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nexport interface SerializeOptions {\n  resolve?: InteractionBuilderFn\n}\n\n/**\n * @description Serializes a Flow transaction or script to a JSON-formatted signable voucher that can be\n * used for offline signing or inspection. This is useful for creating signable transactions that can be\n * signed by external wallets or hardware devices.\n *\n * @param args Array of interaction builder functions or a pre-built interaction object. Builder functions are typically from @onflow/sdk such as\n * transaction(), script(), args(), proposer(), etc.\n * @param opts Optional configuration object\n * @param opts.resolve Custom resolve function to use instead of the default\n *\n * @returns A JSON string representation of the signable voucher that contains all\n * the transaction details needed for signing\n *\n * @example\n * // Serialize a simple transaction\n * import * as fcl from \"@onflow/fcl\"\n *\n * const voucher = await fcl.serialize([\n *   fcl.transaction`\n *     transaction(amount: UFix64, to: Address) {\n *       prepare(signer: AuthAccount) {\n *         // Transaction logic here\n *       }\n *     }\n *   `,\n *   fcl.args([\n *     fcl.arg(\"10.0\", fcl.t.UFix64),\n *     fcl.arg(\"0x01\", fcl.t.Address)\n *   ]),\n *   fcl.proposer(authz),\n *   fcl.payer(authz),\n *   fcl.authorizations([authz])\n * ])\n */\nexport function createSerialize(context: Pick<FCLContext, \"config\" | \"sdk\">) {\n  const serialize = async (\n    args: (InteractionBuilderFn | false)[] | Interaction,\n    opts: SerializeOptions = {}\n  ) => {\n    const resolveFunction = opts.resolve || context.sdk.resolve\n\n    if (Array.isArray(args)) args = await pipe(interaction(), args)\n\n    return JSON.stringify(\n      createSignableVoucher(await resolveFunction(args)),\n      null,\n      2\n    )\n  }\n\n  return serialize\n}\n\nexport const serialize = /* @__PURE__ */ createSerialize(\n  createPartialGlobalFCLContext()\n)\n","import {FvmErrorCode} from \"@onflow/typedefs\"\n\nconst ERROR_CODE_REGEX = /\\[Error Code: (\\d+)\\]/\n\nexport class TransactionError extends Error {\n  public code: FvmErrorCode\n  public type: string\n\n  private constructor(message: string, code: FvmErrorCode) {\n    super(message)\n    this.code = code\n    this.type = FvmErrorCode[code]\n  }\n\n  static fromErrorMessage(errorMessage: string): TransactionError {\n    const match = errorMessage.match(ERROR_CODE_REGEX)\n    const code = match ? parseInt(match[1], 10) : undefined\n\n    return new TransactionError(\n      errorMessage,\n      code || FvmErrorCode.UNKNOWN_ERROR\n    )\n  }\n}\n","import {FCLContext} from \"./context\"\n\n/**\n * @description Extracts configuration values that match a given regular expression pattern from the Flow configuration.\n * This utility function filters the configuration entries using the provided regex pattern and returns a simplified\n * object with the matching keys (with the regex pattern removed) and their corresponding values.\n *\n * @param regex Regular expression pattern to filter configuration keys. The matched portion will be removed from the resulting keys\n * @returns Promise that resolves to an object containing the filtered configuration entries with simplified keys\n *\n * @example\n * // Extract all configuration keys starting with \"accessNode\"\n * const accessNodeConfig = await configLens(/^accessNode\\./)\n * // If config has \"accessNode.api\" = \"https://rest-mainnet.onflow.org\"\n * // Result: { \"api\": \"https://rest-mainnet.onflow.org\" }\n *\n * // Extract wallet-related configuration\n * const walletConfig = await configLens(/^wallet\\./)\n * // Filters keys like \"wallet.discovery.api\" and returns simplified object\n */\nexport async function configLens(\n  context: Pick<FCLContext, \"config\">,\n  regex: RegExp\n): Promise<Record<string, any>> {\n  return Object.fromEntries(\n    Object.entries(await context.config.where(regex)).map(([key, value]) => [\n      key.replace(regex, \"\"),\n      value,\n    ])\n  )\n}\n","import {TransactionStatus} from \"@onflow/typedefs\"\n\n/**\n * @description Checks if a transaction has expired based on its status code.\n * A transaction is considered expired when its status equals 5.\n *\n * @param tx The transaction status object to check\n * @returns True if the transaction has expired, false otherwise\n *\n * @example\n * // Check if a transaction has expired\n * const txStatus = await fcl.tx(transactionId).snapshot()\n * if (isExpired(txStatus)) {\n *   console.log(\"Transaction has expired\")\n * }\n */\nexport const isExpired = (tx: TransactionStatus) => tx.status === 5\n\n/**\n * @description Checks if a transaction has been sealed. A transaction is sealed when it has been\n * included in a block and finalized on the blockchain (status >= 4).\n *\n * @param tx The transaction status object to check\n * @returns True if the transaction is sealed, false otherwise\n *\n * @example\n * // Wait for transaction to be sealed\n * const txStatus = await fcl.tx(transactionId).snapshot()\n * if (isSealed(txStatus)) {\n *   console.log(\"Transaction is sealed and finalized\")\n * }\n */\nexport const isSealed = (tx: TransactionStatus) => tx.status >= 4\n\n/**\n * @description Checks if a transaction has been executed. A transaction is executed when it has\n * been processed by the blockchain network (status >= 3).\n *\n * @param tx The transaction status object to check\n * @returns True if the transaction has been executed, false otherwise\n *\n * @example\n * // Check if transaction has been executed\n * const txStatus = await fcl.tx(transactionId).snapshot()\n * if (isExecuted(txStatus)) {\n *   console.log(\"Transaction has been executed\")\n * }\n */\nexport const isExecuted = (tx: TransactionStatus) => tx.status >= 3\n\n/**\n * @description Checks if a transaction has been finalized. A transaction is finalized when it has\n * been included in a block (status >= 2).\n *\n * @param tx The transaction status object to check\n * @returns True if the transaction has been finalized, false otherwise\n *\n * @example\n * // Check if transaction has been finalized\n * const txStatus = await fcl.tx(transactionId).snapshot()\n * if (isFinalized(txStatus)) {\n *   console.log(\"Transaction has been finalized\")\n * }\n */\nexport const isFinalized = (tx: TransactionStatus) => tx.status >= 2\n\n/**\n * @description Checks if a transaction is pending. A transaction is pending when it has been\n * submitted to the network but not yet processed (status >= 1).\n *\n * @param tx The transaction status object to check\n * @returns True if the transaction is pending, false otherwise\n *\n * @example\n * // Check if transaction is still pending\n * const txStatus = await fcl.tx(transactionId).snapshot()\n * if (isPending(txStatus)) {\n *   console.log(\"Transaction is still pending\")\n * }\n */\nexport const isPending = (tx: TransactionStatus) => tx.status >= 1\n\n/**\n * @description Checks if a transaction status is unknown. A transaction has unknown status when\n * it hasn't been processed yet or there's no information available (status >= 0).\n *\n * @param tx The transaction status object to check\n * @returns True if the transaction status is unknown, false otherwise\n *\n * @example\n * // Check if transaction status is unknown\n * const txStatus = await fcl.tx(transactionId).snapshot()\n * if (isUnknown(txStatus)) {\n *   console.log(\"Transaction status is unknown\")\n * }\n */\nexport const isUnknown = (tx: TransactionStatus) => tx.status >= 0\n\n/**\n * @description Performs a deep equality comparison between two values. This function recursively\n * compares all properties of objects and arrays to determine if they are equal.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @returns True if the values are deeply equal, false otherwise\n *\n * @example\n * // Compare two objects\n * const obj1 = { name: \"Flow\", version: \"1.0\" }\n * const obj2 = { name: \"Flow\", version: \"1.0\" }\n * console.log(deepEqual(obj1, obj2)) // true\n */\nexport const deepEqual = (a: any, b: any): boolean => {\n  if (a === b) return true\n  if (typeof a !== \"object\" || typeof b !== \"object\") return false\n  if (Object.keys(a).length !== Object.keys(b).length) return false\n  for (const key in a) if (!deepEqual(a[key], b[key])) return false\n  return true\n}\n\n/**\n * @description Checks if two values are different by performing a deep equality comparison.\n * This is the inverse of the deepEqual function.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @returns True if the values are different, false if they are equal\n *\n * @example\n * // Check if objects are different\n * const obj1 = { name: \"Flow\", version: \"1.0\" }\n * const obj2 = { name: \"Flow\", version: \"2.0\" }\n * console.log(isDiff(obj1, obj2)) // true\n */\nexport const isDiff = (a: any, b: any): boolean => {\n  return !deepEqual(a, b)\n}\n\n/**\n * @description Extracts a transaction ID from either a string or an object containing a transactionId property.\n * This utility function handles both formats and ensures a valid transaction ID is returned.\n *\n * @param transactionId Either a transaction ID string or an object with a transactionId property\n * @returns The transaction ID as a string\n * @throws If transactionId is null, undefined, or invalid\n *\n * @example\n * // Extract from string\n * const txId = scoped(\"abc123def456\")\n * console.log(txId) // \"abc123def456\"\n */\nexport const scoped = (\n  transactionId:\n    | string\n    | {\n        transactionId: string\n      }\n) => {\n  if (typeof transactionId === \"object\")\n    transactionId = transactionId.transactionId\n  if (transactionId == null) throw new Error(\"transactionId required\")\n  return transactionId\n}\n","export const TXID_REGEXP = /^[0-9a-fA-F]{64}$/\n","import \"../default-config\"\nimport {\n  spawn,\n  subscriber,\n  snapshoter,\n  UPDATED,\n  SNAPSHOT,\n  INIT,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n} from \"@onflow/util-actor\"\nimport {send as fclSend, decode, getTransactionStatus} from \"@onflow/sdk\"\nimport {HTTPRequestError} from \"@onflow/transport-http\"\nimport {grpc} from \"@improbable-eng/grpc-web\"\nimport {TransactionError} from \"./transaction-error\"\nimport {\n  scoped,\n  isDiff,\n  isUnknown,\n  isPending,\n  isFinalized,\n  isExecuted,\n  isSealed,\n  isExpired,\n} from \"./utils\"\nimport {TXID_REGEXP} from \"./constants\"\n\nconst POLL = \"POLL\"\nconst TIMEOUT = \"TIMEOUT\"\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Transaction} Transaction\n */\n\n/**\n * @typedef {import(\"@onflow/typedefs\").TransactionStatus} TransactionStatus\n */\n\nconst fetchTxStatus = async transactionId => {\n  return fclSend([getTransactionStatus(transactionId)]).then(decode)\n}\n\nconst makeHandlers = (opts = {}) => ({\n  [INIT]: async ctx => {\n    setTimeout(() => ctx.sendSelf(TIMEOUT), opts.txNotFoundTimeout)\n    ctx.sendSelf(POLL)\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, ctx.all())\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply(ctx.all())\n  },\n  [TIMEOUT]: async ctx => {\n    // If status is still unknown, send a timeout error\n    if (Object.keys(ctx.all()).length === 0) {\n      ctx.fatalError(\n        new Error(\n          `TX status polling failed: no transaction was found within timeout interval (${opts.txNotFoundTimeout}ms)`\n        )\n      )\n    }\n  },\n  [POLL]: async ctx => {\n    // Helper to queue another poll\n    const poll = () => setTimeout(() => ctx.sendSelf(POLL), opts.pollRate)\n\n    let tx\n    const prevTx = ctx.all()\n    try {\n      tx = await fetchTxStatus(ctx.self())\n    } catch (e) {\n      const isHttpNotFound =\n        e instanceof HTTPRequestError && e.statusCode === 404\n      const isGrpcNotFound = e.code === grpc.Code.NotFound\n\n      // If TX is not found, suppress error and poll again\n      if (isHttpNotFound || isGrpcNotFound) {\n        return poll()\n      }\n\n      return ctx.fatalError(e)\n    }\n\n    if (!isSealed(tx)) poll()\n    if (isDiff(prevTx, tx)) ctx.broadcast(UPDATED, tx)\n    ctx.merge(tx)\n  },\n})\n\nconst spawnTransaction =\n  (opts = {}) =>\n  transactionId => {\n    return spawn(makeHandlers(opts), scoped(transactionId))\n  }\n\n/**\n * Provides methods for interacting with a transaction\n *\n * @param {string} transactionId - The transaction ID\n * @param {object} [opts] - Optional parameters\n * @param {number} [opts.pollRate=1000] - Polling rate in milliseconds\n * @param {number} [opts.txNotFoundTimeout=12500] - Timeout in milliseconds for ignoring transaction not found errors (do not modify unless you know what you are doing)\n * @returns {{\n *    snapshot: function(): Promise<TransactionStatus>,\n *    subscribe: function(SubscriptionCallback): function(): void,\n *    onceFinalized: function(): Promise<TransactionStatus>,\n *    onceExecuted: function(): Promise<TransactionStatus>,\n *    onceSealed: function(): Promise<TransactionStatus>\n * }}\n * @throws {Error} If transactionId is not a 64 byte hash string\n */\nexport function transaction(\n  transactionId,\n  opts = {txNotFoundTimeout: 12500, pollRate: 1000}\n) {\n  // Validate transactionId as 64 byte hash\n  if (!TXID_REGEXP.test(scoped(transactionId)))\n    throw new Error(\"Invalid transactionId\")\n\n  function snapshot() {\n    return snapshoter(transactionId, spawnTransaction(opts))\n  }\n\n  function subscribe(callback) {\n    return subscriber(scoped(transactionId), spawnTransaction(opts), callback)\n  }\n\n  function once(predicate) {\n    return function innerOnce(opts = {}) {\n      const suppress = opts.suppress || false\n      return new Promise((resolve, reject) => {\n        const unsub = subscribe((txStatus, error) => {\n          if ((error || txStatus.statusCode) && !suppress) {\n            if (error != null) {\n              reject(error)\n              unsub()\n            } else if (txStatus.statusCode === 1) {\n              const transactionError = TransactionError.fromErrorMessage(\n                txStatus.errorMessage\n              )\n              reject(transactionError)\n              unsub()\n            }\n            return\n          }\n\n          if (predicate(txStatus)) {\n            resolve(txStatus)\n            unsub()\n          }\n        })\n      })\n    }\n  }\n\n  return {\n    snapshot,\n    subscribe,\n    onceFinalized: once(isFinalized),\n    onceExecuted: once(isExecuted),\n    onceSealed: once(isSealed),\n  }\n}\n\ntransaction.isUnknown = isUnknown\ntransaction.isPending = isPending\ntransaction.isFinalized = isFinalized\ntransaction.isExecuted = isExecuted\ntransaction.isSealed = isSealed\ntransaction.isExpired = isExpired\n\nexport {TransactionError}\n","import \"../default-config\"\nimport {\n  SubscriptionTopic,\n  TransactionExecutionStatus,\n  TransactionStatus,\n} from \"@onflow/typedefs\"\nimport {\n  isDiff,\n  isExecuted,\n  isExpired,\n  isFinalized,\n  isPending,\n  isSealed,\n  scoped,\n} from \"./utils\"\nimport {TXID_REGEXP} from \"./constants\"\nimport {isUnknown, SubscriptionsNotSupportedError} from \"@onflow/sdk\"\nimport {TransactionError} from \"./transaction-error\"\nimport {transaction as legacyTransaction} from \"./legacy-polling\"\nimport {createGetChainId} from \"../utils\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nconst FLOW_EMULATOR = \"local\"\n\n// Map of transaction observables\n// Used for shared global singleton to prevent duplicate subscriptions\nconst registry = new Map<string, ReturnType<typeof createObservable>>()\n\nexport function createTransaction(context: Pick<FCLContext, \"sdk\" | \"config\">) {\n  /**\n   * @description Creates a transaction monitor that provides methods for tracking and subscribing to\n   * transaction status updates on the Flow blockchain. This function returns an object with methods\n   * to get snapshots, subscribe to status changes, and wait for specific transaction states.\n   *\n   * @param transactionId The 64-character hex transaction ID to monitor. Must be a valid\n   * Flow transaction hash (64 bytes represented as hex string).\n   * @param opts Optional configuration parameters\n   * @param opts.pollRate Polling rate in milliseconds when using legacy polling fallback\n   * @param opts.txNotFoundTimeout Timeout in milliseconds for ignoring transaction\n   * not found errors during initial transaction propagation (do not modify unless you know what you are doing)\n   *\n   * @returns Transaction monitor object with methods for tracking transaction status\n   *\n   * @throws If transactionId is not a valid 64-byte hash string\n   *\n   * @example\n   * // Basic transaction monitoring\n   * import * as fcl from \"@onflow/fcl\"\n   *\n   * const txId = await fcl.mutate({\n   *   cadence: `\n   *     transaction {\n   *       execute { log(\"Hello, World!\") }\n   *     }\n   *   `\n   * })\n   *\n   * // Get current status\n   * const status = await fcl.tx(txId).snapshot()\n   * console.log(\"Current status:\", status.status)\n   *\n   * // Subscribe to all status changes\n   * const unsubscribe = fcl.tx(txId).subscribe((status) => {\n   *   console.log(\"Status update:\", status.status)\n   *   if (status.status === fcl.transaction.isSealed) {\n   *     console.log(\"Transaction sealed!\")\n   *     console.log(\"Events:\", status.events)\n   *   }\n   * })\n   * // Clean up subscription when done\n   * setTimeout(() => unsubscribe(), 60000)\n   *\n   * // Wait for specific transaction states\n   * try {\n   *   // Wait for finalization (consensus reached)\n   *   const finalizedStatus = await fcl.tx(txId).onceFinalized()\n   *   console.log(\"Transaction finalized\")\n   *\n   *   // Wait for execution (transaction executed)\n   *   const executedStatus = await fcl.tx(txId).onceExecuted()\n   *   console.log(\"Transaction executed\")\n   *\n   *   // Wait for sealing (transaction sealed in block)\n   *   const sealedStatus = await fcl.tx(txId).onceSealed()\n   *   console.log(\"Transaction sealed:\", sealedStatus.events)\n   * } catch (error) {\n   *   console.error(\"Transaction failed:\", error.message)\n   * }\n   *\n   * // Handle transaction errors\n   * fcl.tx(txId).subscribe(\n   *   (status) => {\n   *     if (status.statusCode === 1) {\n   *       console.error(\"Transaction error:\", status.errorMessage)\n   *     }\n   *   },\n   *   (error) => {\n   *     console.error(\"Subscription error:\", error)\n   *   }\n   * )\n   */\n  function transaction(\n    transactionId: string,\n    opts: {\n      pollRate?: number\n      txNotFoundTimeout?: number\n    } = {txNotFoundTimeout: 12500, pollRate: 1000}\n  ): {\n    snapshot: () => Promise<TransactionStatus>\n    subscribe: (\n      onData: (txStatus: TransactionStatus) => void,\n      onError?: (err: Error) => void\n    ) => () => void\n    onceFinalized: () => Promise<TransactionStatus>\n    onceExecuted: () => Promise<TransactionStatus>\n    onceSealed: () => Promise<TransactionStatus>\n  } {\n    // Validate transactionId as 64 byte hash\n    if (!TXID_REGEXP.test(scoped(transactionId)))\n      throw new Error(\"Invalid transactionId\")\n\n    function getObservable() {\n      let observable = registry.get(transactionId)\n      if (!observable) {\n        observable = createObservable(context, transactionId, opts)\n        registry.set(transactionId, observable)\n      }\n      return observable\n    }\n\n    function snapshot() {\n      return Promise.resolve(getObservable().value)\n    }\n\n    function subscribe(\n      onData: (txStatus: TransactionStatus) => void,\n      onError?: (err: Error) => void\n    ) {\n      const observable = getObservable()\n      const {unsubscribe} = observable.subscribe(onData, onError)\n      return () => unsubscribe()\n    }\n\n    function once(predicate: (txStatus: TransactionStatus) => boolean) {\n      return function innerOnce(opts = {suppress: false}) {\n        const suppress = opts.suppress || false\n        return new Promise((resolve, reject) => {\n          const unsub = subscribe(\n            (txStatus: TransactionStatus) => {\n              if (txStatus.statusCode === 1) {\n                const transactionError = TransactionError.fromErrorMessage(\n                  txStatus.errorMessage\n                )\n                reject(transactionError)\n                unsub()\n              } else if (predicate(txStatus)) {\n                resolve(txStatus)\n                unsub()\n              }\n            },\n            err => {\n              if (!suppress) {\n                reject(err)\n                unsub()\n              }\n            }\n          )\n        }) as Promise<TransactionStatus>\n      }\n    }\n\n    return {\n      snapshot,\n      subscribe,\n      onceFinalized: once(isFinalized),\n      onceExecuted: once(isExecuted),\n      onceSealed: once(isSealed),\n    }\n  }\n\n  transaction.isUnknown = isUnknown\n  transaction.isPending = isPending\n  transaction.isFinalized = isFinalized\n  transaction.isExecuted = isExecuted\n  transaction.isSealed = isSealed\n  transaction.isExpired = isExpired\n\n  return transaction\n}\n\nexport const transaction = /* @__PURE__ */ createTransaction(\n  createPartialGlobalFCLContext()\n)\n\n/**\n * @description Creates an observable for a transaction\n */\nfunction createObservable(\n  context: Pick<FCLContext, \"sdk\" | \"config\">,\n  txId: string,\n  opts: {pollRate?: number; txNotFoundTimeout?: number}\n) {\n  const observers = new Set<{\n    onData: (txStatus: TransactionStatus) => void\n    onError: (err: Error) => void\n  }>()\n  let value: TransactionStatus = {\n    blockId: \"\",\n    status: TransactionExecutionStatus.UNKNOWN,\n    statusCode: 0,\n    errorMessage: \"\",\n    events: [],\n    statusString: \"\",\n  }\n\n  // Initialize the subscription\n  init().catch(error)\n\n  async function init() {\n    const flowNetwork = await createGetChainId(context)()\n\n    // As of Flow CLI v2.2.8, WebSocket subscriptions are not supported on the Flow emulator\n    // This conditional will be removed when WebSocket subscriptions are supported in this environment\n    if (flowNetwork === FLOW_EMULATOR) {\n      console.warn(\n        \"Events are not supported on the Flow emulator, falling back to legacy polling.\"\n      )\n      fallbackLegacyPolling()\n    } else {\n      subscribeTransactionStatuses()\n    }\n  }\n\n  // Subscribe to transaction status updates\n  function subscribeTransactionStatuses() {\n    // Subscribe to transaction status updates\n    const subscription = context.sdk.subscribe({\n      topic: SubscriptionTopic.TRANSACTION_STATUSES,\n      args: {transactionId: txId},\n      onData: txStatus => {\n        if (isDiff(value, txStatus)) {\n          value = txStatus\n          next(txStatus)\n        }\n\n        // Clean up the subscription if the transaction is sealed\n        // Wait for next tick to ensure unsubscribe is defined\n        if (isSealed(txStatus)) {\n          new Promise(resolve => setTimeout(resolve, 0)).then(() => {\n            if (isSealed(txStatus)) {\n              subscription.unsubscribe()\n            }\n          })\n        }\n      },\n      onError: (err: Error) => {\n        if (err instanceof SubscriptionsNotSupportedError) {\n          console.warn(\n            \"Failed to subscribe to transaction status updates using real-time streaming (are you using the deprecated GRPC transport?), falling back to polling.\"\n          )\n          fallbackLegacyPolling()\n        } else {\n          error(err)\n        }\n      },\n    })\n  }\n\n  function fallbackLegacyPolling() {\n    // Poll for transaction status updates\n    const unsubscribe = legacyTransaction(txId, opts).subscribe(\n      (txStatus?: TransactionStatus, err?: Error) => {\n        if (err) {\n          error(err)\n        } else if (txStatus && isDiff(value, txStatus)) {\n          value = txStatus\n          next(txStatus)\n\n          // Clean up the subscription if the transaction is sealed\n          // Wait for next tick to ensure unsubscribe is defined\n          if (isSealed(txStatus)) {\n            new Promise(resolve => setTimeout(resolve, 0)).then(() => {\n              unsubscribe()\n            })\n          }\n        }\n      }\n    )\n  }\n\n  function next(txStatus: TransactionStatus) {\n    for (const observer of observers) {\n      try {\n        observer.onData(txStatus)\n      } catch (error) {\n        console.error(\"Error in transaction observer\", error)\n      }\n    }\n  }\n\n  function error(err: Error) {\n    for (const observer of observers) {\n      try {\n        observer.onError(err)\n      } catch (error) {\n        console.error(\"Error in transaction observer\", error)\n      }\n    }\n  }\n\n  return {\n    subscribe(\n      onData: (status: TransactionStatus) => void,\n      onError?: (error: Error) => void\n    ) {\n      const observer = {\n        onData,\n        onError: onError || (() => {}),\n      }\n      observers.add(observer)\n      onData(value)\n\n      return {\n        unsubscribe: () => observers.delete(observer),\n      }\n    },\n    get value() {\n      return value\n    },\n  }\n}\n","import {getEventsAtBlockHeightRange} from \"@onflow/sdk\"\nimport type {Block, Event} from \"@onflow/typedefs\"\nimport {\n  ActorContext,\n  ActorHandlers,\n  Letter,\n  spawn,\n  SUBSCRIBE,\n  subscriber,\n  UNSUBSCRIBE,\n} from \"@onflow/util-actor\"\nimport {FCLContext} from \"../context\"\n\nexport interface SubscribeObject {\n  /**\n   * @description Subscribe to events\n   * @param callback The callback function\n   * @returns A function to unsubscribe\n   */\n  subscribe: (\n    callback: (data: Event | null, error: Error | null) => void\n  ) => () => void\n}\n\nconst RATE: number = 10000\nconst UPDATED: string = \"UPDATED\"\nconst TICK: string = \"TICK\"\nconst HIGH_WATER_MARK: string = \"hwm\"\n\nconst scheduleTick = async (\n  fclContext: Pick<FCLContext, \"sdk\" | \"config\">,\n  ctx: ActorContext\n): Promise<NodeJS.Timeout> => {\n  return setTimeout(\n    () => ctx.sendSelf(TICK),\n    await fclContext.config.get(\"fcl.eventPollRate\", RATE)\n  )\n}\n\nfunction createHandlers(\n  fclContext: Pick<FCLContext, \"sdk\" | \"config\">\n): ActorHandlers {\n  const HANDLERS: ActorHandlers = {\n    [TICK]: async (ctx: ActorContext): Promise<void> => {\n      if (!ctx.hasSubs()) return\n      let hwm: Block | null = ctx.get(HIGH_WATER_MARK)\n      if (hwm == null) {\n        ctx.put(HIGH_WATER_MARK, await fclContext.sdk.block())\n        ctx.put(TICK, await scheduleTick(fclContext, ctx))\n      } else {\n        let next: Block = await fclContext.sdk.block()\n        ctx.put(HIGH_WATER_MARK, next)\n        if (hwm.height < next.height) {\n          const data: Event[] = await fclContext.sdk\n            .send([\n              getEventsAtBlockHeightRange(\n                ctx.self(),\n                hwm.height + 1,\n                next.height\n              ),\n            ])\n            .then(fclContext.sdk.decode)\n          for (let d of data) ctx.broadcast(UPDATED, d)\n        }\n        ctx.put(TICK, await scheduleTick(fclContext, ctx))\n      }\n    },\n    [SUBSCRIBE]: async (ctx: ActorContext, letter: Letter): Promise<void> => {\n      if (!ctx.hasSubs()) {\n        ctx.put(TICK, await scheduleTick(fclContext, ctx))\n      }\n      ctx.subscribe(letter.from)\n    },\n    [UNSUBSCRIBE]: (ctx: ActorContext, letter: Letter): void => {\n      ctx.unsubscribe(letter.from)\n      if (!ctx.hasSubs()) {\n        clearTimeout(ctx.get(TICK))\n        ctx.delete(TICK)\n        ctx.delete(HIGH_WATER_MARK)\n      }\n    },\n  }\n\n  return HANDLERS\n}\n\nconst spawnEvents = (\n  fclContext: Pick<FCLContext, \"sdk\" | \"config\">,\n  key?: string\n) => spawn(createHandlers(fclContext), key)\n\nexport function createLegacyEvents(\n  context: Pick<FCLContext, \"sdk\" | \"config\">\n) {\n  /**\n   * @description Subscribe to events\n   * @param key A valid event name\n   * @returns An object with a subscribe method\n   *\n   * @example\n   * import * as fcl from \"@onflow/fcl\"\n   * fcl.events(eventName).subscribe((event) => console.log(event))\n   */\n  function legacyEvents(key: string): SubscribeObject {\n    return {\n      /**\n       * @description Subscribe to events\n       * @param {Function} callback The callback function\n       * @returns {SubscriptionCallback}\n       */\n      subscribe: callback =>\n        subscriber(key, address => spawnEvents(context, address), callback),\n    }\n  }\n\n  return legacyEvents\n}\n","import {Event, EventFilter, SubscriptionTopic} from \"@onflow/typedefs\"\nimport {createLegacyEvents} from \"./legacy-events\"\nimport {SubscriptionsNotSupportedError} from \"@onflow/sdk\"\nimport {createGetChainId} from \"../utils\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nconst FLOW_EMULATOR = \"local\"\n\nexport function createEvents(context: Pick<FCLContext, \"config\" | \"sdk\">) {\n  /**\n   * @description Subscribes to Flow blockchain events in real-time. This function provides a way to listen\n   * for specific events emitted by smart contracts on the Flow blockchain. It automatically handles\n   * fallback to legacy polling for environments that don't support WebSocket subscriptions.\n   *\n   * @param filterOrType Event filter object or event type string.\n   * If a string is provided, it will be treated as a single event type to subscribe to.\n   * If an EventFilter object is provided, it can contain multiple event types and other filter criteria.\n   * @param filterOrType.eventTypes Array of event type strings to subscribe to\n   * @param filterOrType.startBlockId Block ID to start streaming from\n   * @param filterOrType.startBlockHeight Block height to start streaming from\n   *\n   * @returns An object containing a subscribe method\n   * @returns returns.subscribe Function to start the subscription\n   * @returns returns.subscribe.onData Callback function called when an event is received\n   * @returns returns.subscribe.onError Optional callback function called when an error occurs\n   * @returns returns.subscribe.unsubscribe Function returned by subscribe() to stop the subscription\n   *\n   * @example\n   * // Subscribe to a specific event type\n   * import * as fcl from \"@onflow/fcl\"\n   *\n   * const unsubscribe = fcl.events(\"A.0x1654653399040a61.FlowToken.TokensWithdrawn\")\n   *   .subscribe((event) => {\n   *     console.log(\"Event received:\", event)\n   *     console.log(\"Event data:\", event.data)\n   *     console.log(\"Transaction ID:\", event.transactionId)\n   *   })\n   *\n   * // Stop listening after 30 seconds\n   * setTimeout(() => {\n   *   unsubscribe()\n   * }, 30000)\n   *\n   * // Subscribe to multiple event types with error handling\n   * const unsubscribe = fcl.events({\n   *   eventTypes: [\n   *     \"A.0x1654653399040a61.FlowToken.TokensWithdrawn\",\n   *     \"A.0x1654653399040a61.FlowToken.TokensDeposited\"\n   *   ]\n   * }).subscribe(\n   *   (event) => {\n   *     console.log(\"Token event:\", event.type, event.data)\n   *   },\n   *   (error) => {\n   *     console.error(\"Event subscription error:\", error)\n   *   }\n   * )\n   *\n   * // Subscribe to events starting from a specific block height\n   * const unsubscribe = fcl.events({\n   *   eventTypes: [\"A.CONTRACT.EVENT\"],\n   *   startBlockHeight: 12345678\n   * }).subscribe((event) => {\n   *   console.log(\"Historical and new events:\", event)\n   * })\n   */\n  function events(filterOrType?: EventFilter | string) {\n    let filter: EventFilter\n    if (typeof filterOrType === \"string\") {\n      filter = {eventTypes: [filterOrType]}\n    } else {\n      filter = filterOrType || {}\n    }\n\n    return {\n      subscribe: (\n        onData: (event: Event) => void,\n        onError: (error: Error) => void = (error: Error) => {\n          console.error(\"Unhandled error in event subscription:\", error)\n        }\n      ): (() => void) => {\n        let unsubscribeFn = () => {}\n        let unsubscribeFnLegacy = () => {}\n\n        // Subscribe to the event stream\n        function subscribeEventStream() {\n          const {unsubscribe} = context.sdk.subscribe({\n            topic: SubscriptionTopic.EVENTS,\n            args: filter,\n            onData: event => {\n              // Emit the event\n              onData(event)\n            },\n            onError: (error: Error) => {\n              // If subscriptions are not supported, fallback to legacy polling, otherwise return the error\n              if (error instanceof SubscriptionsNotSupportedError) {\n                console.warn(\n                  \"Failed to subscribe to events using real-time streaming (are you using the deprecated GRPC transport?), falling back to legacy polling.\"\n                )\n                fallbackLegacyPolling()\n              } else {\n                onError(error)\n              }\n            },\n          })\n          unsubscribeFn = unsubscribe\n        }\n\n        // Fallback to legacy polling if real-time streaming is not supported\n        function fallbackLegacyPolling() {\n          if (typeof filterOrType !== \"string\") {\n            throw new Error(\n              \"Legacy fcl.events fallback only supports string filters (single event type)\"\n            )\n          }\n          unsubscribeFnLegacy = createLegacyEvents(context)(\n            filterOrType\n          ).subscribe((event: Event | null, error: Error | null) => {\n            if (error) {\n              onError(error)\n            } else {\n              if (event) {\n                onData(event)\n              }\n            }\n          })\n        }\n\n        async function subscribeToEvents() {\n          const network = await createGetChainId(context)()\n\n          // As of Flow CLI v2.2.8, WebSocket subscriptions are not supported on the Flow emulator\n          // This conditional will be removed when WebSocket subscriptions are supported in this environment\n          if (network === FLOW_EMULATOR) {\n            console.warn(\n              \"Events are not supported on the Flow emulator, falling back to legacy polling.\"\n            )\n            fallbackLegacyPolling()\n          } else {\n            subscribeEventStream()\n          }\n        }\n\n        // Subscribe to events\n        const initPromise = subscribeToEvents().catch(error => {\n          onError(error)\n        })\n\n        // Return an unsubscribe function\n        return () => {\n          initPromise.finally(() => {\n            unsubscribeFn()\n            unsubscribeFnLegacy()\n          })\n        }\n      },\n    }\n  }\n\n  return events\n}\n\nexport const events = /*@__PURE__*/ createEvents(\n  createPartialGlobalFCLContext()\n)\n","import {invariant} from \"@onflow/util-invariant\"\nimport {LEVELS, log} from \"@onflow/util-logger\"\nimport {isRequired, isString, isObject, isFunc} from \"../../utils/is\"\nimport {CORE_STRATEGIES} from \"../../utils/constants\"\n\nconst stub = () => {\n  throw new Error(`Platform specific Core Strategies are not initialized`)\n}\n\nconst stubCoreStrategies = {\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"HTTP/POST\"]]: stub,\n  [CORE_STRATEGIES[\"IFRAME/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"POP/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"TAB/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub,\n}\n\nconst supportedPlugins = [\"ServicePlugin\"]\nconst supportedServicePlugins = [\"discovery-service\"]\n\nconst validateDiscoveryPlugin = (servicePlugin: any) => {\n  const {services = [], serviceStrategy} = servicePlugin\n  invariant(Array.isArray(services), \"Services must be an array\")\n\n  for (const ds of services) {\n    invariant(\n      isRequired(ds.f_type) && ds.f_type === \"Service\",\n      \"Service is required\"\n    )\n    invariant(\n      isRequired(ds.type) && ds.type === \"authn\",\n      `Service must be type authn. Received ${ds.type}`\n    )\n    invariant(\n      ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method,\n      `Service method ${ds.method} is not supported`\n    )\n  }\n\n  invariant(isRequired(serviceStrategy), \"Service strategy is required\")\n  invariant(\n    isRequired(serviceStrategy.method) && isString(serviceStrategy.method),\n    \"Service strategy method is required\"\n  )\n  invariant(\n    isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec),\n    \"Service strategy exec function is required\"\n  )\n\n  return {discoveryServices: services, serviceStrategy}\n}\n\nconst ServiceRegistry = ({coreStrategies}: {coreStrategies: any}) => {\n  let services = new Set()\n  let strategies = new Map(Object.entries(coreStrategies))\n\n  const add = (servicePlugin: any) => {\n    invariant(\n      supportedServicePlugins.includes(servicePlugin.type),\n      `Service Plugin type ${servicePlugin.type} is not supported`\n    )\n    if (servicePlugin.type === \"discovery-service\") {\n      const {discoveryServices, serviceStrategy} =\n        validateDiscoveryPlugin(servicePlugin)\n      setServices(discoveryServices)\n      if (!strategies.has(serviceStrategy.method)) {\n        strategies.set(serviceStrategy.method, serviceStrategy.exec)\n      } else {\n        log({\n          title: `Add Service Plugin`,\n          message: `Service strategy for ${serviceStrategy.method} already exists`,\n          level: LEVELS.warn,\n        })\n      }\n    }\n  }\n\n  const setServices = (discoveryServices: any) =>\n    (services = new Set([...discoveryServices]))\n\n  const getServices = () => [...services]\n\n  const getStrategy = (method: any) => strategies.get(method)\n\n  const getStrategies = () => [...strategies.keys()]\n\n  return Object.freeze({\n    add,\n    getServices,\n    getStrategy,\n    getStrategies,\n  })\n}\n\nconst validatePlugins = (plugins: any[]) => {\n  let pluginsArray\n  invariant(!!plugins, \"No plugins supplied\")\n\n  if (!Array.isArray(plugins)) {\n    pluginsArray = [plugins]\n  } else {\n    pluginsArray = [...plugins]\n  }\n  for (const p of pluginsArray) {\n    invariant(isRequired(p.name), \"Plugin name is required\")\n    invariant(isRequired(p.f_type), \"Plugin f_type is required\")\n    invariant(\n      supportedPlugins.includes(p.f_type),\n      `Plugin type ${p.f_type} is not supported`\n    )\n  }\n\n  return pluginsArray\n}\n\nconst PluginRegistry = () => {\n  const pluginsMap = new Map()\n\n  const getPlugins = () => pluginsMap\n\n  const add = (plugins: any) => {\n    const pluginsArray = validatePlugins(plugins)\n    for (const p of pluginsArray) {\n      pluginsMap.set(p.name, p)\n      if (p.f_type === \"ServicePlugin\") {\n        serviceRegistry.add(p)\n      }\n    }\n  }\n\n  return Object.freeze({\n    add,\n    getPlugins,\n  })\n}\n\nlet serviceRegistry: ReturnType<typeof ServiceRegistry>\nconst getIsServiceRegistryInitialized = () =>\n  typeof serviceRegistry !== \"undefined\"\n\n/**\n * @description Initializes the service registry with core strategies for different communication methods.\n * This function sets up the registry that manages wallet service strategies and should be called once\n * during FCL initialization with platform-specific core strategies.\n *\n * @param params Configuration object containing core strategies\n * @param params.coreStrategies Object mapping strategy names to their implementation functions\n * @returns The initialized service registry instance\n *\n * @example\n * // Initialize service registry with core strategies\n * const registry = initServiceRegistry({\n *   coreStrategies: {\n *     \"HTTP/POST\": httpPostStrategy,\n *     \"IFRAME/RPC\": iframeRpcStrategy,\n *     \"POP/RPC\": popupRpcStrategy\n *   }\n * })\n */\nexport const initServiceRegistry = ({\n  coreStrategies,\n}: {\n  coreStrategies: any\n}) => {\n  if (getIsServiceRegistryInitialized()) {\n    return serviceRegistry\n  }\n  const _serviceRegistry = ServiceRegistry({coreStrategies})\n  serviceRegistry = _serviceRegistry\n\n  return _serviceRegistry\n}\n\n/**\n * @description Gets the singleton service registry instance. If the registry hasn't been initialized,\n * it will be initialized with stub core strategies and a warning will be logged. This function\n * provides access to the registry for service and strategy management.\n *\n * @returns The service registry instance\n *\n * @example\n * // Get the service registry\n * const registry = getServiceRegistry()\n * const services = registry.getServices()\n * const strategy = registry.getStrategy(\"HTTP/POST\")\n */\nexport const getServiceRegistry = () => {\n  if (!getIsServiceRegistryInitialized()) {\n    console.warn(\n      \"Registry is not initalized, it will be initialized with stub core strategies\"\n    )\n\n    return initServiceRegistry({coreStrategies: stubCoreStrategies})\n  }\n\n  return serviceRegistry\n}\n\n/**\n * @description Global plugin registry instance for managing FCL plugins. This registry handles\n * the registration and management of various FCL plugins including service plugins that add\n * new wallet services and strategies.\n *\n * @example\n * // Add a plugin to the registry\n * pluginRegistry.add({\n *   name: \"MyWalletPlugin\",\n *   f_type: \"ServicePlugin\",\n *   type: \"discovery-service\",\n *   services: [...],\n *   serviceStrategy: { method: \"CUSTOM/RPC\", exec: customExecFunction }\n * })\n */\nexport const pluginRegistry = PluginRegistry()\n","import {config} from \"@onflow/config\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {getServiceRegistry} from \"../current-user/exec-service/plugins\"\nimport {Service} from \"@onflow/typedefs\"\nimport {FCLContext} from \"../context\"\n\nexport interface DiscoveryService extends Service {\n  discoveryAuthnInclude: string[]\n  discoveryAuthnExclude: string[]\n  discoveryFeaturesSuggested: string[]\n}\n\n/**\n * @description Creates an array of discovery services by combining extension services from the\n * window object with registered services from the service registry. This is used internally\n * by FCL to gather all available wallet and authentication services.\n *\n * @returns Promise that resolves to an array of available services\n *\n * @example\n * // Get all available discovery services\n * const services = await makeDiscoveryServices()\n * console.log(services.length) // Number of available services\n * services.forEach(service => {\n *   console.log(`Service: ${service.provider?.name}, Type: ${service.type}`)\n * })\n */\nexport const makeDiscoveryServices = async (): Promise<Service[]> => {\n  const extensionServices = ((window as any)?.fcl_extensions || []) as Service[]\n  return [\n    ...extensionServices,\n    ...(getServiceRegistry().getServices() as Service[]),\n  ]\n}\n\n/**\n * @description Creates and configures a discovery service object used for wallet authentication.\n * This function combines the provided service configuration with discovery-related settings from\n * the FCL configuration to create a complete service definition for wallet authentication flows.\n *\n * @param context FCL context containing configuration and SDK\n * @param service Optional partial service configuration to override defaults\n * @param service.method Optional communication method for the service\n * @param service.endpoint Optional endpoint URL for the service\n * @returns Promise that resolves to a complete discovery service configuration\n * @throws Error if required configuration values are missing\n *\n * @example\n * // Get discovery service with default configuration\n * const discoveryService = await getDiscoveryService(context)\n * console.log(discoveryService.endpoint) // Configured discovery endpoint\n *\n * // Override discovery service endpoint\n * const customService = await getDiscoveryService(context, {\n *   endpoint: \"https://wallet.example.com/authn\",\n *   method: \"HTTP/POST\"\n * })\n *\n * // Use with custom wallet service\n * const walletService = await getDiscoveryService(context, {\n *   endpoint: \"https://my-wallet.com/fcl\",\n *   provider: {\n *     name: \"My Wallet\",\n *     icon: \"https://my-wallet.com/icon.png\"\n *   }\n * })\n */\nexport async function getDiscoveryService(\n  context: Pick<FCLContext, \"config\">,\n  service?: Partial<Service>\n): Promise<DiscoveryService> {\n  const discoveryAuthnInclude = (await context.config.get(\n    \"discovery.authn.include\",\n    []\n  )) as string[]\n  const discoveryAuthnExclude = (await context.config.get(\n    \"discovery.authn.exclude\",\n    []\n  )) as string[]\n  const discoveryFeaturesSuggested = (await context.config.get(\n    \"discovery.features.suggested\",\n    []\n  )) as string[]\n  const discoveryWalletMethod = await context.config.first(\n    [\"discovery.wallet.method\", \"discovery.wallet.method.default\"],\n    undefined\n  )\n  const method = service?.method ? service.method : discoveryWalletMethod\n  const endpoint =\n    service?.endpoint ??\n    (await context.config.first(\n      [\"discovery.wallet\", \"challenge.handshake\"],\n      undefined\n    ))\n\n  invariant(\n    endpoint as any,\n    `\n    If no service is passed to \"authenticate,\" then \"discovery.wallet\" must be defined in fcl config.\n    See: \"https://docs.onflow.org/fcl/reference/api/#setting-configuration-values\"\n    `\n  )\n\n  return {\n    ...service,\n    type: \"authn\",\n    endpoint,\n    method,\n    discoveryAuthnInclude,\n    discoveryAuthnExclude,\n    discoveryFeaturesSuggested,\n  } as DiscoveryService\n}\n","let _isReactNative: boolean = false\n\n/**\n * @description Checks if the current environment is React Native. This function returns a boolean\n * indicating whether FCL is running in a React Native environment rather than a browser or Node.js.\n * This is useful for platform-specific functionality and enabling React Native-specific features.\n *\n * @returns True if running in React Native environment, false otherwise\n *\n * @example\n * // Check if running in React Native\n * import * as fcl from \"@onflow/fcl\"\n *\n * if (fcl.isReactNative()) {\n *   console.log(\"Running in React Native\")\n *   // Use React Native specific wallet integrations\n *   // Enable deep linking for wallet connections\n * } else {\n *   console.log(\"Running in browser or Node.js\")\n *   // Use web-based wallet integrations\n * }\n */\nexport function isReactNative(): boolean {\n  return _isReactNative\n}\n\n/**\n * @description Sets the React Native environment flag for FCL. This function should be called during\n * initialization of React Native applications to inform FCL that it's running in a React Native\n * environment. This enables React Native-specific behaviors and optimizations.\n *\n * @param value True to indicate React Native environment, false otherwise\n *\n * @example\n * // Set React Native flag during app initialization\n * import * as fcl from \"@onflow/fcl\"\n *\n * // In your React Native app's entry point (e.g., App.js)\n * fcl.setIsReactNative(true)\n *\n * // Configure FCL for React Native\n * fcl.config({\n *   \"accessNode.api\": \"https://rest-testnet.onflow.org\",\n *   \"discovery.wallet\": \"https://fcl-discovery.onflow.org/api/testnet/authn\"\n * })\n */\nexport function setIsReactNative(value: boolean): void {\n  _isReactNative = value\n}\n","// This is a workaround for an ongoing issue with URL in React Native\n// It does not parse the URL correctly and appends trailing slashes\n// See: https://github.com/facebook/react-native/issues/24428\n// See: https://github.com/facebook/react-native/issues/24428\n\n// The React Native team is aware of this issue but does not plan to fix it\n// since it could break existing apps, even though this is out of spec\n// See whatwg implementation: https://github.com/jsdom/whatwg-url/blob/master/lib/URL-impl.js#L6-L34\n// See react-native implementation: https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Blob/URL.js#L144-L146\n\n// This is not polyfilled globally because it could break other libraries or the user's code\nimport {isReactNative} from \"./is-react-native\"\n\nconst _URL = globalThis.URL\nexport class URL extends _URL {\n  private _url?: string\n\n  constructor(url: string | URL, base?: string | URL, ...args: any[]) {\n    super(url, base, ...(args as []))\n\n    // Extra check if in React Native\n    if (!isReactNative()) {\n      return\n    }\n\n    // Fix trailing slash issue\n    if (this._url && !url.toString().endsWith(\"/\") && this._url.endsWith(\"/\")) {\n      this._url = this._url.slice(0, -1)\n    }\n  }\n}\n","import {\n  spawn,\n  subscriber,\n  snapshoter,\n  INIT,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n  send,\n  Letter as ActorLetter,\n  ActorContext,\n} from \"@onflow/util-actor\"\nimport {getServices} from \"../services\"\nimport {LEVELS, log} from \"@onflow/util-logger\"\nimport {Service} from \"@onflow/typedefs\"\nimport {FCLContext} from \"../../context\"\nimport {createPartialGlobalFCLContext} from \"../../context/global\"\n\nexport const SERVICE_ACTOR_KEYS = {\n  AUTHN: \"authn\",\n  RESULTS: \"results\",\n  SNAPSHOT: \"SNAPSHOT\",\n  UPDATED: \"UPDATED\",\n  UPDATE_RESULTS: \"UPDATE_RESULTS\",\n} as const\n\nexport interface ServiceData {\n  results: Service[]\n}\n\nexport type SubscriptionCallback = (\n  data: Service[] | null,\n  error: Error | null\n) => void\n\nexport interface Authn {\n  subscribe: (cb: SubscriptionCallback) => () => void\n  snapshot: () => Promise<ServiceData>\n  update: () => void\n}\n\nconst warn = (fact: boolean, msg: string): void => {\n  if (fact) {\n    console.warn(\n      `\n      %cFCL Warning\n      ============================\n      ${msg}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `,\n      \"font-weight:bold;font-family:monospace;\"\n    )\n  }\n}\n\nconst fetchServicesFromDiscovery = async (\n  context: Pick<FCLContext, \"config\">\n): Promise<void> => {\n  try {\n    const services = await getServices({\n      context,\n      types: [SERVICE_ACTOR_KEYS.AUTHN],\n    })\n    send(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {\n      results: services,\n    })\n  } catch (error: any) {\n    log({\n      title: `${error.name} Error fetching Discovery API services.`,\n      message: error.message,\n      level: LEVELS.error,\n    })\n  }\n}\n\nfunction createHandlers(context: Pick<FCLContext, \"config\">) {\n  return {\n    [INIT]: async (ctx: ActorContext) => {\n      warn(\n        typeof window === \"undefined\",\n        '\"fcl.discovery\" is only available in the browser.'\n      )\n      // If you call this before the window is loaded extensions will not be set yet\n      if (document.readyState === \"complete\") {\n        fetchServicesFromDiscovery(context)\n      } else {\n        window.addEventListener(\"load\", () => {\n          fetchServicesFromDiscovery(context)\n        })\n      }\n    },\n    [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (\n      ctx: ActorContext,\n      _letter: ActorLetter,\n      data: ServiceData\n    ) => {\n      ctx.merge(data)\n      ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {...ctx.all()})\n    },\n    [SUBSCRIBE]: (ctx: ActorContext, letter: ActorLetter) => {\n      ctx.subscribe(letter.from!)\n      ctx.send(letter.from!, SERVICE_ACTOR_KEYS.UPDATED, {...ctx.all()})\n    },\n    [UNSUBSCRIBE]: (ctx: ActorContext, letter: ActorLetter) =>\n      ctx.unsubscribe(letter.from!),\n    [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (\n      ctx: ActorContext,\n      letter: ActorLetter\n    ) => letter.reply({...ctx.all()}),\n  }\n}\n\nconst spawnProviders = (context: Pick<FCLContext, \"config\">) =>\n  spawn(createHandlers(context) as any, SERVICE_ACTOR_KEYS.AUTHN)\n\n/**\n * Discovery authn service for interacting with Flow compatible wallets.\n *\n * Discovery abstracts away code so that developers don't have to deal with the discovery\n * of Flow compatible wallets, integration, or authentication. Using discovery from FCL\n * allows dapps to list and authenticate with wallets while having full control over the UI.\n * Common use cases for this are login or registration pages.\n *\n * NOTE: The following methods can only be used in web browsers.\n *\n * WARNING: discovery.authn.endpoint value MUST be set in the configuration before calling this method.\n *\n * @example\n * // Basic usage with React\n * import './config';\n * import { useState, useEffect } from 'react';\n * import * as fcl from '@onflow/fcl';\n *\n * function Component() {\n *   const [wallets, setWallets] = useState([]);\n *   useEffect(\n *     () => fcl.discovery.authn.subscribe((res) => setWallets(res.results)),\n *     [],\n *   );\n *\n *   return (\n *     <div>\n *       {wallets.map((wallet) => (\n *         <button\n *           key={wallet.provider.address}\n *           onClick={() => fcl.authenticate({ service: wallet })}\n *         >\n *           Login with {wallet.provider.name}\n *         </button>\n *       ))}\n *     </div>\n *   );\n * }\n *\n * // Configuration for opt-in services\n * import { config } from '@onflow/fcl';\n *\n * config({\n *   'discovery.authn.endpoint':\n *     'https://fcl-discovery.onflow.org/api/testnet/authn', // Endpoint set to Testnet\n *   'discovery.authn.include': ['0x9d2e44203cb13051'], // Ledger wallet address on Testnet set to be included\n *   'discovery.authn.exclude': ['0x123456789abcdef01'], // Example of excluding a wallet by address\n * });\n */\nfunction createAuthn(context: Pick<FCLContext, \"config\">): Authn {\n  /**\n   * @description Discovery methods for interacting with Authn.\n   */\n  const authn: Authn = {\n    /**\n     * Subscribe to Discovery authn services and receive real-time updates.\n     *\n     * This method allows you to subscribe to changes in the available authentication services.\n     * When new services are discovered or existing ones are updated, the callback function will be invoked.\n     *\n     * @param cb Callback function that receives the list of available services and any error\n     * @returns A function to unsubscribe from the service updates\n     *\n     * @example\n     * import * as fcl from '@onflow/fcl';\n     *\n     * const unsubscribe = fcl.discovery.authn.subscribe((services, error) => {\n     *   if (error) {\n     *     console.error('Discovery error:', error);\n     *     return;\n     *   }\n     *   console.log('Available services:', services);\n     * });\n     *\n     * // Later, to stop receiving updates\n     * unsubscribe();\n     */\n    subscribe: cb =>\n      subscriber(SERVICE_ACTOR_KEYS.AUTHN, () => spawnProviders(context), cb),\n\n    /**\n     * Get the current snapshot of Discovery authn services.\n     *\n     * This method returns a promise that resolves to the current state of available authentication services\n     * without setting up a subscription. Useful for one-time checks or initial state loading.\n     *\n     * @returns A promise that resolves to the current service data\n     *\n     * @example\n     * import * as fcl from '@onflow/fcl';\n     *\n     * async function getServices() {\n     *   try {\n     *     const serviceData = await fcl.discovery.authn.snapshot();\n     *     console.log('Current services:', serviceData.results);\n     *   } catch (error) {\n     *     console.error('Failed to get services:', error);\n     *   }\n     * }\n     */\n    snapshot: () =>\n      snapshoter(SERVICE_ACTOR_KEYS.AUTHN, () => spawnProviders(context)),\n\n    /**\n     * Trigger an update of authn services from the discovery endpoint.\n     *\n     * This method manually triggers a refresh of the available authentication services\n     * from the configured discovery endpoint. Useful when you want to force a refresh\n     * of the service list.\n     *\n     * @example\n     * import * as fcl from '@onflow/fcl';\n     *\n     * // Force refresh of available services\n     * fcl.discovery.authn.update();\n     */\n    update: () => {\n      // Only fetch services if the window is loaded\n      // Otherwise, this will be called by the INIT handler\n      if (document.readyState === \"complete\") {\n        fetchServicesFromDiscovery(context)\n      }\n    },\n  }\n\n  return authn\n}\n\nconst authn = /* @__PURE__ */ createAuthn(createPartialGlobalFCLContext())\n\nexport default authn\n","import {invariant} from \"@onflow/util-invariant\"\nimport {getServiceRegistry} from \"../current-user/exec-service/plugins\"\nimport {getChainId} from \"../utils\"\nimport {VERSION} from \"../VERSION\"\nimport {makeDiscoveryServices} from \"./utils\"\nimport {URL} from \"../utils/url\"\nimport {Service} from \"@onflow/typedefs\"\nimport {FCLContext} from \"../context\"\n\nexport interface GetServicesParams {\n  types: string[]\n  context: Pick<FCLContext, \"config\">\n}\n\nexport interface DiscoveryRequestBody {\n  type: string[]\n  fclVersion: string\n  include: string[]\n  exclude: string[]\n  features: {\n    suggested: string[]\n  }\n  clientServices: Service[]\n  supportedStrategies: string[]\n  userAgent?: string\n  network: string\n}\n\n/**\n * @description Fetches available wallet services from the discovery endpoint based on the\n * requested service types. This function queries the FCL discovery service to find compatible\n * wallet providers that support the specified service types.\n *\n * @param params Object containing the types of services to discover\n * @returns Promise resolving to an array of Service objects from the discovery endpoint\n *\n * @example\n * // Discover authentication services\n * const services = await getServices({ types: [\"authn\"] })\n * console.log(services) // Array of available wallet authentication services\n */\nexport async function getServices({\n  context,\n  types,\n}: GetServicesParams): Promise<Service[]> {\n  const endpoint = await context.config.get(\"discovery.authn.endpoint\")\n  invariant(\n    Boolean(endpoint),\n    `\"discovery.authn.endpoint\" in config must be defined.`\n  )\n\n  const include = await context.config.get(\"discovery.authn.include\", [])\n  const exclude = await context.config.get(\"discovery.authn.exclude\", [])\n  const url = new URL(endpoint as string)\n\n  return fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      type: types,\n      fclVersion: VERSION,\n      include,\n      exclude,\n      features: {\n        suggested: await context.config.get(\"discovery.features.suggested\", []),\n      },\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies(),\n      userAgent: window?.navigator?.userAgent,\n      network: await getChainId(),\n    } as DiscoveryRequestBody),\n  }).then(d => d.json())\n}\n","import authn from \"./services/authn\"\nexport {getDiscoveryService, makeDiscoveryServices} from \"./utils\"\n\nconst discovery = {\n  authn,\n}\n\nexport {discovery}\n","import {SHA3} from \"sha3\"\nimport {Buffer} from \"@onflow/rlp\"\n\n/**\n * @description Generates a SHA3-256 hash of a UTF-8 string. This function is commonly used in Flow\n * for creating deterministic hashes of Cadence code, interaction templates, and other string data\n * that need to be uniquely identified or verified for integrity.\n *\n * @param utf8String The UTF-8 string to hash\n * @returns The SHA3-256 hash of the input string as a hexadecimal string\n *\n * @example\n * // Generate hash of Cadence code\n * const cadenceCode = \"access(all) fun main(): String { return \\\"Hello\\\" }\"\n * const hash = genHash(cadenceCode)\n * console.log(hash) // \"a1b2c3d4e5f6...\" (64-character hex string)\n */\nexport function genHash(utf8String: string): string {\n  const sha = new SHA3(256)\n  sha.update(Buffer.from(utf8String, \"utf8\"))\n  return sha.digest(\"hex\")\n}\n","import {ImportItem} from \"../interaction-template\"\n\nexport interface GenerateImportParams {\n  contractName: string\n  address: string\n}\n\n/**\n * @description Creates an ImportItem object from a contract name and address. This is a utility\n * function used to generate standardized import objects for interaction templates and dependency\n * management. The contract field is initialized as an empty string.\n *\n * @param params The parameters object containing contract details\n * @param params.contractName The name of the contract being imported\n * @param params.address The Flow address where the contract is deployed\n * @returns ImportItem object with contractName, address, and empty contract field\n *\n * @example\n * // Generate import for FlowToken contract\n * const importItem = generateImport({\n *   contractName: \"FlowToken\",\n *   address: \"0x1654653399040a61\"\n * })\n * console.log(importItem)\n * // { contractName: \"FlowToken\", address: \"0x1654653399040a61\", contract: \"\" }\n */\nexport function generateImport({\n  contractName,\n  address,\n}: GenerateImportParams): ImportItem {\n  return {contractName, address, contract: \"\"}\n}\n","import {generateImport} from \"./generate-import\"\nimport {ImportItem} from \"../interaction-template\"\n\n/**\n * @description Parses a Cadence script or transaction to find all import statements and extracts\n * the contract names and addresses. This function uses regular expressions to identify import\n * statements and creates ImportItem objects for each imported contract.\n *\n * @param cadence The Cadence code string to parse for import statements\n * @returns Array of ImportItem objects containing contract names and addresses\n *\n * @example\n * // Parse imports from Cadence code\n * const cadenceCode = `\n *   import FlowToken from 0x1654653399040a61\n *   import FungibleToken, NonFungibleToken from 0x9a0766d93b6608b7\n *\n *   transaction() {\n *     // transaction code\n *   }\n * `\n *\n * const imports = findImports(cadenceCode)\n * console.log(imports)\n * // [\n * //   { contractName: \"FlowToken\", address: \"0x1654653399040a61\", contract: \"\" },\n * //   { contractName: \"FungibleToken\", address: \"0x9a0766d93b6608b7\", contract: \"\" },\n * //   { contractName: \"NonFungibleToken\", address: \"0x9a0766d93b6608b7\", contract: \"\" }\n * // ]\n */\nexport function findImports(cadence: string): ImportItem[] {\n  const imports: ImportItem[] = []\n\n  const importsReg = /import ((\\w|,| )+)* from 0x\\w+/g\n  const fileImports = cadence.match(importsReg) || []\n\n  for (const fileImport of fileImports) {\n    const importLineReg = /import ((\\w+|, |)*) from (0x\\w+)/g\n    const importLine = importLineReg.exec(fileImport)\n\n    const contractsReg = /((?:\\w+)+),?/g\n    const contracts = importLine?.[1].match(contractsReg) || []\n\n    for (const contract of contracts) {\n      imports.push(\n        generateImport({\n          address: importLine?.[3]!,\n          contractName: contract.replace(/,/g, \"\"),\n        })\n      )\n    }\n  }\n\n  return imports\n}\n","import {invariant, getAccount} from \"@onflow/sdk\"\nimport {genHash} from \"../utils/hash\"\nimport {findImports} from \"../utils/find-imports\"\nimport {generateImport} from \"../utils/generate-import\"\nimport {FCLContext} from \"../../context\"\nimport {createPartialGlobalFCLContext} from \"../../context/global\"\n\nexport interface GenerateDependencyPin110Params {\n  address: string\n  contractName: string\n  blockHeight?: number\n}\n\nexport function createGenerateDependencyPin110(\n  context: Pick<FCLContext, \"config\" | \"sdk\">\n) {\n  /**\n   * @description Produces a dependency pin for a contract at current state of chain\n   * @param params\n   * @param params.address The address of the account containing the contract\n   * @param params.contractName The name of the contract\n   * @param params.blockHeight The block height to generate the dependency pin at\n   * @param opts Options to pass to the interaction\n   * @returns The dependency pin\n   */\n  async function generateDependencyPin110(\n    {address, contractName}: GenerateDependencyPin110Params,\n    opts: any = {}\n  ): Promise<string> {\n    invariant(\n      address != undefined,\n      \"generateDependencyPin({ address }) -- address must be defined\"\n    )\n    invariant(\n      contractName != undefined,\n      \"generateDependencyPin({ contractName }) -- contractName must be defined\"\n    )\n    invariant(\n      typeof address === \"string\",\n      \"generateDependencyPin({ address }) -- address must be a string\"\n    )\n    invariant(\n      typeof contractName === \"string\",\n      \"generateDependencyPin({ contractName }) -- contractName must be a string\"\n    )\n\n    const horizon: any = [generateImport({contractName, address})]\n\n    for (const horizonImport of horizon) {\n      const account = await context.sdk\n        .send(\n          [\n            getAccount(\n              await context.config.get(\n                horizonImport.address,\n                horizonImport.address\n              )\n            ),\n          ],\n          opts\n        )\n        .then(context.sdk.decode)\n\n      horizonImport.contract = account.contracts?.[horizonImport.contractName]\n\n      if (!horizonImport.contract) {\n        console.error(\"Did not find expected contract\", horizonImport, account)\n        throw new Error(\"Did not find expected contract\")\n      }\n\n      const contractImports = findImports(horizonImport.contract)\n\n      horizon.push(...contractImports)\n    }\n\n    const contractPinSelfHashesPromises = horizon.map((iport: any) =>\n      genHash(iport.contract)\n    )\n    // genHash returns a promise, so we need to await the results of all the promises\n    const contractPinSelfHashes = await Promise.all(\n      contractPinSelfHashesPromises\n    )\n    const contractPinHashes = contractPinSelfHashes.join(\"\")\n\n    return genHash(contractPinHashes)\n  }\n\n  return generateDependencyPin110\n}\n\nexport const generateDependencyPin110 =\n  /* @__PURE__ */ createGenerateDependencyPin110(\n    createPartialGlobalFCLContext()\n  )\n","import {encode as rlpEncode} from \"@onflow/rlp\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport type {\n  InteractionTemplate110,\n  InteractionTemplateDependency,\n  InteractionTemplateI18n,\n  InteractionTemplateMessage,\n  InteractionTemplateNetwork,\n  InteractionTemplateParameter,\n} from \"../interaction-template\"\nimport {createGenerateDependencyPin110} from \"../generate-dependency-pin/generate-dependency-pin-1.1.0\"\nimport {genHash} from \"../utils/hash\"\nimport {FCLContext} from \"../../context\"\nimport {createPartialGlobalFCLContext} from \"../../context/global\"\n\nasync function generateContractNetworks(\n  context: Pick<FCLContext, \"config\" | \"sdk\">,\n  contractName: string,\n  networks: InteractionTemplateNetwork[]\n): Promise<string[][]> {\n  const values: string[][] = []\n  for (const net of networks) {\n    const networkHashes = [genHash(net.network)]\n    const {address, dependency_pin_block_height} = net\n    if (net.dependency_pin) {\n      const hash = await createGenerateDependencyPin110(context)({\n        address,\n        contractName,\n        blockHeight: dependency_pin_block_height,\n      })\n      networkHashes.push(genHash(hash))\n    }\n    values.push(networkHashes)\n  }\n  return values\n}\n\nasync function generateContractDependencies(\n  context: Pick<FCLContext, \"config\" | \"sdk\">,\n  dependencies: InteractionTemplateDependency[]\n): Promise<any[]> {\n  const values: any[] = []\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i]\n    const contracts = []\n    for (let j = 0; j < dependency?.contracts.length; j++) {\n      const c = dependency?.contracts[j]\n      const contractName = c?.contract\n      contracts.push(genHash(contractName))\n      const contractHashes = await generateContractNetworks(\n        context,\n        contractName,\n        c?.networks\n      )\n      contracts.push(contractHashes)\n    }\n    values.push(contracts)\n  }\n  return values\n}\n\nexport function createGenerateTemplateId(\n  context: Pick<FCLContext, \"config\" | \"sdk\">\n) {\n  /**\n   * @description Generates Interaction Template ID for a given Interaction Template\n   *\n   * @param params\n   * @param params.template Interaction Template\n   * @returns Interaction Template ID\n   */\n  async function generateTemplateId({\n    template,\n  }: {\n    template: InteractionTemplate110\n  }): Promise<string> {\n    invariant(\n      !!template,\n      \"generateTemplateId({ template }) -- template must be defined\"\n    )\n    invariant(\n      typeof template === \"object\",\n      \"generateTemplateId({ template }) -- template must be an object\"\n    )\n    invariant(\n      template.f_type === \"InteractionTemplate\",\n      \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\"\n    )\n    invariant(\n      template.f_version === \"1.1.0\",\n      \"generateTemplateId({ template }) -- template object must be an version 1.1.0\"\n    )\n\n    const templateData = template.data\n\n    const messages = await Promise.all(\n      templateData.messages.map(\n        async (templateMessage: InteractionTemplateMessage) => [\n          genHash(templateMessage.key),\n          await Promise.all(\n            templateMessage.i18n.map(\n              async (templateMessagei18n: InteractionTemplateI18n) => [\n                genHash(templateMessagei18n.tag),\n                genHash(templateMessagei18n.translation),\n              ]\n            )\n          ),\n        ]\n      )\n    )\n\n    const params = await Promise.all(\n      templateData?.[\"parameters\"]\n        .sort(\n          (a: InteractionTemplateParameter, b: InteractionTemplateParameter) =>\n            a.index - b.index\n        )\n        .map(async (arg: InteractionTemplateParameter) => [\n          genHash(arg.label),\n          [\n            genHash(String(arg.index)),\n            genHash(arg.type),\n            await Promise.all(\n              arg.messages.map(\n                async (argumentMessage: InteractionTemplateMessage) => [\n                  genHash(argumentMessage.key),\n                  await Promise.all(\n                    argumentMessage.i18n.map(\n                      async (argumentMessagei18n: InteractionTemplateI18n) => [\n                        genHash(argumentMessagei18n.tag),\n                        genHash(argumentMessagei18n.translation),\n                      ]\n                    )\n                  ),\n                ]\n              )\n            ),\n          ],\n        ])\n    )\n\n    const dependencies = [\n      await generateContractDependencies(context, templateData?.dependencies),\n    ]\n\n    const encodedHex = rlpEncode([\n      genHash(template?.f_type),\n      genHash(template?.f_version),\n      genHash(templateData?.type),\n      genHash(templateData?.interface),\n      messages,\n      genHash(templateData?.cadence?.body),\n      [dependencies],\n      params,\n    ]).toString(\"hex\")\n\n    return genHash(encodedHex)\n  }\n\n  return generateTemplateId\n}\n\nexport const generateTemplateId = /* @__PURE__ */ createGenerateTemplateId(\n  createPartialGlobalFCLContext()\n)\n","import {invariant} from \"@onflow/util-invariant\"\nimport {generateTemplateId as generateTemplateId100} from \"./generate-template-id-1.0.0\"\nimport {generateTemplateId as generateTemplateId110} from \"./generate-template-id-1.1.0\"\nimport type {InteractionTemplate} from \"../interaction-template\"\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *\n * @param params\n * @param params.template Interaction Template\n * @returns Interaction Template ID\n */\nexport async function generateTemplateId({\n  template,\n}: {\n  template: InteractionTemplate\n}): Promise<string> {\n  invariant(\n    !!template,\n    \"generateTemplateId({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateTemplateId({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      return await generateTemplateId110({template})\n    case \"1.0.0\":\n      return await generateTemplateId100({template})\n    default:\n      throw new Error(\"generateTemplateId Error: Unsupported template version\")\n  }\n}\n\n/**\n * @description Verifies the given Interaction Template Id has been correctly generated\n *\n * @param params\n * @param params.template Interaction Template\n * @returns true or false, Interaction Template ID\n */\nexport async function verifyGeneratedTemplateId({\n  template,\n}: {\n  template: InteractionTemplate\n}): Promise<boolean> {\n  return template.id === (await generateTemplateId({template}))\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {encode as rlpEncode} from \"@onflow/rlp\"\nimport {genHash} from \"../utils/hash\"\nimport type {InteractionTemplate100} from \"../interaction-template\"\n\nexport interface GenerateTemplateId100Params {\n  template: InteractionTemplate100\n}\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *\n * @param params\n * @param params.template Interaction Template\n * @returns Interaction Template ID\n */\nexport async function generateTemplateId({\n  template,\n}: GenerateTemplateId100Params): Promise<string> {\n  invariant(\n    !!template,\n    \"generateTemplateId({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateTemplateId({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\"\n  )\n  invariant(\n    template.f_version === \"1.0.0\",\n    \"generateTemplateId({ template }) -- template object must be an version 1.0.0\"\n  )\n\n  const templateData = template.data\n\n  const messages = await Promise.all(\n    Object.keys(templateData.messages).map(async messageKey => [\n      genHash(messageKey),\n      await Promise.all(\n        Object.keys(templateData.messages?.[messageKey]?.i18n).map(\n          async i18nkeylanguage => [\n            genHash(i18nkeylanguage),\n            genHash(\n              templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage]\n            ),\n          ]\n        )\n      ),\n    ])\n  )\n\n  const dependencies = await Promise.all(\n    Object.keys(templateData?.dependencies).map(\n      async dependencyAddressPlaceholder => [\n        genHash(dependencyAddressPlaceholder),\n        await Promise.all(\n          Object.keys(\n            templateData?.dependencies?.[dependencyAddressPlaceholder]\n          ).map(async dependencyContract => [\n            genHash(dependencyContract),\n            await Promise.all(\n              Object.keys(\n                templateData?.dependencies?.[dependencyAddressPlaceholder]?.[\n                  dependencyContract\n                ]\n              ).map(async dependencyContractNetwork => [\n                genHash(dependencyContractNetwork),\n                [\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork].address\n                  ),\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork]\n                      .contract\n                  ),\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork]\n                      .fq_address\n                  ),\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork].pin\n                  ),\n                  genHash(\n                    String(\n                      templateData?.dependencies?.[\n                        dependencyAddressPlaceholder\n                      ]?.[dependencyContract]?.[dependencyContractNetwork]\n                        .pin_block_height\n                    )\n                  ),\n                ],\n              ])\n            ),\n          ])\n        ),\n      ]\n    )\n  )\n\n  const _arguments = await Promise.all(\n    Object.keys(templateData?.[\"arguments\"]).map(async argumentLabel => [\n      genHash(argumentLabel),\n      [\n        genHash(String(templateData?.[\"arguments\"]?.[argumentLabel].index)),\n        genHash(templateData?.[\"arguments\"]?.[argumentLabel].type),\n        genHash(templateData?.[\"arguments\"]?.[argumentLabel].balance || \"\"),\n        await Promise.all(\n          Object.keys(\n            templateData?.[\"arguments\"]?.[argumentLabel].messages\n          ).map(async argumentMessageKey => [\n            genHash(argumentMessageKey),\n            await Promise.all(\n              Object.keys(\n                templateData?.[\"arguments\"]?.[argumentLabel].messages?.[\n                  argumentMessageKey\n                ].i18n\n              ).map(async i18nkeylanguage => [\n                genHash(i18nkeylanguage),\n                genHash(\n                  templateData?.[\"arguments\"]?.[argumentLabel].messages?.[\n                    argumentMessageKey\n                  ].i18n?.[i18nkeylanguage]\n                ),\n              ])\n            ),\n          ])\n        ),\n      ],\n    ])\n  )\n\n  const encodedHex = rlpEncode([\n    genHash(\"InteractionTemplate\"),\n    genHash(\"1.0.0\"),\n    genHash(templateData?.type),\n    genHash(templateData?.interface),\n    messages,\n    genHash(templateData?.cadence),\n    dependencies,\n    _arguments,\n  ]).toString(\"hex\")\n\n  return genHash(encodedHex)\n}\n","import {invariant, getAccount} from \"@onflow/sdk\"\nimport {genHash} from \"../utils/hash\"\nimport {findImports} from \"../utils/find-imports\"\nimport {generateImport} from \"../utils/generate-import\"\nimport {FCLContext} from \"../../context\"\nimport {createPartialGlobalFCLContext} from \"../../context/global\"\n\nexport interface GenerateDependencyPin100Params {\n  address: string\n  contractName: string\n}\n\nexport function creategenerateDependencyPin100(\n  context: Pick<FCLContext, \"config\" | \"sdk\">\n) {\n  /**\n   * @description Produces a dependency pin for a contract at current state of chain\n   * @param params\n   * @param params.address The address of the account containing the contract\n   * @param params.contractName The name of the contract\n   * @param opts Options to pass to the interaction\n   * @returns The dependency pin\n   */\n  async function generateDependencyPin100(\n    {address, contractName}: GenerateDependencyPin100Params,\n    opts: any = {}\n  ): Promise<string> {\n    invariant(\n      address != undefined,\n      \"generateDependencyPin({ address }) -- address must be defined\"\n    )\n    invariant(\n      contractName != undefined,\n      \"generateDependencyPin({ contractName }) -- contractName must be defined\"\n    )\n    invariant(\n      typeof address === \"string\",\n      \"generateDependencyPin({ address }) -- address must be a string\"\n    )\n    invariant(\n      typeof contractName === \"string\",\n      \"generateDependencyPin({ contractName }) -- contractName must be a string\"\n    )\n\n    const horizon: any = [generateImport({contractName, address})]\n\n    for (const horizonImport of horizon) {\n      const account = await context.sdk\n        .send(\n          [\n            getAccount(\n              await context.config.get(\n                horizonImport.address,\n                horizonImport.address\n              )\n            ),\n          ],\n          opts\n        )\n        .then(context.sdk.decode)\n\n      horizonImport.contract = account.contracts?.[horizonImport.contractName]\n\n      if (!horizonImport.contract) {\n        console.error(\"Did not find expected contract\", horizonImport, account)\n        throw new Error(\"Did not find expected contract\")\n      }\n\n      const contractImports = findImports(horizonImport.contract)\n\n      horizon.push(...contractImports)\n    }\n\n    const contractHashes = horizon.map((iport: any) => genHash(iport.contract))\n\n    const contractHashesJoined = contractHashes.join(\"\")\n\n    return genHash(contractHashesJoined)\n  }\n\n  return generateDependencyPin100\n}\n\nexport const generateDependencyPin100 =\n  /* @__PURE__ */ creategenerateDependencyPin100(\n    createPartialGlobalFCLContext()\n  )\n","import {block, invariant} from \"@onflow/sdk\"\nimport {generateDependencyPin110} from \"./generate-dependency-pin-1.1.0\"\nimport {generateDependencyPin100} from \"./generate-dependency-pin-1.0.0\"\n\nexport interface GenerateDependencyPinParams {\n  version?: string\n  address: string\n  contractName: string\n  blockHeight?: number\n}\n\n/**\n * @description Generates a dependency pin for a smart contract on the Flow blockchain. A dependency\n * pin is a cryptographic hash that uniquely identifies a specific version of a contract at a particular\n * state. This is used in Interaction Templates to ensure consistent behavior by pinning to specific\n * contract versions and preventing issues from contract updates.\n *\n * @param params\n * @param params.version The version of the interaction template (e.g., \"1.0.0\", \"1.1.0\")\n * @param params.address The Flow account address containing the contract (with or without 0x prefix)\n * @param params.contractName The name of the contract to generate a pin for\n * @param params.blockHeight Optional specific block height to pin to\n * @param opts Additional options to pass to the underlying interaction\n *\n * @returns Promise that resolves to the dependency pin as a string\n *\n * @throws If required parameters are missing or invalid, or if the template version is unsupported\n *\n * @example\n * // Generate dependency pin for a contract at current state\n * import * as fcl from \"@onflow/fcl\"\n *\n * const dependencyPin = await fcl.InteractionTemplateUtils.generateDependencyPin({\n *   version: \"1.1.0\",\n *   address: \"0x1654653399040a61\",\n *   contractName: \"FlowToken\"\n * })\n */\nexport async function generateDependencyPin(\n  {version, address, contractName}: GenerateDependencyPinParams,\n  opts: any = {}\n): Promise<string> {\n  invariant(\n    address != undefined,\n    \"generateDependencyPin({ address }) -- address must be defined\"\n  )\n  invariant(\n    contractName != undefined,\n    \"generateDependencyPin({ contractName }) -- contractName must be defined\"\n  )\n  invariant(\n    typeof address === \"string\",\n    \"generateDependencyPin({ address }) -- address must be a string\"\n  )\n  invariant(\n    typeof contractName === \"string\",\n    \"generateDependencyPin({ contractName }) -- contractName must be a string\"\n  )\n\n  switch (version) {\n    case \"1.1.0\":\n      return await generateDependencyPin110({address, contractName})\n    case \"1.0.0\":\n      return await generateDependencyPin100({address, contractName})\n    default:\n      throw new Error(\n        \"deriveCadenceByNetwork Error: Unsupported template version\"\n      )\n  }\n}\n\n/**\n * @description Generates a dependency pin for a smart contract at the latest sealed block on the Flow\n * blockchain. This variant ensures the pin is generated against the most recent finalized state of the\n * network, providing consistency and avoiding issues with pending transactions affecting the pin generation.\n *\n * @param params\n * @param params.version The version of the interaction template (e.g., \"1.0.0\", \"1.1.0\")\n * @param params.address The Flow account address containing the contract (with or without 0x prefix)\n * @param params.contractName The name of the contract to generate a pin for\n * @param params.blockHeight This parameter is ignored as the function always uses latest sealed block\n * @param opts Additional options to pass to the underlying interaction\n *\n * @returns Promise that resolves to the dependency pin as a string\n *\n * @throws If required parameters are missing or invalid, template version is unsupported,\n * or if unable to fetch the latest sealed block\n *\n * @example\n * // Generate dependency pin at latest sealed block\n * import * as fcl from \"@onflow/fcl\"\n *\n * const dependencyPin = await fcl.InteractionTemplateUtils.generateDependencyPinAtLatestSealedBlock({\n *   version: \"1.1.0\",\n *   address: \"0x1654653399040a61\",\n *   contractName: \"FlowToken\"\n * })\n */\nexport async function generateDependencyPinAtLatestSealedBlock(\n  {version, address, contractName}: GenerateDependencyPinParams,\n  opts: any = {}\n): Promise<string> {\n  const latestSealedBlock = await block({sealed: true}, opts)\n  const latestSealedBlockHeight = latestSealedBlock?.height\n\n  return generateDependencyPin(\n    {version, address, contractName, blockHeight: latestSealedBlockHeight},\n    opts\n  )\n}\n","import {generateDependencyPin} from \"./generate-dependency-pin/generate-dependency-pin\"\nimport {invariant, block} from \"@onflow/sdk\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\nimport {InteractionTemplate} from \"./interaction-template\"\n\nexport interface VerifyDependencyPinsSameParams {\n  template: InteractionTemplate\n  blockHeight?: number\n  network: string\n}\n\nexport interface VerifyDependencyPinsSameOpts {\n  [key: string]: any\n}\n\nexport interface VerifyDependencyPinsSameAtLatestSealedBlockParams {\n  template: InteractionTemplate\n  network: string\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at a block height\n *\n * @param params\n * @param params.template Interaction Template to check pins for\n * @param params.blockHeight Block height to check pins at\n * @param params.network Network to check pins on\n * @param opts\n * @returns Whether or not the pins match\n */\nexport async function verifyDependencyPinsSame(\n  {template, blockHeight, network}: VerifyDependencyPinsSameParams,\n  opts: VerifyDependencyPinsSameOpts = {}\n): Promise<boolean> {\n  invariant(\n    template != undefined,\n    \"generateDependencyPin({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateDependencyPin({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\"\n  )\n\n  invariant(\n    network != undefined,\n    \"generateDependencyPin({ network }) network must be defined\"\n  )\n  invariant(\n    blockHeight != undefined,\n    \"generateDependencyPin({ blockHeight }) blockHeight must be defined\"\n  )\n  invariant(\n    typeof blockHeight === \"number\",\n    \"generateDependencyPin({ blockHeight }) blockHeight must be a number\"\n  )\n\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const templateDependenciesPlaceholderKeys = Object.keys(\n        template.data.dependencies\n      )\n\n      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {\n        const templateDependencyPlaceholder =\n          template.data.dependencies[templateDependencyPlaceholderKey]\n\n        const templateDependencyPlaceholderContractNames = Object.keys(\n          templateDependencyPlaceholder\n        )\n\n        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {\n          const templateDependencyPlaceholderContractNetworks =\n            template.data.dependencies[templateDependencyPlaceholderKey][\n              templateDependencyPlaceholderContractName\n            ]\n\n          const templateDependency =\n            templateDependencyPlaceholderContractNetworks[network]\n          if (typeof templateDependency === \"undefined\") continue\n\n          const pin = await generateDependencyPin(\n            {\n              address: templateDependency.address,\n              contractName: templateDependency.contract,\n              blockHeight,\n            },\n            opts\n          )\n\n          if (pin !== templateDependency.pin) {\n            log({\n              title: \"verifyDependencyPinsSame Debug Error\",\n              message: `Could not recompute and match dependency pin.\n                                address: ${templateDependency.address} | contract: ${templateDependency.contract}\n                                computed: ${pin}\n                                template: ${templateDependency.pin}\n                            `,\n              level: LEVELS.debug,\n            })\n            return false\n          }\n        }\n      }\n\n      return true\n\n    case \"1.1.0\":\n      let isVerified = false\n      // iterate over each dependency\n      for (let i = 0; i < template.data?.dependencies.length; i++) {\n        const dependency = template.data?.dependencies[i]\n        // iterate over each contract in dependency\n        for (let j = 0; j < dependency?.contracts.length; j++) {\n          const contract = dependency?.contracts[j]\n          // iterate over each network in contract\n          for (let k = 0; k < contract?.networks.length; k++) {\n            const net = contract?.networks[k]\n            // if network matches, generate pin and compare\n            if (net.network === network) {\n              const pin = await generateDependencyPin(\n                {\n                  version: template.f_version,\n                  address: net.address,\n                  contractName: contract.contract,\n                  blockHeight,\n                },\n                opts\n              )\n\n              if (pin !== (net as any).dependency_pin.pin) {\n                log({\n                  title: \"verifyDependencyPinsSame Debug Error\",\n                  message: `Could not recompute and match dependency pin.\n                                    address: ${net.address} | contract: ${contract.contract}\n                                    computed: ${pin}\n                                    template: ${(net as any).pin}\n                                `,\n                  level: LEVELS.debug,\n                })\n                return false\n              } else {\n                isVerified = true\n              }\n            }\n          }\n        }\n      }\n      return isVerified\n\n    default:\n      throw new Error(\n        \"verifyDependencyPinsSame Error: Unsupported template version\"\n      )\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at the latest block height\n *\n * @param params\n * @param params.template Interaction Template to check pins for\n * @param params.network Network to check pins on\n * @param opts\n * @returns Whether or not the pins match\n */\nexport async function verifyDependencyPinsSameAtLatestSealedBlock(\n  {template, network}: VerifyDependencyPinsSameAtLatestSealedBlockParams,\n  opts: VerifyDependencyPinsSameOpts = {}\n): Promise<boolean> {\n  const latestSealedBlock = await block({sealed: true})\n  const latestSealedBlockHeight = latestSealedBlock?.height\n\n  return verifyDependencyPinsSame(\n    {template, network, blockHeight: latestSealedBlockHeight},\n    opts\n  )\n}\n","import {config, invariant} from \"@onflow/sdk\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\nimport {createQuery} from \"../exec/query\"\nimport {generateTemplateId} from \"./generate-template-id/generate-template-id\"\nimport {createGetChainId} from \"../utils\"\nimport type {InteractionTemplate} from \"./interaction-template\"\nimport {FCLContext} from \"../context\"\n\nexport interface GetInteractionTemplateAuditsParams {\n  template: InteractionTemplate\n  auditors?: string[]\n}\n\nexport interface GetInteractionTemplateAuditsOpts {\n  flowInteractionAuditContract?: string\n}\n\n/**\n * @description Checks whether a set of auditors have audited a given Interaction Template on the Flow\n * blockchain. This function validates that the provided interaction template has been properly audited\n * for security by trusted auditors before execution. It queries the Flow blockchain's audit contract\n * to verify audit status.\n *\n * @param params\n * @param params.template The Interaction Template to check audits for. Must be\n * a valid InteractionTemplate object with f_type \"InteractionTemplate\"\n * @param params.auditors Array of auditor addresses to check. If not provided, will use\n * auditors from configuration 'flow.auditors'\n * @param opts Optional configuration parameters\n * @param opts.flowInteractionAuditContract Override address for the FlowInteractionAudit\n * contract if not using network defaults\n *\n * @returns Promise that resolves to an object mapping auditor\n * addresses to boolean values indicating whether they have audited the template\n *\n * @throws If template is invalid, template ID cannot be recomputed, network is unsupported,\n * or required configuration is missing\n *\n * @example\n * // Check if template has been audited by specific auditors\n * import * as fcl from \"@onflow/fcl\"\n *\n * const template = {\n *   f_type: \"InteractionTemplate\",\n *   f_version: \"1.1.0\",\n *   id: \"template-id-123\",\n *   data: {\n *     type: \"transaction\",\n *     interface: \"...\",\n *     cadence: \"transaction { ... }\"\n *   }\n * }\n *\n * const auditorAddresses = [\n *   \"0x1234567890abcdef\",\n *   \"0xabcdef1234567890\"\n * ]\n *\n * const auditResults = await fcl.InteractionTemplateUtils.getInteractionTemplateAudits({\n *   template,\n *   auditors: auditorAddresses\n * })\n *\n * console.log(auditResults)\n * // { \"0x1234567890abcdef\": true, \"0xabcdef1234567890\": false }\n */\nexport async function getInteractionTemplateAudits(\n  context: FCLContext,\n  {template, auditors}: GetInteractionTemplateAuditsParams,\n  opts: GetInteractionTemplateAuditsOpts = {}\n): Promise<Record<string, boolean>> {\n  invariant(\n    template != undefined,\n    \"getInteractionTemplateAudits({ template }) -- template must be defined\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate\"\n  )\n\n  // Recompute ID to be sure it matches\n  let recomputedTemplateID = await generateTemplateId({template})\n\n  if (recomputedTemplateID !== template.id) {\n    log({\n      title: \"getInteractionTemplateAudits Debug Error\",\n      message: `Could not recompute and match template ID\n                computed: ${recomputedTemplateID}\n                template: ${template.id}\n            `,\n      level: LEVELS.debug,\n    })\n    throw new Error(\n      \"getInteractionTemplateAudits Error: Could not recompute and match template ID\"\n    )\n  }\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n    case \"1.0.0\":\n      const _auditors = auditors || (await context.config.get(\"flow.auditors\"))\n\n      invariant(\n        _auditors,\n        \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set\"\n      )\n      invariant(\n        Array.isArray(_auditors),\n        \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array\"\n      )\n\n      let FlowInteractionAuditContract = opts.flowInteractionAuditContract\n      if (!FlowInteractionAuditContract) {\n        const fclNetwork = await createGetChainId(context)(opts)\n        invariant(\n          fclNetwork === \"mainnet\" || fclNetwork === \"testnet\",\n          \"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'\"\n        )\n        if (fclNetwork === \"mainnet\") {\n          FlowInteractionAuditContract = \"0xfd100e39d50a13e6\"\n        } else {\n          FlowInteractionAuditContract = \"0xf78bfc12d0a786dc\"\n        }\n      }\n\n      const audits = await createQuery(context)({\n        cadence: `\n        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}\n        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,\n        args: (arg: any, t: any) => [\n          arg(recomputedTemplateID, t.String),\n          arg(_auditors, t.Array(t.Address)),\n        ],\n      })\n\n      return audits\n\n    default:\n      throw new Error(\n        \"getInteractionTemplateAudits Error: Unsupported template version\"\n      )\n  }\n}\n","import {invariant} from \"@onflow/sdk\"\nimport type {InteractionTemplate} from \"./interaction-template\"\n\nexport interface GetTemplateArgumentMessageParams {\n  localization?: string\n  argumentLabel: string\n  messageKey: string\n  template: InteractionTemplate\n}\n\n/**\n * @description Gets Interaction Template argument message by message key, argument label, and localization\n *\n * @param params\n * @param params.localization [localization=\"en-US\"] Localization to get message for\n * @param params.argumentLabel Argument label to get message for\n * @param params.messageKey Message key to get message for\n * @param params.template Interaction Template to get message from\n * @returns Message\n */\nexport function getTemplateArgumentMessage({\n  localization = \"en-US\",\n  argumentLabel,\n  messageKey,\n  template,\n}: GetTemplateArgumentMessageParams): string | undefined {\n  invariant(\n    messageKey,\n    \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined\"\n  )\n  invariant(\n    typeof messageKey === \"string\",\n    \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string\"\n  )\n\n  invariant(\n    argumentLabel,\n    \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined\"\n  )\n  invariant(\n    typeof argumentLabel === \"string\",\n    \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string\"\n  )\n\n  invariant(\n    localization,\n    \"getTemplateArgumentMessage({ localization }) -- localization must be defined\"\n  )\n  invariant(\n    typeof localization === \"string\",\n    \"getTemplateArgumentMessage({ localization }) -- localization must be a string\"\n  )\n\n  invariant(\n    template != undefined,\n    \"getTemplateArgumentMessage({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"getTemplateArgumentMessage({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      const param = template?.data?.parameters?.find(\n        (a: any) => a.label === argumentLabel\n      )\n      if (!param) return undefined\n      const message = param?.messages?.find((a: any) => a.key === messageKey)\n      if (!message) return undefined\n      const lzn = message?.i18n?.find((a: any) => a.tag === localization)\n      if (!lzn) return undefined\n      return lzn.translation\n    case \"1.0.0\":\n      return template?.data?.arguments?.[argumentLabel]?.messages?.[messageKey]\n        ?.i18n?.[localization]\n    default:\n      throw new Error(\n        \"getTemplateArgumentMessage Error: Unsupported template version\"\n      )\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport type {InteractionTemplate} from \"./interaction-template\"\n\nexport interface GetTemplateMessageParams {\n  localization?: string\n  messageKey: string\n  template: InteractionTemplate\n}\n\n/**\n * @description Get Interaction Template argument message\n *\n * @param params\n * @param params.localization [localization=\"en-US\"] Localization code\n * @param params.messageKey Message key\n * @param params.template Interaction Template\n * @returns Message\n */\nexport function getTemplateMessage({\n  localization = \"en-US\",\n  messageKey,\n  template,\n}: GetTemplateMessageParams): string | undefined {\n  invariant(\n    messageKey as any,\n    \"getTemplateMessage({ messageKey }) -- messageKey must be defined\"\n  )\n  invariant(\n    typeof messageKey === \"string\",\n    \"getTemplateMessage({ messageKey }) -- messageKey must be a string\"\n  )\n\n  invariant(\n    localization as any,\n    \"getTemplateMessage({ localization }) -- localization must be defined\"\n  )\n  invariant(\n    typeof localization === \"string\",\n    \"getTemplateMessage({ localization }) -- localization must be a string\"\n  )\n\n  invariant(\n    template != undefined,\n    \"getTemplateMessage({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"getTemplateMessage({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"getTemplateMessage({ template }) -- template object must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      const msg = template?.data?.messages?.find(\n        (a: any) => a.key === messageKey\n      )\n      if (!msg) return undefined\n      const lzn = msg?.i18n?.find((a: any) => a.tag === localization)\n      if (!lzn) return undefined\n      return lzn.translation\n    case \"1.0.0\":\n      return template?.data?.messages?.[messageKey]?.i18n?.[localization]\n    default:\n      throw new Error(\n        \"getTemplateArgumentMessage Error: Unsupported template version\"\n      )\n  }\n}\n","import type {AccountAuthorization} from \"@onflow/sdk\"\nimport * as sdk from \"@onflow/sdk\"\nimport {CurrentUserService} from \"../current-user\"\nimport {isNumber} from \"../utils/is\"\nimport type {ArgsFn} from \"./args\"\nimport {normalizeArgs} from \"./utils/normalize-args\"\nimport {preMutate} from \"./utils/pre\"\nimport {prepTemplateOpts} from \"./utils/prep-template-opts\"\nimport {FCLContext} from \"../context\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\n\nexport interface MutateOptions {\n  cadence?: string\n  args?: ArgsFn\n  template?: any\n  limit?: number\n  authz?: AccountAuthorization\n  proposer?: AccountAuthorization\n  payer?: AccountAuthorization\n  authorizations?: AccountAuthorization[]\n}\n\n/**\n * @description Factory function that returns a mutate function for a given currentUser.\n *\n * @param currentUserOrConfig CurrentUser actor or configuration\n */\nexport const createMutate = (\n  context: Pick<FCLContext, \"config\" | \"sdk\" | \"currentUser\">\n) => {\n  /**\n   * @description Allows you to submit transactions to the blockchain to potentially mutate the state.\n   *\n   * When being used in the browser, `fcl.mutate` uses the built-in `fcl.authz` function to produce the authorization (signatures) for the current user. When calling this method from Node.js, you will need to supply your own custom authorization function.\n   *\n   * @param opts Mutation options configuration\n   * @param opts.cadence A valid cadence transaction (required)\n   * @param opts.args Any arguments to the script if needed should be supplied via a function that returns an array of arguments\n   * @param opts.limit Compute (Gas) limit for query.\n   * @param opts.proposer The authorization function that returns a valid AuthorizationObject for the proposer role\n   * @param opts.template Interaction Template for a transaction\n   * @param opts.authz Authorization function for transaction\n   * @param opts.payer Payer Authorization function for transaction\n   * @param opts.authorizations Authorizations function for transaction\n   * @returns The transaction ID\n   *\n   * @example\n   * import * as fcl from '@onflow/fcl';\n   * // login somewhere before\n   * fcl.authenticate();\n   *\n   * const txId = await fcl.mutate({\n   *   cadence: `\n   *     import Profile from 0xba1132bc08f82fe2\n   *\n   *     transaction(name: String) {\n   *       prepare(account: auth(BorrowValue) &Account) {\n   *         account.storage.borrow<&{Profile.Owner}>(from: Profile.privatePath)!.setName(name)\n   *       }\n   *     }\n   *   `,\n   *   args: (arg, t) => [arg('myName', t.String)],\n   * });\n   */\n  const mutate = async (opts: MutateOptions = {}): Promise<string> => {\n    var txid\n    try {\n      await preMutate(context, opts)\n      opts = await prepTemplateOpts(context, opts)\n      // Allow for a config to overwrite the authorization function.\n      // prettier-ignore\n      const authz: any = await context\n        .config\n        .get(\"fcl.authz\", context.currentUser.authorization)\n\n      txid = context.sdk\n        .send([\n          sdk.transaction(opts.cadence!),\n\n          sdk.args(normalizeArgs(opts.args || [])),\n\n          opts.limit && isNumber(opts.limit) && (sdk.limit(opts.limit!) as any),\n\n          // opts.proposer > opts.authz > authz\n          sdk.proposer(opts.proposer || opts.authz || authz),\n\n          // opts.payer > opts.authz > authz\n          sdk.payer(opts.payer || opts.authz || authz),\n\n          // opts.authorizations > [opts.authz > authz]\n          sdk.authorizations(opts.authorizations || [opts.authz || authz]),\n        ])\n        .then(context.sdk.decode)\n\n      return txid\n    } catch (error) {\n      throw error\n    }\n  }\n\n  return mutate\n}\n\n/**\n * @description Legacy factory function that creates a mutate function using global FCL context.\n * This function provides backward compatibility for code that was written before the\n * introduction of dependency injection patterns in FCL. It creates a mutate function\n * by combining a partial global context with a provided current user service.\n *\n * This function is considered legacy and should be used primarily for backward compatibility.\n * New code should prefer using the `createMutate` function with a complete FCL context\n * for better testability and dependency management.\n *\n * The function creates a partial context using global configuration and SDK methods,\n * then combines it with the provided current user service to create a fully functional\n * mutate function.\n *\n * @param currentUserOrConfig The current user service instance that provides authentication\n * and authorization capabilities. This service must implement the CurrentUserService interface\n * and provide methods for user authentication, authorization, and session management.\n *\n * @returns A mutate function that can submit transactions to the Flow blockchain.\n * The returned function accepts the same options as the standard mutate function:\n * - cadence: The Cadence transaction code to execute\n * - args: Function that returns transaction arguments\n * - template: Interaction template for standardized transactions\n * - limit: Compute limit for the transaction\n * - authz: Authorization function for all roles\n * - proposer: Specific authorization for proposer role\n * - payer: Specific authorization for payer role\n * - authorizations: Array of authorization functions for authorizer roles\n *\n * @example\n * // Legacy usage with global context\n * import { getMutate } from \"@onflow/fcl-core\"\n * import { getCurrentUser } from \"@onflow/fcl-core\"\n *\n * // Get the current user service\n * const currentUser = getCurrentUser({ platform: \"web\" })\n *\n * // Create mutate function using legacy pattern\n * const mutate = getMutate(currentUser)\n *\n * // Use the mutate function\n * const txId = await mutate({\n *   cadence: `\n *     transaction {\n *       execute { log(\"Hello, Flow!\") }\n *     }\n *   `\n * })\n */\nexport const getMutate = (currentUserOrConfig: CurrentUserService) => {\n  const partialContext = createPartialGlobalFCLContext()\n  const context: Pick<FCLContext, \"config\" | \"sdk\" | \"currentUser\"> = {\n    ...partialContext,\n    currentUser: currentUserOrConfig,\n  }\n  return createMutate(context)\n}\n","import {CompositeSignature} from \"@onflow/typedefs\"\nimport {sansPrefix} from \"@onflow/util-address\"\nimport {COMPOSITE_SIGNATURE_PRAGMA} from \"./__vsn\"\n\n/**\n * @description Normalizes a composite signature to ensure compatibility with FCL format\n *\n * @param resp The composite signature to normalize\n * @returns The normalized composite signature or null\n *\n * @example\n * const resp = normalizeCompositeSignature({\n *   f_type: \"CompositeSignature\",\n *   f_vsn: \"1.0.0\",\n *   addr: \"_____\",         // sans-prefix\n *   signature: \"adfe1234\", // hex\n *   keyId: 3,\n * })\n */\nexport function normalizeCompositeSignature(\n  resp: any\n): CompositeSignature | null {\n  if (resp == null) return null\n\n  if (!resp[\"f_vsn\"]) {\n    return {\n      ...COMPOSITE_SIGNATURE_PRAGMA,\n      addr: sansPrefix(resp.addr || (resp as any).address),\n      signature: resp.signature || (resp as any).sig,\n      keyId: resp.keyId,\n    } as unknown as CompositeSignature\n  }\n\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp as unknown as CompositeSignature\n\n    default:\n      return null\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\nimport {SERVICE_PRAGMA} from \"./__vsn\"\n\nexport interface FrameService extends Service {\n  old?: any\n}\n\n/**\n * @description Normalizes a frame service to ensure compatibility with FCL service format\n *\n * @param service The frame service to normalize\n * @returns The normalized frame service or null\n *\n * @example\n * const service = normalizeFrame({\n *   f_type: \"Service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"frame\",\n *   endpoint: \"https://rawr\",\n *   data: {},   // Sent to frame when ready\n *   params: {}, // include in query params on frame\n * })\n */\nexport function normalizeFrame(service: Service | null): FrameService | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      old: service,\n      ...SERVICE_PRAGMA,\n      type: \"frame\",\n      endpoint: service.endpoint,\n      params: service.params || {},\n      data: service.data || {},\n    } as FrameService\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {SERVICE_PRAGMA} from \"./__vsn\"\nimport {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Normalizes a back-channel-rpc service to ensure compatibility with FCL service format\n *\n * @param service The back-channel-rpc service to normalize\n * @returns The normalized back-channel-rpc service or null\n *\n * @example\n * const service = normalizeBackChannelRpc({\n *   f_type: \"Service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"back-channel-rpc\",\n *   endpoint: \"https://rawr\",\n *   method: \"HTTP/GET\", // HTTP/GET | HTTP/POST\n *   data: {},           // included in body of rpc\n *   params: {},         // included as query params on endpoint url\n * })\n */\nexport function normalizeBackChannelRpc(\n  service: Service | null\n): Service | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: \"back-channel-rpc\",\n      endpoint: service.endpoint,\n      method: service.method,\n      params: service.params || {},\n      data: service.data || {},\n    } as Service\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\nimport {SERVICE_PRAGMA} from \"./__vsn\"\n\n/**\n * @description Normalizes a local-view service to ensure compatibility with FCL format\n *\n * @param resp The local-view to normalize\n * @returns The normalized local-view or null\n *\n * @example\n * const service = normalizeLocalView({\n *   f_type: \"Service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"local-view\",\n *   method: \"VIEW/IFRAME\",\n *   endpoint: \"https://woot.org/authz/local\",\n *   data: {},\n *   params: {},\n * })\n */\nexport function normalizeLocalView(resp: Service | null): Service | null {\n  if (resp == null) return null\n  if (resp.method == null) {\n    resp = {...resp, type: \"local-view\", method: \"VIEW/IFRAME\"}\n  }\n\n  if (!resp[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: resp.type || \"local-view\",\n      method: resp.method,\n      endpoint: resp.endpoint,\n      data: resp.data || {},\n      params: resp.params || {},\n    } as Service\n  }\n\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp\n\n    default:\n      return null\n  }\n}\n","import {normalizeAuthn} from \"./authn\"\nimport {normalizeAuthz} from \"./authz\"\nimport {normalizePreAuthz} from \"./pre-authz\"\nimport {normalizeFrame} from \"./frame\"\nimport {normalizeBackChannelRpc} from \"./back-channel-rpc\"\nimport {normalizeOpenId} from \"./open-id\"\nimport {normalizeUserSignature} from \"./user-signature\"\nimport {normalizeLocalView} from \"./local-view\"\nimport {normalizeAccountProof} from \"./account-proof\"\nimport {normalizeAuthnRefresh} from \"./authn-refresh\"\nimport type {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Normalizes an array of services by applying type-specific normalization to each service.\n * This function processes multiple services in batch, applying the appropriate normalizer based on\n * each service's type, and filters out any services that fail normalization.\n *\n * @param services Array of services to normalize\n * @param data Optional additional data to pass to individual service normalizers\n * @returns Array of normalized services with invalid services filtered out\n *\n * @example\n * // Normalize multiple services from wallet discovery\n * const rawServices = [\n *   { type: \"authn\", endpoint: \"https://wallet.com/authn\", ... },\n *   { type: \"authz\", endpoint: \"https://wallet.com/authz\", ... },\n *   { type: \"user-signature\", endpoint: \"https://wallet.com/sign\", ... }\n * ]\n *\n * const normalizedServices = normalizeServices(rawServices)\n * console.log(\"Normalized services:\", normalizedServices)\n */\nexport function normalizeServices(services: Service[], data?: any): Service[] {\n  return services\n    .map(service => normalizeService(service, data))\n    .filter(Boolean)\n}\n\nconst serviceNormalizers: Record<\n  string,\n  (service: Service, data?: any) => any\n> = {\n  \"back-channel-rpc\": normalizeBackChannelRpc,\n  \"pre-authz\": normalizePreAuthz,\n  authz: normalizeAuthz,\n  authn: normalizeAuthn,\n  frame: normalizeFrame,\n  \"open-id\": normalizeOpenId,\n  \"user-signature\": normalizeUserSignature,\n  \"local-view\": normalizeLocalView,\n  \"account-proof\": normalizeAccountProof,\n  \"authn-refresh\": normalizeAuthnRefresh,\n}\n\n/**\n * @description Normalizes a single service by applying the appropriate type-specific normalizer.\n * This function looks up the correct normalizer based on the service type and applies it to\n * ensure the service conforms to expected formats and contains required fields.\n *\n * @param service The service object to normalize\n * @param data Optional additional data to pass to the service normalizer\n * @returns The normalized service object\n *\n * @example\n * // Normalize an authentication service\n * const rawService = {\n *   type: \"authn\",\n *   endpoint: \"https://wallet.example.com/authn\",\n *   method: \"HTTP/POST\",\n *   // ... other service properties\n * }\n *\n * const normalized = normalizeService(rawService)\n * console.log(\"Normalized service:\", normalized)\n */\nexport function normalizeService(service: Service, data?: any): Service {\n  try {\n    const normalized = serviceNormalizers[service.type](service, data)\n    return normalized\n  } catch (error) {\n    console.error(\n      `Unrecognized FCL Service Type [${service.type}]`,\n      service,\n      error\n    )\n    return service\n  }\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {IDENTITY_PRAGMA, SERVICE_PRAGMA} from \"./__vsn\"\nimport {AuthzService} from \"./authz\"\n\n/**\n * @description Normalizes a pre-authz service to ensure compatibility with FCL service format\n *\n * @param service The pre-authz service to normalize\n * @returns The normalized pre-authz service or null\n *\n * @example\n * const service = normalizePreAuthz({\n *   f_type: \"service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"pre-authz\",\n *   uid: \"uniqueDedupeKey\",\n *   endpoint: \"https://rawr\",\n *   method: \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n *   identity: {\n *     address: \"0x______\",\n *     keyId: 0,\n *   },\n * })\n */\nexport function normalizePreAuthz(\n  service: AuthzService | null\n): AuthzService | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: service.type,\n      uid: service.id,\n      endpoint: service.endpoint,\n      method: service.method,\n      identity: {\n        ...IDENTITY_PRAGMA,\n        address: withPrefix(service.addr!),\n        keyId: service.keyId,\n      },\n      params: service.params,\n      data: service.data,\n    } as AuthzService\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {IDENTITY_PRAGMA, SERVICE_PRAGMA} from \"./__vsn\"\nimport {Service} from \"@onflow/typedefs\"\n\nexport interface AuthzService extends Service {\n  id?: string\n  addr?: string\n  keyId?: number\n  identity?: any\n}\n\n/**\n * @description Normalizes an authz service to ensure compatibility with FCL service format\n *\n * @param service The authz service to normalize\n * @returns The normalized authz service or null\n *\n * @example\n * const service = normalizeAuthz({\n *   f_type: \"service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"authz\",\n *   uid: \"uniqueDedupeKey\",\n *   endpoint: \"https://rawr\",\n *   method: \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n *   identity: {\n *     address: \"0x______\",\n *     keyId: 0,\n *   },\n *   data: {}, // included in body of authz request\n *   params: {}, // included as query params on endpoint url\n * })\n */\nexport function normalizeAuthz(\n  service: AuthzService | null\n): AuthzService | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: service.type,\n      uid: service.id,\n      endpoint: service.endpoint,\n      method: service.method,\n      identity: {\n        ...IDENTITY_PRAGMA,\n        address: withPrefix(service.addr!),\n        keyId: service.keyId,\n      },\n      params: service.params,\n      data: service.data,\n    } as AuthzService\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\nimport {withPrefix} from \"@onflow/util-address\"\nimport {SERVICE_PRAGMA} from \"./__vsn\"\n\nexport interface AuthnService extends Service {\n  id?: string\n  addr?: string\n  name?: string\n  icon?: string\n  authn?: string\n  pid?: string\n}\n\n/**\n * @description Normalizes an authn service to ensure compatibility with FCL service format\n *\n * @param service The authn service to normalize\n * @returns The normalized authn service or null\n *\n * @example\n * const service = normalizeAuthn({\n *   f_type: \"Service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"authn\",\n *   uid: \"uniqueDedupeKey\",\n *   endpoint: \"https://rawr\",\n *   id: \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n *   identity: {\n *     address: \"0x____\"\n *   },\n *   provider: {\n *     address: \"0x____\",\n *     name: \"Best Wallet\",\n *     description: \"The Best Wallet\",\n *     icon: \"https://\",\n *   }\n * })\n */\nexport function normalizeAuthn(\n  service: AuthnService | null\n): AuthnService | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: service.type,\n      uid: service.id,\n      endpoint: service.authn,\n      id: service.pid,\n      provider: {\n        address: withPrefix(service.addr!),\n        name: service.name,\n        icon: service.icon,\n      },\n    } as AuthnService\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Normalizes an open-id service to ensure compatibility with FCL service format\n *\n * @param service The open-id service to normalize\n * @returns The normalized open-id service or null\n *\n * @example\n * const service = normalizeOpenId({\n *   f_type: \"Service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"open-id\",\n *   uid: \"uniqueDedupeKey\",\n *   method: \"data\",\n *   data: {\n *      profile: {\n *        name: \"Bob\",\n *        family_name: \"Builder\",\n *        given_name: \"Robert\",\n *        middle_name: \"the\",\n *        nickname: \"Bob the Builder\",\n *        preferred_username: \"bob\",\n *        profile: \"https://www.bobthebuilder.com/\",\n *        picture: \"https://avatars.onflow.org/avatar/bob\",\n *        gender: \"...\",\n *        birthday: \"2001-01-18\",\n *        zoneinfo: \"America/Vancouver\",\n *        locale: \"en-us\",\n *        updated_at: \"1614970797388\"\n *      },\n *      email: {\n *        email: \"bob@bob.bob\",\n *        email_verified: true\n *      },\n *      address: {\n *        address: \"One Apple Park Way, Cupertino, CA 95014, USA\"\n *      },\n *      phone: {\n *        phone_number: \"+1 (xxx) yyy-zzzz\",\n *        phone_number_verified: true\n *      },\n *      social: {\n *        twitter: \"@_qvvg\",\n *        twitter_verified: true\n *      },\n *   }\n * })\n */\nexport function normalizeOpenId(service: Service | null): Service | null {\n  if (service == null) return null\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import type {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Normalizes a user-signature service to ensure compatibility with FCL service format\n *\n * @param service The user-signature service to normalize\n * @returns The normalized user-signature service or null\n *\n * @example\n * const service = {\n *   \"f_type\": \"Service\",\n *   \"f_vsn\": \"1.0.0\",\n *   \"type\": \"user-signature\",\n *   \"uid\": \"uniqueDedupeKey\",\n *   \"endpoint\": \"https://rawr\",\n *   \"method\": \"IFRAME/RPC\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n *   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n *   \"data\": {}, // included in body of user-signature request\n *   \"params\": {}, // included as query params on endpoint url\n * }\n */\nexport function normalizeUserSignature(\n  service: Service | null\n): Service | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    throw new Error(\"Invalid user-signature service\")\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Normalizes an account-proof service to ensure compatibility with FCL service format\n *\n * @param service The account-proof service to normalize\n * @returns The normalized account-proof service or null\n *\n * @example\n * {\n *   \"f_type\": \"Service\",                    // Its a service!\n *   \"f_vsn\": \"1.0.0\",                       // Follows the v1.0.0 spec for the service\n *   \"type\": \"account-proof\",                // the type of service it is\n *   \"method\": \"DATA\",                       // Its data!\n *   \"uid\": \"awesome-wallet#account-proof\",  // A unique identifier for the service\n *   \"data\": {\n *     \"f_type\": \"account-proof\",\n *     \"f_vsn\": \"1.0.0\",\n *     \"nonce\": \"0A1BC2FF\",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)\n *     \"address\": \"0xUSER\",                  // The user's address (8 bytes, i.e 16 hex characters)\n *     \"signature\": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)\n * }\n */\nexport function normalizeAccountProof(service: Service | null): Service | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    throw new Error(`FCL Normalizer Error: Invalid account-proof service`)\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\n\nexport interface AuthnRefreshService extends Service {\n  id?: string\n  addr?: string\n  name?: string\n  icon?: string\n  authn?: string\n  pid?: string\n}\n\n/**\n * @description Normalizes an authn-refresh service to ensure compatibility with FCL service format\n *\n * @param service The authn-refresh service to normalize\n * @returns The normalized authn-refresh service or null\n *\n * @example\n * const service = normalizeAuthnRefresh({\n *   f_type: \"Service\",\n *   f_vsn: \"1.0.0\",\n *   type: \"authn-refresh\",\n *   uid: \"uniqueDedupeKey\",\n *   endpoint: \"https://rawr\",\n *   method: \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n *   id: \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n *   data: {}, // included in body of request\n *   params: {}, // included as query params on endpoint url\n * })\n */\nexport function normalizeAuthnRefresh(\n  service: AuthnRefreshService | null\n): AuthnRefreshService | null {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    throw new Error(\"Invalid authn-refresh service\")\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import * as semver from \"@onflow/util-semver\"\nimport {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Finds a service of a specific type from an array of services, returning the one with\n * the highest version number. This is used internally by FCL to select the most recent version\n * of a service when multiple services of the same type are available.\n *\n * @param services Array of services to search through\n * @param type The type of service to find (e.g., \"authn\", \"authz\", \"user-signature\")\n * @returns The service with the highest version number of the specified type, or null if none found\n *\n * @example\n * // Find the latest authentication service\n * const services = [\n *   { type: \"authn\", f_vsn: \"1.0.0\", endpoint: \"...\" },\n *   { type: \"authn\", f_vsn: \"1.1.0\", endpoint: \"...\" },\n *   { type: \"authz\", f_vsn: \"1.0.0\", endpoint: \"...\" }\n * ]\n * const latestAuthn = serviceOfType(services, \"authn\")\n */\nexport function serviceOfType(\n  services: Service[] = [],\n  type: string\n): Service | null {\n  // Find the greatest version of the service type\n  return services.reduce(\n    (mostRecent, service) =>\n      service.type === type\n        ? !mostRecent || semver.compare(service.f_vsn, mostRecent.f_vsn) > 0\n          ? service\n          : mostRecent\n        : mostRecent,\n    null as Service | null\n  )\n}\n","import * as rlp from \"@onflow/rlp\"\nimport {CurrentUser, Service} from \"@onflow/typedefs\"\nimport {withPrefix} from \"@onflow/util-address\"\nimport {USER_PRAGMA} from \"../normalizers/service/__vsn\"\nimport {normalizeServices} from \"../normalizers/service/service\"\nimport {fetchServices} from \"./fetch-services\"\nimport {mergeServices} from \"./merge-services\"\nimport {serviceOfType} from \"./service-of-type\"\n\nexport interface UserData {\n  addr: string | null\n  paddr?: string | null\n  services?: Service[]\n  hks?: string\n  code?: string\n  expires?: number\n  [key: string]: any\n}\n\nfunction deriveCompositeId(authn: Service): string {\n  return rlp\n    .encode([\n      authn.provider?.address || authn.provider?.name || \"UNSPECIFIED\",\n      (authn as any).id,\n    ])\n    .toString(\"hex\")\n}\n\nfunction normalizeData(data: UserData): UserData {\n  data.addr = data.addr ? withPrefix(data.addr) : null\n  data.paddr = data.paddr ? withPrefix(data.paddr) : null\n  return data\n}\n\n/**\n * @description Builds a complete CurrentUser object from user data by normalizing addresses,\n * fetching additional services, and creating a composite ID. This function handles the\n * construction of the user object that represents the authenticated state in FCL.\n *\n * @param data The user data containing address, services, and authentication information\n * @returns Promise resolving to a CurrentUser object with normalized data and services\n *\n * @example\n * // Build a user object from authentication data\n * const userData = {\n *   addr: \"0x1234567890abcdef\",\n *   services: [...],\n *   hks: \"https://wallet.example.com/hooks\",\n *   code: \"auth_code_123\"\n * }\n * const user = await buildUser(userData)\n * console.log(user.addr) // \"0x1234567890abcdef\"\n */\nexport async function buildUser(data: UserData): Promise<CurrentUser> {\n  data = normalizeData(data)\n\n  var services = normalizeServices(\n    mergeServices(\n      data.services || [],\n      await fetchServices(data.hks!, data.code!)\n    )\n  )\n\n  const authn = serviceOfType(services, \"authn\") as Service\n\n  return {\n    ...USER_PRAGMA,\n    addr: withPrefix(data.addr!),\n    cid: deriveCompositeId(authn),\n    loggedIn: true,\n    services: services,\n    expiresAt: data.expires,\n  }\n}\n","import {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Merges two arrays of services into a single array. This is a simple concatenation\n * operation used internally by FCL to combine service arrays from different sources.\n * The function handles undefined/null inputs gracefully by treating them as empty arrays.\n *\n * @param sx1 First array of services to merge\n * @param sx2 Second array of services to merge\n * @returns Combined array containing all services from both input arrays\n *\n * @example\n * // Merge wallet services with discovery services\n * const walletServices = [\n *   { type: \"authn\", endpoint: \"wallet1.com\" },\n *   { type: \"authz\", endpoint: \"wallet1.com\" }\n * ]\n * const discoveryServices = [\n *   { type: \"authn\", endpoint: \"wallet2.com\" }\n * ]\n * const allServices = mergeServices(walletServices, discoveryServices)\n */\nexport function mergeServices(\n  sx1: Service[] = [],\n  sx2: Service[] = []\n): Service[] {\n  // TODO: Make this smarter\n  return [...sx1, ...sx2]\n}\n","import {URL} from \"../utils/url\"\nimport {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Fetches additional services from a remote endpoint using an authorization code.\n * This function handles both modern service arrays and legacy wallet provider formats for\n * backward compatibility.\n *\n * @param servicesURL The URL endpoint to fetch services from\n * @param code The authorization code to include in the request\n * @returns Promise resolving to an array of Service objects\n *\n * @example\n * // Fetch services from a wallet provider\n * const services = await fetchServices(\n *   \"https://wallet.example.com/services\",\n *   \"auth_code_123\"\n * )\n */\nexport async function fetchServices(\n  servicesURL: string | null,\n  code: string | null\n): Promise<Service[]> {\n  if (servicesURL == null || code == null) return []\n\n  const url = new URL(servicesURL)\n  url.searchParams.append(\"code\", code)\n\n  const resp: any = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  }).then(d => d.json())\n\n  if (Array.isArray(resp)) return resp\n\n  // Backwards compatibility for First-Gen Wallet Providers\n  const services: Service[] = []\n\n  // Convert authorizations into authz services\n  if (Array.isArray(resp.authorizations)) {\n    for (let service of resp.authorizations) {\n      services.push({\n        type: \"authz\",\n        keyId: resp.keyId,\n        ...service,\n      })\n    }\n  }\n\n  // Convert Provider info into an authn service\n  if (resp.provider != null) {\n    services.push({\n      type: \"authn\",\n      id: \"wallet-provider#authn\",\n      ...resp.provider,\n    })\n  }\n\n  return services\n}\n","import * as logger from \"@onflow/util-logger\"\nimport {getServiceRegistry} from \"./plugins\"\n\nconst FCL_WC_SERVICE_METHOD = \"WC/RPC\"\n\nconst isServerSide = typeof window === \"undefined\"\n\n/**\n * @description Checks if WalletConnect service plugin is enabled and logs a warning if it's not.\n * This function verifies that the WalletConnect strategy is registered in the service registry.\n * It's called internally by FCL to notify developers about missing WalletConnect configuration,\n * which is required for users to connect with certain wallets.\n *\n * @example\n * // This function is called automatically by FCL, but can be used manually:\n * checkWalletConnectEnabled()\n * // If WalletConnect is not configured, an error will be logged to the console\n *\n * // To properly configure WalletConnect to avoid the warning:\n * import * as fcl from \"@onflow/fcl\"\n *\n * fcl.config({\n *   \"app.detail.title\": \"My App\",\n *   \"walletconnect.projectId\": \"your-walletconnect-project-id\"\n * })\n */\n// Utility to notify the user if the Walletconnect service plugin has not been loaded\nexport function checkWalletConnectEnabled() {\n  if (isServerSide) return\n\n  const serviceRegistry = getServiceRegistry()\n  const strategies = serviceRegistry.getStrategies()\n\n  if (!strategies.includes(FCL_WC_SERVICE_METHOD)) {\n    logger.log({\n      title: \"FCL WalletConnect Service Plugin\",\n      level: logger.LEVELS.error,\n      message:\n        \"All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information.\",\n    })\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\nimport {getServiceRegistry} from \"./plugins\"\nimport {createGetChainId} from \"../../utils\"\nimport {VERSION} from \"../../VERSION\"\nimport {configLens} from \"../../default-config\"\nimport {checkWalletConnectEnabled} from \"./wc-check\"\nimport {Service, CurrentUser} from \"@onflow/typedefs\"\nimport {FCLContext} from \"../../context\"\n\nconst AbortController =\n  globalThis.AbortController || require(\"abort-controller\")\n\nexport interface ExecStrategyParams {\n  service: Service\n  body: Record<string, any>\n  config: ExecConfig\n  abortSignal: AbortSignal\n  customRpc?: string\n  user?: CurrentUser\n  opts?: Record<string, any>\n}\n\nexport interface ExecServiceParams {\n  service: Service\n  msg?: Record<string, any>\n  config?: Record<string, any>\n  opts?: Record<string, any>\n  platform?: string\n  abortSignal?: AbortSignal\n  execStrategy?: (params: ExecStrategyParams) => Promise<StrategyResponse>\n  user?: CurrentUser\n}\n\nexport interface StrategyResponse {\n  status: string\n  data?: any\n  updates?: Record<string, any>\n  local?: boolean\n  authorizationUpdates?: Record<string, any>\n}\n\nexport interface ExecConfig {\n  services: Record<string, any>\n  app: Record<string, any>\n  client: {\n    platform?: string\n    fclVersion: string\n    fclLibrary: string\n    hostname: string | null\n    network: string\n    [key: string]: any\n  }\n}\n\nexport type StrategyFunction = (\n  params: ExecStrategyParams\n) => Promise<StrategyResponse>\n\n/**\n * @description Executes a service strategy based on the service method. This function looks up the\n * appropriate strategy from the service registry and executes it with the provided parameters.\n * It's used internally by FCL to handle different communication methods with wallet services.\n *\n * @param params The parameters object containing service details and execution context\n * @returns Promise resolving to the strategy response\n *\n * @example\n * // Execute a service strategy (internal usage)\n * const response = await execStrategy({\n *   service: { method: \"HTTP/POST\", endpoint: \"https://wallet.example.com/authz\" },\n *   body: { transaction: \"...\" },\n *   config: execConfig,\n *   abortSignal: controller.signal\n * })\n */\nexport const execStrategy = async ({\n  service,\n  body,\n  config,\n  abortSignal,\n  customRpc,\n  user,\n  opts,\n}: ExecStrategyParams): Promise<StrategyResponse> => {\n  const strategy = getServiceRegistry().getStrategy(\n    service.method\n  ) as StrategyFunction\n  return strategy({service, body, config, abortSignal, customRpc, opts, user})\n}\n\n/**\n * @description Executes a service with the provided parameters, handling configuration setup,\n * error handling, and recursive service redirects. This is the main entry point for executing\n * wallet service interactions in FCL.\n *\n * @param params The service execution parameters including service, message, and configuration\n * @returns Promise resolving to a StrategyResponse containing the execution result\n *\n * @example\n * // Execute a service (internal usage)\n * const response = await execService({\n *   service: { type: \"authz\", method: \"HTTP/POST\", endpoint: \"...\" },\n *   msg: { transaction: \"...\" },\n *   config: { client: { platform: \"web\" } }\n * })\n */\nexport async function execService(\n  context: Pick<FCLContext, \"config\" | \"sdk\">,\n  {\n    service,\n    msg = {},\n    config = {},\n    opts = {},\n    platform,\n    abortSignal = new AbortController().signal,\n    execStrategy: _execStrategy,\n    user,\n  }: ExecServiceParams\n): Promise<StrategyResponse> {\n  // Notify the developer if WalletConnect is not enabled\n  checkWalletConnectEnabled()\n\n  msg.data = service.data\n  const execConfig: ExecConfig = {\n    services: await configLens(context, /^service\\./),\n    app: await configLens(context, /^app\\.detail\\./),\n    client: {\n      ...config.client,\n      platform,\n      fclVersion: VERSION,\n      fclLibrary: \"https://github.com/onflow/fcl-js\",\n      hostname: window?.location?.hostname ?? null,\n      network: await createGetChainId(context)(opts),\n    },\n  }\n\n  try {\n    const res = await (_execStrategy || execStrategy)({\n      service,\n      body: msg,\n      config: execConfig,\n      opts,\n      user,\n      abortSignal,\n    })\n\n    if (res.status === \"REDIRECT\") {\n      invariant(\n        service.type === res.data.type,\n        \"Cannot shift recursive service type in execService\"\n      )\n      return await execService(context, {\n        service: res.data,\n        msg,\n        config: execConfig,\n        opts,\n        abortSignal,\n        platform,\n        user,\n      })\n    } else {\n      return res\n    }\n  } catch (error: any) {\n    log({\n      title: `Error on execService ${service?.type}`,\n      message: error,\n      level: LEVELS.error,\n    })\n    throw error\n  }\n}\n","import {config} from \"@onflow/config\"\nimport {arg, Signable, t} from \"@onflow/sdk\"\nimport {\n  Account,\n  CompositeSignature,\n  CurrentUser,\n  Service,\n} from \"@onflow/typedefs\"\nimport {\n  ActorContext,\n  INIT,\n  Letter,\n  send,\n  spawn,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n} from \"@onflow/util-actor\"\nimport {sansPrefix, withPrefix} from \"@onflow/util-address\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {LEVELS, log} from \"@onflow/util-logger\"\nimport \"../default-config\"\nimport {getDiscoveryService, makeDiscoveryServices} from \"../discovery\"\nimport {normalizeCompositeSignature} from \"../normalizers/service/composite-signature\"\nimport {StorageProvider} from \"../utils/storage\"\nimport {buildUser} from \"./build-user\"\nimport {execService} from \"./exec-service\"\nimport {getServiceRegistry} from \"./exec-service/plugins\"\nimport {serviceOfType} from \"./service-of-type\"\nimport {createPartialGlobalFCLContext} from \"../context/global\"\nimport {FCLContext} from \"../context\"\nimport {v4 as uuidv4} from \"uuid\"\n\nexport interface CurrentUserConfig {\n  platform: string\n  discovery?: {\n    execStrategy?: (...args: any[]) => any\n  }\n  getStorageProvider: () => Promise<StorageProvider>\n}\n\nexport interface CurrentUserContext extends Pick<FCLContext, \"config\" | \"sdk\"> {\n  platform: string\n  getStorageProvider: () => Promise<StorageProvider>\n  discovery?: {\n    execStrategy?: (...args: any[]) => any\n  }\n  actorName: string\n}\n\nexport interface CurrentUserServiceApi {\n  authenticate: (opts?: AuthenticationOptions) => Promise<CurrentUser>\n  unauthenticate: () => void\n  authorization: (account: Account) => Promise<Account>\n  signUserMessage: (msg: string) => Promise<CompositeSignature[]>\n  subscribe: (callback: (user: CurrentUser) => void) => () => void\n  snapshot: () => Promise<CurrentUser>\n  resolveArgument: () => Promise<string>\n}\n\nexport interface CurrentUserService extends CurrentUserServiceApi {\n  (): CurrentUserServiceApi\n}\n\nexport interface AccountProofData {\n  appIdentifier: string\n  nonce: string\n  [key: string]: any\n}\n\nexport interface AuthenticationOptions {\n  service?: Service\n  redir?: boolean\n  forceReauth?: boolean\n}\n\nexport interface MakeConfigOptions {\n  discoveryAuthnInclude?: string[]\n  discoveryAuthnExclude?: string[]\n  discoveryFeaturesSuggested?: string[]\n}\n\n/**\n * @description Type guard function that checks if a value is a function. This is a simple utility\n * used internally by FCL for type checking and validation.\n *\n * @param d The value to check\n * @returns True if the value is a function, false otherwise\n *\n * @example\n * // Check if a value is a function\n * const callback = () => console.log(\"Hello\")\n * const notCallback = \"string\"\n *\n * console.log(isFn(callback)) // true\n * console.log(isFn(notCallback)) // false\n */\nexport const isFn = (d: any): boolean => typeof d === \"function\"\n\nconst NAME = \"CURRENT_USER\"\nconst UPDATED = \"CURRENT_USER/UPDATED\"\nconst SNAPSHOT = \"SNAPSHOT\"\nconst SET_CURRENT_USER = \"SET_CURRENT_USER\"\nconst DEL_CURRENT_USER = \"DEL_CURRENT_USER\"\n\nconst DATA = `{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}`\n\nconst getStoredUser = async (storage: StorageProvider): Promise<any> => {\n  const fallback = JSON.parse(DATA)\n  const stored = await storage.get(NAME)\n  if (stored != null && fallback[\"f_vsn\"] !== stored[\"f_vsn\"]) {\n    storage.removeItem(NAME)\n    return fallback\n  }\n  return stored || fallback\n}\n\nconst makeHandlers = (context: CurrentUserContext) => {\n  // Wrapper for backwards compatibility\n  const getStorageProvider = async (): Promise<StorageProvider> => {\n    if (context.getStorageProvider) return await context.getStorageProvider()\n    return (await context.config.first(\n      [\"fcl.storage\", \"fcl.storage.default\"],\n      undefined\n    )) as any\n  }\n\n  return {\n    [INIT]: async (ctx: ActorContext) => {\n      if (typeof window === \"undefined\") {\n        console.warn(\n          `\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        `,\n          \"font-weight:bold;font-family:monospace;\"\n        )\n      }\n\n      ctx.merge(JSON.parse(DATA))\n      const storage = await getStorageProvider()\n      if (storage.can) {\n        const user = await getStoredUser(storage)\n        if (notExpired(user)) ctx.merge(user)\n      }\n    },\n    [SUBSCRIBE]: (ctx: ActorContext, letter: Letter) => {\n      ctx.subscribe(letter.from)\n      ctx.send(letter.from, UPDATED, {...ctx.all()})\n    },\n    [UNSUBSCRIBE]: (ctx: ActorContext, letter: Letter) => {\n      ctx.unsubscribe(letter.from)\n    },\n    [SNAPSHOT]: async (ctx: ActorContext, letter: Letter) => {\n      letter.reply({...ctx.all()})\n    },\n    [SET_CURRENT_USER]: async (\n      ctx: ActorContext,\n      letter: Letter,\n      data: any\n    ) => {\n      ctx.merge(data)\n      const storage = await getStorageProvider()\n      if (storage.can) storage.put(NAME, ctx.all())\n      ctx.broadcast(UPDATED, {...ctx.all()})\n    },\n    [DEL_CURRENT_USER]: async (ctx: ActorContext, letter: Letter) => {\n      ctx.merge(JSON.parse(DATA))\n      const storage = await getStorageProvider()\n      if (storage.can) storage.put(NAME, ctx.all())\n      ctx.broadcast(UPDATED, {...ctx.all()})\n    },\n  }\n}\n\nconst spawnCurrentUser = (context: CurrentUserContext) => {\n  spawn(makeHandlers(context), context.actorName)\n}\n\nfunction notExpired(user: any): boolean {\n  return (\n    user.expiresAt == null ||\n    user.expiresAt === 0 ||\n    user.expiresAt > Date.now()\n  )\n}\n\nasync function getAccountProofData(\n  context: Pick<FCLContext, \"config\">\n): Promise<AccountProofData | undefined> {\n  let accountProofDataResolver: any = await context.config.get(\n    \"fcl.accountProof.resolver\"\n  )\n  if (accountProofDataResolver == null) return\n  if (!isFn(accountProofDataResolver)) {\n    log({\n      title: \"Account Proof Data Resolver must be a function\",\n      message: `Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}\n                `,\n      level: LEVELS.warn,\n    })\n    return\n  }\n\n  const accountProofData = {...(await accountProofDataResolver())}\n\n  const origin: any = window?.location?.origin\n\n  if (accountProofData.appIdentifier) {\n    if (origin) {\n      log.deprecate({\n        pkg: \"FCL\",\n        subject: \"appIdentifier in fcl.accountProof.resolver\",\n        message:\n          \"Manually set app identifiers in the account proof resolver function are now deprecated.  These are now automatically set to the application origin URL by FCL\",\n        transition:\n          \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-appIdentifier-field-in-account-proof-resolver\",\n      })\n\n      invariant(\n        typeof accountProofData.appIdentifier === \"string\",\n        \"appIdentifier must be a string\"\n      )\n    }\n  } else {\n    invariant(\n      origin,\n      \"The appIdentifier (origin) could not be inferred from the window.location.origin.  Please set the appIdentifier manually in the fcl.accountProof.resolver function.\"\n    )\n\n    accountProofData.appIdentifier = origin\n  }\n\n  invariant(\n    /^[0-9a-f]+$/i.test(accountProofData.nonce),\n    \"Nonce must be a hex string\"\n  )\n\n  return accountProofData\n}\n\nconst makeConfig = async ({\n  discoveryAuthnInclude,\n  discoveryAuthnExclude,\n  discoveryFeaturesSuggested,\n}: MakeConfigOptions): Promise<Record<string, any>> => {\n  return {\n    client: {\n      discoveryAuthnInclude,\n      discoveryAuthnExclude,\n      discoveryFeaturesSuggested,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies(),\n    },\n  }\n}\n\n/**\n * @description Factory function to create the authenticate method\n * @param config Current User Configuration\n */\nconst createAuthenticate =\n  (context: CurrentUserContext) =>\n  /**\n   * @description Calling this method will authenticate the current user via any wallet that supports FCL. Once called, FCL will initiate communication with the configured `discovery.wallet` endpoint which lets the user select a wallet to authenticate with. Once the wallet provider has authenticated the user, FCL will set the values on the current user object for future use and authorization.\n   *\n   * This method can only be used in web browsers.\n   *\n   * `discovery.wallet` value must be set in the configuration before calling this method. See FCL Configuration.\n   *\n   * The default discovery endpoint will open an iframe overlay to let the user choose a supported wallet.\n   *\n   * `authenticate` can also take a service returned from discovery with `fcl.authenticate(\\{ service \\})`.\n   *\n   * @param opts Authentication options\n   * @param opts.service Optional service to use for authentication. A service returned from discovery can be passed here.\n   * @param opts.redir Optional redirect flag. Defaults to false.\n   * @param opts.forceReauth Optional force re-authentication flag. Defaults to false.\n   * @returns Promise that resolves to the authenticated CurrentUser object or undefined\n   *\n   * @example\n   * import * as fcl from '@onflow/fcl';\n   * fcl\n   *   .config()\n   *   .put('accessNode.api', 'https://rest-testnet.onflow.org')\n   *   .put('discovery.wallet', 'https://fcl-discovery.onflow.org/testnet/authn');\n   * // anywhere on the page\n   * fcl.authenticate();\n   */\n  async ({\n    service,\n    redir = false,\n    forceReauth = false,\n  }: AuthenticationOptions = {}): Promise<CurrentUser | undefined> => {\n    if (\n      service &&\n      !service?.provider?.is_installed &&\n      service?.provider?.requires_install\n    ) {\n      window.location.href = service?.provider?.install_link!\n      return\n    }\n\n    return new Promise(async (resolve, reject) => {\n      spawnCurrentUser(context)\n      const opts = {redir}\n      const user = await createSnapshot(context)()\n      const refreshService = serviceOfType(user.services, \"authn-refresh\")\n      let accountProofData\n\n      if (user.loggedIn && !forceReauth) {\n        if (refreshService) {\n          try {\n            const response: any = await execService(context, {\n              service: refreshService,\n              msg: accountProofData,\n              opts,\n              platform: context.platform,\n              user,\n            })\n            send(context.actorName, SET_CURRENT_USER, await buildUser(response))\n          } catch (error: any) {\n            log({\n              title: `${error.name} Could not refresh wallet authentication.`,\n              message: error.message,\n              level: LEVELS.error,\n            })\n          } finally {\n            return resolve(await createSnapshot(context)())\n          }\n        } else {\n          return resolve(user)\n        }\n      }\n\n      try {\n        accountProofData = await getAccountProofData(context)\n      } catch (error: any) {\n        log({\n          title: `${error.name} On Authentication: Could not resolve account proof data.`,\n          message: error.message,\n          level: LEVELS.error,\n        })\n        return reject(error)\n      }\n\n      try {\n        const discoveryService = await getDiscoveryService(context, service)\n        const response: any = await execService(context, {\n          service: discoveryService,\n          msg: accountProofData,\n          config: await makeConfig(discoveryService),\n          opts,\n          platform: context.platform,\n          execStrategy: context.discovery?.execStrategy,\n          user,\n        })\n\n        send(context.actorName, SET_CURRENT_USER, await buildUser(response))\n      } catch (error: any) {\n        log({\n          title: `${error} On Authentication`,\n          message: error,\n          level: LEVELS.error,\n        })\n      } finally {\n        resolve(await createSnapshot(context)())\n      }\n    })\n  }\n\n/**\n * @description Factory function to create the unauthenticate method\n * @param config Current User Configuration\n */\nfunction createUnauthenticate(context: CurrentUserContext) {\n  /**\n   * @description Logs out the current user and sets the values on the current user object to null.\n   *\n   * This method can only be used in web browsers.\n   *\n   * The current user must be authenticated first.\n   *\n   * @example\n   * import * as fcl from '@onflow/fcl';\n   * fcl.config().put('accessNode.api', 'https://rest-testnet.onflow.org');\n   * // first authenticate to set current user\n   * fcl.authenticate();\n   * // ... somewhere else & sometime later\n   * fcl.unauthenticate();\n   * // fcl.currentUser.loggedIn === null\n   */\n  return function unauthenticate() {\n    spawnCurrentUser(context)\n    send(context.actorName, DEL_CURRENT_USER)\n  }\n}\n\nconst normalizePreAuthzResponse = (authz: any) => ({\n  f_type: \"PreAuthzResponse\",\n  f_vsn: \"1.0.0\",\n  proposer: (authz || {}).proposer,\n  payer: (authz || {}).payer || [],\n  authorization: (authz || {}).authorization || [],\n})\n\n/**\n * @description Factory function to create the resolvePreAuthz method\n * @param config Current User Configuration\n */\nconst createResolvePreAuthz =\n  (context: CurrentUserContext) =>\n  (authz: any, {user}: {user: CurrentUser}) => {\n    const resp = normalizePreAuthzResponse(authz)\n    const axs = []\n\n    if (resp.proposer != null) axs.push([\"PROPOSER\", resp.proposer])\n    for (let az of resp.payer || []) axs.push([\"PAYER\", az])\n    for (let az of resp.authorization || []) axs.push([\"AUTHORIZER\", az])\n\n    var result = axs.map(([role, az]) => ({\n      tempId: [az.identity.address, az.identity.keyId].join(\"|\"),\n      addr: az.identity.address,\n      keyId: az.identity.keyId,\n      signingFunction(signable: Signable) {\n        return execService(context, {\n          service: az,\n          msg: signable,\n          platform: context.platform,\n          user,\n        })\n      },\n      role: {\n        proposer: role === \"PROPOSER\",\n        payer: role === \"PAYER\",\n        authorizer: role === \"AUTHORIZER\",\n      },\n    }))\n    return result\n  }\n\n/**\n * @description Factory function to create the authorization method\n * @param config Current User Configuration\n */\nconst createAuthorization =\n  (context: CurrentUserContext) =>\n  /**\n   * @description Produces the needed authorization details for the current user to submit transactions to Flow\n   * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.\n   *\n   * @param account Account object\n   * @returns Account object with signing function\n   * */\n  async (account: Account) => {\n    spawnCurrentUser(context)\n\n    return {\n      ...account,\n      tempId: \"CURRENT_USER\",\n      async resolve(account: Account, preSignable: Signable) {\n        const user = await createAuthenticate(context)({redir: true})\n        const authz = serviceOfType(user!.services, \"authz\")\n        const preAuthz = serviceOfType(user!.services, \"pre-authz\")\n\n        if (preAuthz)\n          return createResolvePreAuthz(context)(\n            await execService(context, {\n              service: preAuthz,\n              msg: preSignable,\n              platform: context.platform,\n              user,\n            }),\n            {\n              user: user!,\n            }\n          )\n        if (authz) {\n          return {\n            ...account,\n            tempId: \"CURRENT_USER\",\n            resolve: null,\n            addr: sansPrefix((authz as any).identity.address),\n            keyId: (authz as any).identity.keyId,\n            sequenceNum: null,\n            signature: null,\n            async signingFunction(signable: Signable) {\n              return normalizeCompositeSignature(\n                await execService(context, {\n                  service: authz,\n                  msg: signable,\n                  opts: {\n                    includeOlderJsonRpcCall: true,\n                  },\n                  platform: context.platform,\n                  user,\n                })\n              )\n            },\n          }\n        }\n        throw new Error(\n          \"No Authz or PreAuthz Service configured for CURRENT_USER\"\n        )\n      },\n    }\n  }\n\n/**\n * @description Factory function to create the subscribe method\n * @param context Current User Context\n */\nfunction createSubscribe(context: CurrentUserContext) {\n  /**\n   * @description The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.\n   *\n   * @param callback The callback will be called with the current user as the first argument when the current user is set or removed.\n   * @returns Function to unsubscribe from user state changes\n   *\n   * @example\n   * import React, { useState, useEffect } from 'react';\n   * import * as fcl from '@onflow/fcl';\n   *\n   * export function AuthCluster() {\n   *   const [user, setUser] = useState({ loggedIn: null });\n   *   useEffect(() => fcl.currentUser.subscribe(setUser), []); // sets the callback for FCL to use\n   *\n   *   if (user.loggedIn) {\n   *     return (\n   *       <div>\n   *         <span>{user?.addr ?? 'No Address'}</span>\n   *         <button onClick={fcl.unauthenticate}>Log Out</button>\n   *       </div>\n   *     );\n   *   } else {\n   *     return (\n   *       <div>\n   *         <button onClick={fcl.logIn}>Log In</button>{' '}\n   *         <button onClick={fcl.signUp}>Sign Up</button>\n   *       </div>\n   *     );\n   *   }\n   * }\n   */\n  return function subscribe(callback: (user: CurrentUser) => void) {\n    spawnCurrentUser(context)\n    const EXIT = \"@EXIT\"\n    const self = spawn(async ctx => {\n      ctx.send(context.actorName, SUBSCRIBE)\n      while (1) {\n        const letter = await ctx.receive()\n        if (letter.tag === EXIT) {\n          ctx.send(context.actorName, UNSUBSCRIBE)\n          return\n        }\n        callback(letter.data)\n      }\n    })\n    return () => send(self, EXIT)\n  }\n}\n\n/**\n * @description Factory function to create the snapshot method\n * @param context Current User Context\n */\nfunction createSnapshot(\n  context: CurrentUserContext\n): () => Promise<CurrentUser> {\n  /**\n   * @description Returns the current user object. This is the same object that is set and available on `fcl.currentUser.subscribe(callback)`.\n   *\n   * @returns Promise that resolves to the current user object\n   *\n   * @example\n   * // returns the current user object\n   * const user = fcl.currentUser.snapshot();\n   *\n   * // subscribes to the current user object and logs to console on changes\n   * fcl.currentUser.subscribe(console.log);\n   */\n  return function snapshot() {\n    spawnCurrentUser(context)\n    return send(context.actorName, SNAPSHOT, null, {\n      expectReply: true,\n      timeout: 0,\n    })\n  }\n}\n\n/**\n * @description Resolves the current user as an argument\n * @param config Current User Configuration\n */\nconst createResolveArgument = (config: CurrentUserContext) => async () => {\n  const {addr} = (await createAuthenticate(config)()) as any\n  return arg(withPrefix(addr) as any, t.Address)\n}\n\nconst makeSignable = (msg: string) => {\n  invariant(/^[0-9a-f]+$/i.test(msg), \"Message must be a hex string\")\n\n  return {\n    message: msg,\n  }\n}\n\n/**\n * @description Factory function to create the signUserMessage method\n * @param config Current User Configuration\n */\nconst createSignUserMessage =\n  (context: CurrentUserContext) =>\n  /**\n   * @description A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.\n   *\n   * This method requires the current user's wallet to support a signing service endpoint. Currently, only Blocto is compatible with this feature by default.\n   *\n   * @param msg A hexadecimal string to be signed\n   * @returns An Array of CompositeSignatures: \\{`addr`, `keyId`, `signature`\\}\n   *\n   * @example\n   * import * as fcl from '@onflow/fcl';\n   *\n   * export const signMessage = async () => {\n   *   const MSG = Buffer.from('FOO').toString('hex');\n   *   try {\n   *     return await currentUser.signUserMessage(MSG);\n   *   } catch (error) {\n   *     console.log(error);\n   *   }\n   * };\n   */\n  async (msg: string) => {\n    spawnCurrentUser(context)\n    const user: any = await createAuthenticate(context)({\n      redir: true,\n    })\n\n    const signingService = serviceOfType(user.services, \"user-signature\")\n\n    invariant(\n      signingService as any,\n      \"Current user must have authorized a signing service.\"\n    )\n\n    try {\n      const response = await execService(context, {\n        service: signingService as any,\n        msg: makeSignable(msg),\n        platform: context.platform,\n        user,\n      })\n      if (Array.isArray(response)) {\n        return response.map(compSigs => normalizeCompositeSignature(compSigs))\n      } else {\n        return [normalizeCompositeSignature(response)]\n      }\n    } catch (error) {\n      return error\n    }\n  }\n\nconst _createUser = (context: CurrentUserContext): CurrentUserService => {\n  const currentUser = {\n    authenticate: createAuthenticate(context),\n    unauthenticate: createUnauthenticate(context),\n    authorization: createAuthorization(context),\n    signUserMessage: createSignUserMessage(context),\n    subscribe: createSubscribe(context),\n    snapshot: createSnapshot(context),\n    resolveArgument: createResolveArgument(context),\n  }\n\n  return Object.assign(\n    () => {\n      return {...currentUser}\n    },\n    {...currentUser}\n  ) as any\n}\n\nconst createUser = (\n  context: Pick<FCLContext, \"config\" | \"sdk\" | \"storage\"> & {\n    platform: string\n    discovery?: {\n      execStrategy?: (...args: any[]) => any\n    }\n  }\n) => {\n  return _createUser({\n    ...context,\n    getStorageProvider: async () => context.storage,\n    discovery: context.discovery,\n    actorName: `${NAME}_${uuidv4()}`,\n  })\n}\n\n/**\n * @description Creates and configures the Current User service for managing user authentication and\n * authorization in Flow applications. This is the core service for handling user sessions, wallet\n * connections, transaction signing, and user data management. The service provides both callable\n * function interface and object methods for maximum flexibility.\n *\n * @param config Configuration object for the current user service\n * @param config.platform Platform identifier (e.g., \"web\", \"mobile\", \"extension\")\n * @param config.discovery Optional discovery configuration for wallet services\n * @param config.getStorageProvider Optional function to provide custom storage implementation\n *\n * @returns Current user service object with authentication and authorization methods\n *\n * @example\n * // Basic setup and authentication\n * import * as fcl from \"@onflow/fcl\"\n *\n * // Configure FCL\n * fcl.config({\n *   \"accessNode.api\": \"https://rest-testnet.onflow.org\",\n *   \"discovery.wallet\": \"https://fcl-discovery.onflow.org/testnet/authn\"\n * })\n *\n * // Create current user service\n * const currentUser = fcl.getCurrentUser({\n *   platform: \"web\"\n * })\n *\n * // Authenticate user\n * const user = await currentUser.authenticate()\n * console.log(\"Authenticated user:\", user.addr)\n *\n * // Subscribe to authentication state changes\n * const currentUser = fcl.getCurrentUser({ platform: \"web\" })\n *\n * const unsubscribe = currentUser.subscribe((user) => {\n *   if (user.loggedIn) {\n *     console.log(\"User logged in:\", user.addr)\n *     document.getElementById(\"login-btn\").style.display = \"none\"\n *     document.getElementById(\"logout-btn\").style.display = \"block\"\n *   } else {\n *     console.log(\"User logged out\")\n *     document.getElementById(\"login-btn\").style.display = \"block\"\n *     document.getElementById(\"logout-btn\").style.display = \"none\"\n *   }\n * })\n *\n * // Clean up subscription\n * window.addEventListener(\"beforeunload\", () => unsubscribe())\n *\n * // Sign transactions with user authorization\n * const currentUser = fcl.getCurrentUser({ platform: \"web\" })\n *\n * const txId = await fcl.mutate({\n *   cadence: `\n *     transaction(amount: UFix64, to: Address) {\n *       prepare(signer: AuthAccount) {\n *         // Transfer tokens logic here\n *       }\n *     }\n *   `,\n *   args: (arg, t) => [\n *     arg(\"10.0\", t.UFix64),\n *     arg(\"0x01\", t.Address)\n *   ],\n *   authz: currentUser.authorization\n * })\n *\n * // Sign custom messages\n * const currentUser = fcl.getCurrentUser({ platform: \"web\" })\n *\n * const message = Buffer.from(\"Hello, Flow!\").toString(\"hex\")\n * const signatures = await currentUser.signUserMessage(message)\n *\n * console.log(\"Message signatures:\", signatures)\n */\nconst getCurrentUser = (cfg: CurrentUserConfig): CurrentUserService => {\n  const partialContext = createPartialGlobalFCLContext()\n\n  // Wrapper for backwards compatibility\n  const getStorageProvider = async (): Promise<StorageProvider> => {\n    if (cfg.getStorageProvider) return await cfg.getStorageProvider()\n    return (await config.first(\n      [\"fcl.storage\", \"fcl.storage.default\"],\n      undefined\n    )) as any\n  }\n\n  return _createUser({\n    ...partialContext,\n    getStorageProvider,\n    platform: cfg.platform,\n    actorName: NAME,\n    discovery: cfg.discovery,\n  })\n}\n\nexport {createUser, getCurrentUser}\n","import {URL} from \"../../../../utils/url\"\nimport {Service} from \"@onflow/typedefs\"\n\n/**\n * @description Creates a URL object from a service endpoint with additional parameters including\n * the application origin and service-specific parameters. This function is used internally by\n * FCL strategies to construct the complete URL for service communication.\n *\n * @param service The service object containing endpoint and optional parameters\n * @returns URL object with all parameters appended as query string parameters\n *\n * @example\n * // Create URL from service\n * const service = {\n *   endpoint: \"https://wallet.example.com/authn\",\n *   params: {\n *     appName: \"MyApp\",\n *     nonce: \"abc123\"\n *   }\n * }\n * const url = serviceEndpoint(service)\n * console.log(url.toString())\n * // https://wallet.example.com/authn?l6n=https://myapp.com&appName=MyApp&nonce=abc123\n */\nexport function serviceEndpoint(service: Service): URL {\n  const url = new URL(service.endpoint)\n  if (window?.location?.origin) {\n    url.searchParams.append(\"l6n\", window.location.origin)\n  }\n  if (service.params != null) {\n    for (let [key, value] of Object.entries(service.params || {})) {\n      url.searchParams.append(key, value)\n    }\n  }\n  return url\n}\n","import {Service} from \"@onflow/typedefs\"\nimport {serviceEndpoint} from \"./service-endpoint\"\n\nexport interface FetchServiceOptions {\n  method?: \"GET\" | \"POST\"\n  data?: Record<string, any>\n  headers?: Record<string, string>\n}\n\n/**\n * @description Makes an HTTP request to a service endpoint with the specified options.\n * This utility function handles the common patterns for communicating with wallet services\n * including proper headers, body serialization, and JSON response parsing.\n *\n * @param service The service configuration containing endpoint and headers\n * @param opts Optional request configuration including method, data, and headers\n * @returns Promise resolving to the parsed JSON response\n *\n * @example\n * // Fetch from a service endpoint\n * const response = await fetchService(service, {\n *   method: \"POST\",\n *   data: { transaction: \"...\" },\n *   headers: { \"Authorization\": \"Bearer token\" }\n * })\n */\nexport function fetchService(\n  service: Service,\n  opts: FetchServiceOptions = {}\n): Promise<any> {\n  const method = opts.method || \"POST\"\n  const body =\n    method === \"GET\"\n      ? undefined\n      : JSON.stringify(opts.data || service.data || {})\n\n  return fetch(serviceEndpoint(service), {\n    method: method,\n    headers: {\n      ...(service.headers || {}),\n      ...(opts.headers || {}),\n      \"Content-Type\": \"application/json\",\n    },\n    body: body,\n  }).then(d => d.json())\n}\n","import {CompositeSignature} from \"@onflow/typedefs\"\nimport {POLLING_RESPONSE_PRAGMA} from \"./__vsn\"\nimport {normalizeBackChannelRpc} from \"./back-channel-rpc\"\nimport {normalizeFrame} from \"./frame\"\n\nexport interface PollingResponse {\n  f_type: \"PollingResponse\"\n  f_vsn: \"1.0.0\"\n  status: \"PENDING\" | \"APPROVED\" | \"DECLINED\" | \"REDIRECT\"\n  reason: string | null\n  compositeSignature?: CompositeSignature\n  authorizationUpdates?: any\n  local: any\n  data?: any\n  updates?: any\n}\n\n/**\n * @description Normalizes a polling response to ensure compatibility with FCL format\n *\n * @param resp The polling response to normalize\n * @returns The normalized polling response or null\n *\n * @example\n * const resp = normalizePollingResponse({\n *   f_type: \"PollingResponse\",\n *   f_vsn: \"1.0.0\",\n *   status: \"PENDING\", // PENDING | APPROVED | DECLINED | REDIRECT\n *   reason: null,      // Reason for Declining Transaction\n *   data: null,        // Return value for APPROVED\n *   updates: BackChannelRpc,\n *   local: Frame,\n * })\n */\nexport function normalizePollingResponse(\n  resp: PollingResponse | null\n): PollingResponse | null {\n  if (resp == null) return null\n\n  if (!resp[\"f_vsn\"]) {\n    return {\n      ...POLLING_RESPONSE_PRAGMA,\n      status: resp.status ?? \"APPROVED\",\n      reason: resp.reason ?? null,\n      data: resp.compositeSignature || resp.data || {...resp} || {},\n      updates: normalizeBackChannelRpc(resp.authorizationUpdates),\n      local: normalizeFrame((resp.local || [])[0]),\n    } as PollingResponse\n  }\n\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp\n\n    default:\n      return null\n  }\n}\n","import {normalizePollingResponse} from \"../../../../normalizers/service/polling-response\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {fetchService} from \"./fetch-service\"\nimport {Service} from \"@onflow/typedefs\"\n\nexport interface ServiceMethodOptions {\n  \"HTTP/GET\": \"GET\"\n  \"HTTP/POST\": \"POST\"\n}\n\nconst OPTIONS: ServiceMethodOptions = {\n  \"HTTP/GET\": \"GET\",\n  \"HTTP/POST\": \"POST\",\n}\n\nconst serviceMethod = (service: Service): \"GET\" | \"POST\" => {\n  invariant(\n    OPTIONS[service.method as keyof ServiceMethodOptions] as any,\n    \"Invalid Service Method for type back-channel-rpc\",\n    {service}\n  )\n  return OPTIONS[service.method as keyof ServiceMethodOptions]\n}\n\nconst serviceBody = (service: Service): string | undefined => {\n  if (service.method === \"HTTP/GET\") return undefined\n  if (service.method === \"HTTP/POST\" && (service as any).data != null)\n    return JSON.stringify((service as any).data)\n  return undefined\n}\n\n/**\n * @description Continuously polls a service endpoint until it receives an APPROVED or DECLINED\n * response. This function handles the asynchronous nature of wallet interactions by repeatedly\n * checking for status updates with appropriate delays.\n *\n * @param service The service configuration containing the polling endpoint\n * @param checkCanContinue Optional function to control whether polling should continue\n * @returns Promise resolving to the final response data when approved or rejected\n *\n * @example\n * // Poll a service for completion\n * const result = await poll(pollingService, () => !userCancelled)\n * console.log(result) // Final response data\n */\nexport async function poll(\n  service: Service,\n  checkCanContinue: () => boolean = () => true\n): Promise<any> {\n  invariant(service as any, \"Missing Polling Service\", {service})\n  const canContinue = checkCanContinue()\n  if (!canContinue) throw new Error(\"Externally Halted\")\n\n  let resp\n  try {\n    if (\n      typeof document !== \"undefined\" &&\n      document.visibilityState === \"hidden\"\n    ) {\n      await new Promise(r => setTimeout(r, 500))\n      return poll(service, checkCanContinue)\n    }\n\n    resp = await fetchService(service, {\n      method: serviceMethod(service),\n    }).then(normalizePollingResponse)\n  } catch (error) {\n    throw error\n  }\n\n  switch (resp?.status) {\n    case \"APPROVED\":\n      return resp.data\n    case \"DECLINED\":\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`)\n    default:\n      await new Promise(r => setTimeout(r, 500))\n      return poll(resp?.updates, checkCanContinue)\n  }\n}\n","export interface BuildMessageHandlerParams {\n  close: () => void\n  send: (msg: any) => void\n  onReady: (\n    e: MessageEvent,\n    utils: {send: (msg: any) => void; close: () => void}\n  ) => void\n  onResponse: (\n    e: MessageEvent,\n    utils: {send: (msg: any) => void; close: () => void}\n  ) => void\n  onMessage: (\n    e: MessageEvent,\n    utils: {send: (msg: any) => void; close: () => void}\n  ) => void\n  onCustomRpc: (\n    payload: any,\n    utils: {send: (msg: any) => void; close: () => void}\n  ) => void\n  getSource?: () => Window | null\n}\n\nconst CLOSE_EVENT = \"FCL:VIEW:CLOSE\"\nconst READY_EVENT = \"FCL:VIEW:READY\"\nconst RESPONSE_EVENT = \"FCL:VIEW:RESPONSE\"\nconst CUSTOM_RPC = \"FCL:VIEW:CUSTOM_RPC\"\n\nconst _ = (e: any) => typeof e === \"string\" && e.toLowerCase()\n\nconst IGNORE = new Set([\n  \"monetizationstart\",\n  \"monetizationpending\",\n  \"monetizationprogress\",\n  \"monetizationstop\",\n])\n\nconst deprecate = (was: string, want: string): void =>\n  console.warn(\n    \"DEPRECATION NOTICE\",\n    `Received ${was}, please use ${want} for this and future versions of FCL`\n  )\n\n/**\n * @description Creates a message handler for processing window messages from wallet service\n * frames or popups. This handler manages the communication protocol between FCL and wallet\n * services, including ready states, responses, and cleanup operations.\n *\n * @param params Configuration object containing callback functions and utilities\n * @returns Message event handler function that can be attached to window message listeners\n *\n * @example\n * // Create a message handler for wallet communication\n * const handler = buildMessageHandler({\n *   close: () => cleanup(),\n *   send: (msg) => postMessage(msg),\n *   onReady: (e, utils) => initializeWallet(utils),\n *   onResponse: (e, utils) => handleResponse(e.data),\n *   onMessage: (e, utils) => processMessage(e),\n *   onCustomRpc: (payload, utils) => handleRpc(payload)\n * })\n * window.addEventListener(\"message\", handler)\n */\nexport const buildMessageHandler = ({\n  close,\n  send,\n  onReady,\n  onResponse,\n  onMessage,\n  onCustomRpc,\n  getSource,\n}: BuildMessageHandlerParams): ((e: MessageEvent) => void) => {\n  let source: any\n  return (e: MessageEvent): void => {\n    try {\n      source = getSource?.() || source\n    } catch (_) {\n      // If getSource isn't working correctly, we should reset source\n      // to prevent desync between the source and the actual source\n      source = null\n    }\n\n    try {\n      if (typeof e.data !== \"object\") return\n      if (IGNORE.has(e.data.type)) return\n      if (source != null && e.source !== source) return\n      if (_(e.data.type) === _(CLOSE_EVENT)) close()\n      if (_(e.data.type) === _(READY_EVENT)) {\n        onReady(e, {send, close})\n        source ||= e.source as Window\n      }\n      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {send, close})\n      if (_(e.data.type) === _(CUSTOM_RPC))\n        onCustomRpc(e.data.payload, {send, close})\n      onMessage(e, {send, close})\n\n      // Backwards Compatible\n      if (_(e.data.type) === _(\"FCL:FRAME:READY\")) {\n        deprecate(e.data.type, READY_EVENT)\n        onReady(e, {send, close})\n        source ||= e.source as Window\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT)\n        onResponse(e, {send, close})\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:CLOSE\")) {\n        deprecate(e.data.type, CLOSE_EVENT)\n        close()\n      }\n      //\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT)\n        onResponse(e, {send, close})\n      }\n      if (_(e.data.type) === _(\"FCL::AUTHZ_READY\")) {\n        deprecate(e.data.type, READY_EVENT)\n        onReady(e, {send, close})\n        source ||= e.source as Window\n      }\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT)\n        close()\n      }\n      if (_(e.data.type) === _(\"FCL::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT)\n        close()\n      }\n    } catch (error) {\n      console.error(\"Frame Callback Error\", error)\n      close()\n    }\n  }\n}\n","import {createUser, type CurrentUserServiceApi} from \"../current-user\"\nimport {StorageProvider} from \"../fcl-core\"\nimport {createSdkClient, SdkClientOptions} from \"@onflow/sdk\"\nimport {getContracts} from \"@onflow/config\"\nimport {invariant} from \"@onflow/util-invariant\"\ninterface FCLConfig {\n  accessNodeUrl: string\n  transport: SdkClientOptions[\"transport\"]\n  customResolver?: SdkClientOptions[\"customResolver\"]\n  customDecoders?: SdkClientOptions[\"customDecoders\"]\n  flowJson?: any\n  computeLimit: number\n  platform: string\n  discoveryWallet?: string\n  discoveryWalletMethod?: string\n  discoveryAuthnEndpoint?: string\n  discoveryAuthnInclude?: string[]\n  flowNetwork?: string\n  storage: StorageProvider\n  discovery?: {\n    execStrategy?: (...args: any[]) => any\n  }\n  // App detail properties\n  appDetailTitle?: string\n  appDetailIcon?: string\n  appDetailDescription?: string\n  appDetailUrl?: string\n  // Service configuration\n  serviceOpenIdScopes?: string[]\n}\n\n// Define a compatibility config interface for backward compatibility\nexport interface ConfigService {\n  get: (key: string, defaultValue?: any) => Promise<any>\n  put: (key: string, value: any) => Promise<ConfigService> | ConfigService\n  update: (\n    key: string,\n    updateFn: (oldValue: any) => any\n  ) => Promise<ConfigService> | ConfigService\n  delete: (key: string) => Promise<ConfigService> | ConfigService\n  where: (pattern: RegExp) => Promise<Record<string, any>>\n  first: (keys: string[], defaultValue?: any) => Promise<any> | any\n  subscribe: (\n    callback: (config: Record<string, any> | null) => void\n  ) => () => void\n  all: () => Promise<Record<string, any>>\n}\n\n/**\n * FCL Context contains the core infrastructure dependencies\n */\nexport interface FCLContext {\n  /** Configuration service for network settings, endpoints, etc. */\n  currentUser: CurrentUserServiceApi\n  sdk: ReturnType<typeof createSdkClient>\n  storage: StorageProvider\n  /** Legacy config compatibility layer */\n  config: ConfigService\n  platform: string\n}\n\n/**\n * Factory function to create an FCL context\n */\nexport function createFCLContext(config: FCLConfig): FCLContext {\n  let contracts: Record<string, string> | undefined\n\n  if (config.flowJson) {\n    invariant(\n      !!config.flowNetwork,\n      \"If flowJson is provided, flowNetwork must also be specified.\"\n    )\n\n    const cleanedNetwork = config.flowNetwork\n      .toLowerCase()\n      .replace(/^local$/, \"emulator\")\n\n    invariant(\n      cleanedNetwork === \"mainnet\" ||\n        cleanedNetwork === \"testnet\" ||\n        cleanedNetwork === \"emulator\",\n      `Invalid flowNetwork: ${config.flowNetwork}. Must be one of: mainnet, testnet, emulator.`\n    )\n\n    contracts = getContracts(config.flowJson, cleanedNetwork)\n  }\n\n  const sdk = createSdkClient({\n    accessNodeUrl: config.accessNodeUrl,\n    transport: config.transport,\n    computeLimit: config.computeLimit,\n    customResolver: config.customResolver,\n    customDecoders: config.customDecoders,\n    contracts: contracts,\n  })\n\n  const configService = createConfigService(config)\n\n  const currentUser = createUser({\n    platform: config.platform,\n    storage: config.storage,\n    config: configService,\n    discovery: {\n      execStrategy: config.discovery?.execStrategy,\n    },\n    sdk,\n  })\n\n  return {\n    storage: config.storage,\n    currentUser: currentUser,\n    sdk: sdk,\n    config: configService,\n    platform: config.platform,\n  }\n}\n\nexport function createConfigService(config: FCLConfig): ConfigService {\n  // Create internal config store based on provided typed config\n  const configStore = new Map<string, any>([\n    [\"platform\", config.platform],\n    [\"discovery.wallet\", config.discoveryWallet],\n    [\"discovery.wallet.method\", config.discoveryWalletMethod],\n    [\"discovery.authn.endpoint\", config.discoveryAuthnEndpoint],\n    [\"flow.network\", config.flowNetwork],\n    [\"accessNode.api\", config.accessNodeUrl],\n    [\"fcl.limit\", config.computeLimit],\n    [\"app.detail.title\", config.appDetailTitle],\n    [\"app.detail.icon\", config.appDetailIcon],\n    [\"app.detail.description\", config.appDetailDescription],\n    [\"app.detail.url\", config.appDetailUrl],\n    [\"service.OpenID.scopes\", config.serviceOpenIdScopes],\n  ])\n\n  // Filter out undefined values\n  for (const [key, value] of configStore.entries()) {\n    if (value === undefined) {\n      configStore.delete(key)\n    }\n  }\n\n  // Create subscribers registry\n  const subscribers = new Set<(config: Record<string, any>) => void>()\n\n  // Create compatibility config layer\n  const configService: ConfigService = {\n    get: async (key: string, fallback?: any) => {\n      return configStore.has(key) ? configStore.get(key) : fallback\n    },\n    put: async (key: string, value: any) => {\n      configStore.set(key, value)\n      subscribers.forEach(fn => fn(configStore))\n      return configService\n    },\n    update: async (key: string, updateFn: (oldValue: any) => any) => {\n      const oldValue = configStore.get(key)\n      const newValue = updateFn(oldValue)\n      configStore.set(key, newValue)\n      subscribers.forEach(fn => fn(configStore))\n      return configService\n    },\n    delete: async (key: string) => {\n      configStore.delete(key)\n      subscribers.forEach(fn => fn(configStore))\n      return configService\n    },\n    where: async (pattern: RegExp) => {\n      const result: Record<string, any> = {}\n      for (const [key, value] of configStore.entries()) {\n        if (pattern.test(key)) {\n          result[key] = value\n        }\n      }\n      return result\n    },\n    first: async (keys: string[], defaultValue?: any) => {\n      if (typeof keys === \"string\") keys = [keys]\n      for (const key of keys) {\n        if (configStore.has(key)) {\n          return configStore.get(key)\n        }\n      }\n      return defaultValue\n    },\n    subscribe: (callback: (config: Record<string, any>) => void) => {\n      subscribers.add(callback)\n      return () => {\n        subscribers.delete(callback)\n      }\n    },\n    all: async () => {\n      return Object.fromEntries(configStore.entries())\n    },\n  }\n\n  return configService\n}\n","import {createGetChainId} from \"./get-chain-id\"\nimport {FCLContext} from \"../../context\"\nimport {createPartialGlobalFCLContext} from \"../../context/global\"\n\n/**\n * @description Watches the FCL configuration for changes to the access node and automatically updates\n * the chain ID cache accordingly. This ensures that chain ID information stays current when the\n * access node configuration changes, preventing stale chain ID data from being used.\n *\n * @returns A function that can be called to unsubscribe the configuration listener\n *\n * @example\n * // Start watching for chain ID changes\n * import * as fcl from \"@onflow/fcl\"\n *\n * const unsubscribe = fcl.watchForChainIdChanges()\n *\n * // Later, when you want to stop watching\n * unsubscribe()\n */\nexport function watchForChainIdChanges(\n  context?: Pick<FCLContext, \"config\" | \"sdk\">\n): () => void {\n  if (!context) {\n    context = createPartialGlobalFCLContext()\n  }\n  return context.config.subscribe(() => {\n    // Call getChainId to update the chainId cache if access node has changed\n    createGetChainId(context)({\n      enableRequestLogging: false,\n    }).catch(() => {})\n  })\n}\n","import {httpTransport} from \"@onflow/transport-http\"\nimport {createVerifyUserSignatures} from \"./app-utils/verify-signatures\"\nimport {createFCLContext} from \"./context/index\"\nimport {createMutate} from \"./exec/mutate\"\nimport {createQuery} from \"./exec/query\"\nimport {createQueryRaw} from \"./exec/query-raw\"\nimport {createTransaction} from \"./transaction\"\nimport {createEvents} from \"./events\"\nimport {createGetChainId} from \"./utils\"\nimport {createSerialize} from \"./serialize\"\nimport {SdkTransport} from \"@onflow/typedefs\"\nimport {StorageProvider} from \"./fcl-core\"\n\nexport interface FlowClientCoreConfig {\n  // Core network configuration (most commonly used)\n  accessNodeUrl: string\n  flowNetwork?: string\n  flowJson?: Record<string, any>\n\n  // Wallet/Discovery configuration\n  discoveryWallet?: string\n  discoveryWalletMethod?: string\n  discoveryAuthnEndpoint?: string\n  discoveryAuthnInclude?: string[]\n\n  // Compute limit for transactions\n  computeLimit: number\n\n  // Storage configuration\n  storage: StorageProvider\n\n  // Platform configuration\n  platform: string\n\n  // Discovery configuration\n  discovery?: {\n    execStrategy?: (opts: any) => Promise<any>\n  }\n\n  // App detail properties\n  appDetailTitle?: string\n  appDetailIcon?: string\n  appDetailDescription?: string\n  appDetailUrl?: string\n\n  // Service configuration\n  serviceOpenIdScopes?: string[]\n\n  // Advanced/SDK configuration (least commonly used)\n  transport?: SdkTransport\n  customResolver?: any\n  customDecoders?: any\n}\n\nexport function createFlowClientCore(params: FlowClientCoreConfig) {\n  const context = createFCLContext({\n    ...params,\n    transport: params.transport || httpTransport,\n  })\n\n  return {\n    // Global services\n    currentUser: context.currentUser,\n\n    // Execution methods\n    mutate: createMutate(context),\n    query: createQuery(context),\n    queryRaw: createQueryRaw(context),\n    verifyUserSignatures: createVerifyUserSignatures(context),\n    getChainId: createGetChainId(context),\n\n    // Streaming helpers\n    tx: createTransaction(context),\n    events: createEvents(context),\n\n    // Authentication methods\n    authenticate: context.currentUser.authenticate,\n    unauthenticate: context.currentUser.unauthenticate,\n    signUserMessage: context.currentUser.signUserMessage,\n\n    // Utility methods\n    serialize: createSerialize(context),\n\n    // Re-export the SDK methods\n    ...context.sdk,\n  }\n}\n","import {fetchService} from \"./utils/fetch-service\"\nimport {normalizePollingResponse} from \"../../../normalizers/service/polling-response\"\nimport {normalizeLocalView} from \"../../../normalizers/service/local-view\"\nimport {poll} from \"./utils/poll\"\nimport {VERSION} from \"../../../VERSION\"\nimport {serviceEndpoint} from \"../strategies/utils/service-endpoint\"\nimport {Service} from \"@onflow/typedefs\"\n\nexport interface ExecHttpPostParams {\n  service: Service & {\n    data?: Record<string, any>\n    type: string\n  }\n  body: Record<string, any>\n  config: Record<string, any>\n  opts: Record<string, any>\n}\n\nexport type ExecLocalFunction = (\n  view: any,\n  options: {\n    serviceEndpoint: typeof serviceEndpoint\n    onClose: () => void\n  }\n) => Promise<[any, () => void]>\n\n/**\n * @description Creates an HTTP POST strategy executor that handles wallet service communication\n * via HTTP POST requests. This function manages the full lifecycle including polling for\n * responses, handling local views, and managing user interactions.\n *\n * @param execLocal Function to execute local view rendering and user interaction\n * @returns HTTP POST strategy function that can be used to execute services\n *\n * @example\n * // Create an HTTP POST executor\n * const httpPostExec = getExecHttpPost(async (view, { serviceEndpoint, onClose }) => {\n *   // Render local view and return cleanup function\n *   return [viewData, () => cleanup()]\n * })\n */\nexport const getExecHttpPost =\n  (execLocal: ExecLocalFunction) =>\n  async ({service, body, config, opts}: ExecHttpPostParams): Promise<any> => {\n    const resp = await fetchService(service, {\n      data: {\n        fclVersion: VERSION,\n        service: {\n          params: service.params,\n          data: service.data,\n          type: service.type,\n        },\n        config,\n        ...body,\n      },\n    }).then(normalizePollingResponse)\n\n    if (resp?.status === \"APPROVED\") {\n      return resp.data\n    } else if (resp?.status === \"DECLINED\") {\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`)\n    } else if (resp?.status === \"REDIRECT\") {\n      return resp\n    } else if (resp?.status === \"PENDING\") {\n      // these two flags are required to run polling one more time before it stops\n      let canContinue = true\n      let shouldContinue = true\n\n      const [_, unmount] = await execLocal(normalizeLocalView(resp.local), {\n        serviceEndpoint,\n        onClose: () => (shouldContinue = false),\n      })\n\n      const close = () => {\n        try {\n          unmount()\n          shouldContinue = false\n        } catch (error) {\n          console.error(\"Frame Close Error\", error)\n        }\n      }\n\n      /**\n       * this function is run once per poll call.\n       * Offsetting canContinue flag to make sure that\n       * the polling is performed one extra time after canContinue flag is set to false\n       * to prevent halting on Android when a browser calls window.close\n       * before FCL receives a successful result from polling\n       *\n       * @returns {boolean}\n       */\n      const checkCanContinue = () => {\n        const offsetCanContinue = canContinue\n        canContinue = shouldContinue\n        return offsetCanContinue\n      }\n\n      return poll(resp.updates, checkCanContinue)\n        .then(serviceResponse => {\n          close()\n          return serviceResponse\n        })\n        .catch(error => {\n          console.error(error)\n          close()\n          throw error\n        })\n    } else {\n      console.error(`Auto Decline: Invalid Response`, {service, resp})\n      throw new Error(`Auto Decline: Invalid Response`)\n    }\n  }\n"],"names":["VERSION","is","type","d","isRequired","isObject","isString","isFunc","isNumber","normalizeArgs","ax","sdk","arg","t","async","pre","context","opts","invariant","cadence","template","config","get","httpDocumentResolver","_ref","res","url","fetchTransport","e","Error","ok","json","DOCUMENT_RESOLVERS","Map","deriveCadenceByNetwork110","network","f_version","networkDependencies","data","dependencies","forEach","dependency","contracts","contract","contractName","networks","net","address","undefined","Object","keys","length","values","body","reduce","c","regex","RegExp","replace","replaceStringImports","deriveCadenceByNetwork","f_type","map","dependencyPlaceholder","dependencyNetworkContracts","dependencyContract","dependencyContractForNetwork","_ref2","placeholder","deriveCadenceByNetwork100","createPartialGlobalFCLContext","_config","send","decode","subscribe","subscribeRaw","account","block","resolve","chainIdCache","hasWarnedEnv","createGetChainId","arguments","flowNetworkCfg","envCfg","log","deprecate","pkg","subject","message","transition","accessNode","node","getNetworkParameters","then","chainId","fetchChainId","catch","error","getChainId","prepTemplateOpts","documentResolversFromConfig","where","key","resolverFromConfig","resolverProtocol","set","urlParts","exec","protocol","resolver","retrieve","createQueryRaw","preQuery","script","args","atLatestBlock","isSealed","limit","queryRaw","createQuery","query","FCL_REDIRECT_URL_PARAM_NAME","FCL_RESPONSE_PARAM_NAME","CORE_STRATEGIES","onMessageFromFCL","messageType","cb","internal","origin","deprecated","console","warn","interaction","buildData","window","addEventListener","removeEventListener","sendMsgToFCL","msg","redirectUrl","URLSearchParams","location","search","URL","searchParams","append","JSON","stringify","href","parent","postMessage","opener","SERVICE_PRAGMA","f_vsn","IDENTITY_PRAGMA","USER_PRAGMA","POLLING_RESPONSE_PRAGMA","COMPOSITE_SIGNATURE_PRAGMA","addressBuffer","addr","leftPaddedHexBuffer","value","pad","Buffer","from","padStart","nonceBuffer","nonce","encodeAccountProof","appIdentifier","includeDomainTag","ACCOUNT_PROOF_DOMAIN_TAG","toString","padEnd","rightPaddedHexBuffer","concat","rlpEncode","sansPrefix","constructor","keyId","signature","this","withPrefix","Number","status","reason","close","service","endpoint","Array","isArray","fcl_extensions","push","validateArgs","signatures","test","every","sig","i","arr","cs","compSigs","getVerifySignaturesScript","verifyFunction","fclCryptoContract","testnet","mainnet","previewnet","createVerifyAccountProof","signaturesArr","keyIndices","el","Address","String","Int","createVerifyUserSignatures","verifyAccountProof","verifyUserSignatures","callback","verify","createSerialize","resolveFunction","pipe","createSignableVoucher","serialize","ERROR_CODE_REGEX","TransactionError","code","super","FvmErrorCode","fromErrorMessage","errorMessage","match","parseInt","UNKNOWN_ERROR","configLens","fromEntries","entries","isExpired","tx","isExecuted","isFinalized","isPending","deepEqual","a","b","isDiff","scoped","transactionId","TXID_REGEXP","POLL","TIMEOUT","makeHandlers","INIT","setTimeout","ctx","sendSelf","txNotFoundTimeout","SUBSCRIBE","letter","UPDATED","all","UNSUBSCRIBE","unsubscribe","SNAPSHOT","reply","fatalError","poll","pollRate","prevTx","fclSend","getTransactionStatus","fetchTxStatus","self","isHttpNotFound","HTTPRequestError","statusCode","isGrpcNotFound","grpc","Code","NotFound","broadcast","merge","spawnTransaction","spawn","transaction","subscriber","once","predicate","suppress","Promise","reject","unsub","txStatus","transactionError","snapshot","snapshoter","onceFinalized","onceExecuted","onceSealed","isUnknown","FLOW_EMULATOR","registry","createTransaction","getObservable","observable","txId","observers","Set","blockId","TransactionExecutionStatus","UNKNOWN","events","statusString","init","fallbackLegacyPolling","subscribeTransactionStatuses","subscription","topic","SubscriptionTopic","TRANSACTION_STATUSES","onData","next","onError","err","SubscriptionsNotSupportedError","legacyTransaction","observer","add","delete","createObservable","TICK","HIGH_WATER_MARK","scheduleTick","fclContext","spawnEvents","hasSubs","hwm","put","height","getEventsAtBlockHeightRange","clearTimeout","createHandlers","createEvents","filterOrType","filter","eventTypes","unsubscribeFn","unsubscribeFnLegacy","createLegacyEvents","event","initPromise","EVENTS","subscribeEventStream","subscribeToEvents","finally","stub","stubCoreStrategies","supportedPlugins","supportedServicePlugins","ServiceRegistry","coreStrategies","services","strategies","setServices","discoveryServices","freeze","servicePlugin","includes","serviceStrategy","ds","method","validateDiscoveryPlugin","has","title","level","LEVELS","getServices","getStrategy","getStrategies","serviceRegistry","getIsServiceRegistryInitialized","initServiceRegistry","_serviceRegistry","getServiceRegistry","pluginRegistry","PluginRegistry","pluginsMap","plugins","pluginsArray","p","name","validatePlugins","getPlugins","makeDiscoveryServices","_isReactNative","isReactNative","_URL","globalThis","base","_len","_key","_url","endsWith","slice","SERVICE_ACTOR_KEYS","fetchServicesFromDiscovery","types","Boolean","include","exclude","fetch","headers","fclVersion","features","suggested","clientServices","supportedStrategies","userAgent","navigator","results","fact","document","readyState","SERVICE_ACTOR_KEYS_UPDATE_RESULTS","_letter","SERVICE_ACTOR_KEYS_SNAPSHOT","spawnProviders","createAuthn","update","discovery","authn","genHash","utf8String","sha","SHA3","digest","generateImport","findImports","imports","fileImports","fileImport","importLine","contractsReg","createGenerateDependencyPin110","horizon","horizonImport","getAccount","contractImports","contractPinSelfHashesPromises","iport","join","generateDependencyPin110","generateContractNetworks","networkHashes","dependency_pin_block_height","dependency_pin","hash","blockHeight","generateContractDependencies","j","contractHashes","createGenerateTemplateId","templateData","messages","templateMessage","i18n","templateMessagei18n","tag","translation","params","sort","index","label","argumentMessage","argumentMessagei18n","encodedHex","interface","generateTemplateId","generateTemplateId110","messageKey","i18nkeylanguage","dependencyAddressPlaceholder","dependencyContractNetwork","fq_address","pin","pin_block_height","_arguments","argumentLabel","balance","argumentMessageKey","generateTemplateId100","creategenerateDependencyPin100","generateDependencyPin100","generateDependencyPin","version","verifyDependencyPinsSame","templateDependenciesPlaceholderKeys","templateDependencyPlaceholderKey","templateDependencyPlaceholder","templateDependencyPlaceholderContractNames","templateDependencyPlaceholderContractName","templateDependency","debug","isVerified","k","sealed","auditors","recomputedTemplateID","id","_auditors","FlowInteractionAuditContract","flowInteractionAuditContract","fclNetwork","audits","localization","param","parameters","find","lzn","latestSealedBlock","latestSealedBlockHeight","createMutate","preMutate","authz","currentUser","authorization","proposer","payer","authorizations","normalizeCompositeSignature","resp","normalizeFrame","old","normalizeBackChannelRpc","normalizeLocalView","normalizeServices","serviceNormalizers","normalizeService","uid","identity","pid","provider","icon","frame","serviceOfType","mostRecent","semver","compare","deriveCompositeId","rlp","encode","buildUser","mergeServices","paddr","normalizeData","servicesURL","fetchServices","hks","cid","loggedIn","expiresAt","expires","isServerSide","AbortController","require","execStrategy","abortSignal","customRpc","user","strategy","execService","platform","signal","_execStrategy","logger","checkWalletConnectEnabled","execConfig","app","client","fclLibrary","hostname","NAME","SET_CURRENT_USER","DEL_CURRENT_USER","DATA","getStorageProvider","first","parse","storage","can","fallback","stored","removeItem","getStoredUser","Date","now","notExpired","spawnCurrentUser","actorName","makeConfig","discoveryAuthnInclude","discoveryAuthnExclude","discoveryFeaturesSuggested","createAuthenticate","redir","forceReauth","is_installed","requires_install","createSnapshot","refreshService","accountProofData","response","accountProofDataResolver","getAccountProofData","discoveryService","discoveryWalletMethod","getDiscoveryService","install_link","createUnauthenticate","createAuthorization","tempId","preSignable","preAuthz","normalizePreAuthzResponse","axs","az","_ref3","role","signingFunction","signable","authorizer","createResolvePreAuthz","sequenceNum","includeOlderJsonRpcCall","createSubscribe","EXIT","receive","expectReply","timeout","createResolveArgument","makeSignable","createSignUserMessage","signingService","_createUser","authenticate","unauthenticate","signUserMessage","resolveArgument","assign","serviceEndpoint","fetchService","normalizePollingResponse","compositeSignature","updates","authorizationUpdates","local","OPTIONS","serviceMethod","checkCanContinue","visibilityState","r","CLOSE_EVENT","READY_EVENT","RESPONSE_EVENT","_","toLowerCase","IGNORE","was","want","createFCLContext","flowJson","flowNetwork","cleanedNetwork","getContracts","createSdkClient","accessNodeUrl","transport","computeLimit","customResolver","customDecoders","configService","configStore","discoveryWallet","discoveryAuthnEndpoint","appDetailTitle","appDetailIcon","appDetailDescription","appDetailUrl","serviceOpenIdScopes","subscribers","fn","updateFn","newValue","result","pattern","defaultValue","createConfigService","uuidv4","enableRequestLogging","source","onReady","onResponse","onMessage","onCustomRpc","getSource","payload","httpTransport","mutate","cfg","partialContext","execLocal","canContinue","shouldContinue","unmount","onClose","offsetCanContinue","serviceResponse","currentUserOrConfig"],"mappings":"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"}