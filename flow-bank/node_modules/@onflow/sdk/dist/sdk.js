'use strict';

var logger = require('@onflow/util-logger');
var utilInvariant = require('@onflow/util-invariant');
var uuid = require('uuid');
var typedefs = require('@onflow/typedefs');
var config = require('@onflow/config');
var rlp = require('@onflow/rlp');
var utilAddress = require('@onflow/util-address');
var EventEmitter = require('events');
var transportHttp = require('@onflow/transport-http');
var sha3 = require('sha3');
var utilTemplate = require('@onflow/util-template');
var types = require('@onflow/types');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var logger__namespace = /*#__PURE__*/_interopNamespaceDefault(logger);
var types__namespace = /*#__PURE__*/_interopNamespaceDefault(types);

const ACCT = `{
  "kind":"${typedefs.InteractionResolverKind.ACCOUNT}",
  "tempId":null,
  "addr":null,
  "keyId":null,
  "sequenceNum":null,
  "signature":null,
  "signingFunction":null,
  "resolve":null,
  "role": {
    "proposer":false,
    "authorizer":false,
    "payer":false,
    "param":false
  }
}`;
const ARG = `{
  "kind":"${typedefs.InteractionResolverKind.ARGUMENT}",
  "tempId":null,
  "value":null,
  "asArgument":null,
  "xform":null,
  "resolve": null,
  "resolveArgument": null
}`;
const IX = `{
  "tag":"${typedefs.InteractionTag.UNKNOWN}",
  "assigns":{},
  "status":"${typedefs.InteractionStatus.OK}",
  "reason":null,
  "accounts":{},
  "params":{},
  "arguments":{},
  "message": {
    "cadence":null,
    "refBlock":null,
    "computeLimit":null,
    "proposer":null,
    "payer":null,
    "authorizations":[],
    "params":[],
    "arguments":[]
  },
  "proposer":null,
  "authorizations":[],
  "payer":[],
  "events": {
    "eventType":null,
    "start":null,
    "end":null,
    "blockIds":[]
  },
  "subscribeEvents": {
    "startBlockId":null,
    "startHeight":null,
    "eventTypes":null,
    "addresses":null,
    "contracts":null,
    "heartbeatInterval":null
  },
  "transaction": {
    "id":null
  },
  "block": {
    "id":null,
    "height":null,
    "isSealed":null
  },
  "account": {
    "addr":null
  },
  "collection": {
    "id":null
  }
}`;
const KEYS = new Set(Object.keys(JSON.parse(IX)));

/**
 * Creates a new interaction object with default values.
 *
 * @returns A new interaction object initialized with default values
 */
const initInteraction = () => JSON.parse(IX);

/**
 * Creates a new interaction object with default values.
 *
 * @deprecated Use initInteraction() instead. This function will be removed in a future version.
 *
 * @returns A new interaction object initialized with default values
 */
const interaction = () => {
  logger.log.deprecate({
    pkg: "FCL/SDK",
    message: `The interaction been deprecated from the Flow JS-SDK/FCL. use initInteraction instead`,
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0010-deprecate-interaction",
    level: logger.LEVELS.warn
  });
  return initInteraction();
};

/**
 * Checks if a value is a number.
 *
 * @param d The value to check
 * @returns True if the value is a number, false otherwise
 *
 * @example
 * import { isNumber } from "@onflow/sdk"
 *
 * console.log(isNumber(42)); // true
 * console.log(isNumber("42")); // false
 * console.log(isNumber(3.14)); // true
 * console.log(isNumber(null)); // false
 */
const isNumber$1 = d => typeof d === "number";

/**
 * Checks if a value is an array.
 *
 * @param d The value to check
 * @returns True if the value is an array, false otherwise
 *
 * @example
 * import { isArray } from "@onflow/sdk"
 *
 * console.log(isArray([1, 2, 3])); // true
 * console.log(isArray("hello")); // false
 * console.log(isArray({})); // false
 * console.log(isArray(null)); // false
 */
const isArray$1 = d => Array.isArray(d);

/**
 * Checks if a value is an object (but not null).
 *
 * @param d The value to check
 * @returns True if the value is an object and not null, false otherwise
 *
 * @example
 * import { isObj } from "@onflow/sdk"
 *
 * console.log(isObj({})); // true
 * console.log(isObj({name: "Alice"})); // true
 * console.log(isObj(null)); // false
 * console.log(isObj("string")); // false
 * console.log(isObj([])); // true (arrays are objects)
 */
const isObj = d => d !== null && typeof d === "object";

/**
 * Checks if a value is null or undefined.
 *
 * @param d The value to check
 * @returns True if the value is null or undefined, false otherwise
 *
 * @example
 * import { isNull } from "@onflow/sdk"
 *
 * console.log(isNull(null)); // true
 * console.log(isNull(undefined)); // true
 * console.log(isNull("")); // false
 * console.log(isNull(0)); // false
 * console.log(isNull(false)); // false
 */
const isNull = d => d == null;

/**
 * Checks if a value is a function.
 *
 * @param d The value to check
 * @returns True if the value is a function, false otherwise
 *
 * @example
 * import { isFn } from "@onflow/sdk"
 *
 * console.log(isFn(() => {})); // true
 * console.log(isFn(function() {})); // true
 * console.log(isFn("function")); // false
 * console.log(isFn({})); // false
 */
const isFn$3 = d => typeof d === "function";

/**
 * Checks if an object is a valid interaction.
 *
 * @param ix The object to check
 * @returns True if the object is a valid interaction, false otherwise
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { isInteraction, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * console.log(isInteraction(interaction)); // true
 * console.log(isInteraction({})); // false
 * console.log(isInteraction(null)); // false
 *
 * // Check if a builder result is a valid interaction
 * const built = await fcl.build([fcl.script`access(all) fun main(): Int { return 42 }`]);
 * console.log(isInteraction(built)); // true
 */
const isInteraction = ix => {
  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;
  for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;
  return true;
};

/**
 * Marks an interaction as successful and returns the interaction object.
 *
 * @param ix The interaction to mark as successful
 * @returns The interaction object with status set to OK
 *
 * @example
 * import { Ok, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * const successfulInteraction = Ok(interaction);
 * console.log(successfulInteraction.status); // "OK"
 */
const Ok = ix => {
  ix.status = typedefs.InteractionStatus.OK;
  return ix;
};

/**
 * Marks an interaction as failed with a specific reason and returns the interaction object.
 *
 * @param ix The interaction to mark as failed
 * @param reason The reason for the failure
 * @returns The interaction object with status set to BAD and reason set
 *
 * @example
 * import { Bad, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * const failedInteraction = Bad(interaction, "Invalid transaction signature");
 * console.log(failedInteraction.status); // "BAD"
 * console.log(failedInteraction.reason); // "Invalid transaction signature"
 */
const Bad = (ix, reason) => {
  ix.status = typedefs.InteractionStatus.BAD;
  ix.reason = reason;
  return ix;
};
const makeIx = wat => ix => {
  ix.tag = wat;
  return Ok(ix);
};
const prepAccountKeyId = acct => {
  if (acct.keyId == null) return acct;
  utilInvariant.invariant(!isNaN(parseInt(acct.keyId.toString())), "account.keyId must be an integer");
  return {
    ...acct,
    keyId: parseInt(acct.keyId.toString())
  };
};
/**
 * Creates a new account object with default values.
 *
 * @returns A new account object initialized with default values
 *
 * @example
 * import { initAccount } from "@onflow/sdk"
 *
 * const account = initAccount();
 * console.log(account.addr); // null
 * console.log(account.keyId); // null
 * console.log(account.role.proposer); // false
 *
 * // Typically used internally by other functions
 * // You'll more commonly use authorization() or prepAccount()
 */
const initAccount = () => JSON.parse(ACCT);

/**
 * Prepares and configures an account for use in an interaction with a specific role.
 *
 * @param acct The account authorization function or account object
 * @param opts Configuration options including the role for the account
 * @returns A function that adds the prepared account to an interaction
 */
const prepAccount = function (acct) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return ix => {
    utilInvariant.invariant(typeof acct === "function" || typeof acct === "object", "prepAccount must be passed an authorization function or an account object");
    utilInvariant.invariant(opts.role != null, "Account must have a role");
    const ACCOUNT = initAccount();
    const role = opts.role;
    const tempId = uuid.v4();
    let account = {
      ...acct
    };
    if (acct.authorization && isFn$3(acct.authorization)) account = {
      resolve: acct.authorization
    };
    if (!acct.authorization && isFn$3(acct)) account = {
      resolve: acct
    };
    const resolve = account.resolve;
    if (resolve) {
      account.resolve = function (acct) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        return [resolve, prepAccountKeyId].reduce(async (d, fn) => fn(await d, ...rest), acct);
      };
    }
    account = prepAccountKeyId(account);
    ix.accounts[tempId] = {
      ...ACCOUNT,
      tempId,
      ...account,
      role: {
        ...ACCOUNT.role,
        ...(typeof acct.role === "object" ? acct.role : {}),
        ...(role ? {
          [role]: true
        } : {})
      }
    };
    if (role === typedefs.TransactionRole.AUTHORIZER) {
      ix.authorizations.push(tempId);
    } else if (role === typedefs.TransactionRole.PAYER) {
      ix.payer.push(tempId);
    } else if (role) {
      ix[role] = tempId;
    }
    return ix;
  };
};

/**
 * Creates an argument resolver and adds it to an interaction.
 *
 * This function is typically used internally by the SDK to handle arguments in scripts and transactions.
 * For most use cases, you should use `fcl.arg()` instead of this function directly.
 *
 * @param arg The argument configuration object
 * @returns A function that adds the argument to an interaction
 *
 * @example
 * import { makeArgument, initInteraction } from "@onflow/sdk"
 * import * as fcl from "@onflow/fcl";
 *
 * const interaction = initInteraction();
 *
 * // Create an argument resolver (usually you'd use fcl.arg instead)
 * const argResolver = {
 *   value: 42,
 *   xform: fcl.t.Int,
 *   resolve: (value, xform) => ({ value, xform })
 * };
 *
 * // Add the argument to the interaction
 * makeArgument(argResolver)(interaction);
 *
 * console.log(interaction.message.arguments.length); // 1
 *
 * // Preferred way - use fcl.arg instead:
 * // fcl.args([fcl.arg(42, fcl.t.Int)])
 */
const makeArgument = arg => ix => {
  let tempId = uuid.v4();
  ix.message.arguments.push(tempId);
  ix.arguments[tempId] = JSON.parse(ARG);
  ix.arguments[tempId].tempId = tempId;
  ix.arguments[tempId].value = arg.value;
  ix.arguments[tempId].asArgument = arg.asArgument;
  ix.arguments[tempId].xform = arg.xform;
  ix.arguments[tempId].resolve = arg.resolve;
  ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
  return Ok(ix);
};
const makeUnknown /*                 */ = makeIx(typedefs.InteractionTag.UNKNOWN);
const makeScript /*                  */ = makeIx(typedefs.InteractionTag.SCRIPT);
const makeTransaction /*             */ = makeIx(typedefs.InteractionTag.TRANSACTION);
const makeGetTransactionStatus /*    */ = makeIx(typedefs.InteractionTag.GET_TRANSACTION_STATUS);
const makeGetTransaction /*          */ = makeIx(typedefs.InteractionTag.GET_TRANSACTION);
const makeGetAccount /*              */ = makeIx(typedefs.InteractionTag.GET_ACCOUNT);
const makeGetEvents /*               */ = makeIx(typedefs.InteractionTag.GET_EVENTS);
const makePing /*                    */ = makeIx(typedefs.InteractionTag.PING);
const makeGetBlock /*                */ = makeIx(typedefs.InteractionTag.GET_BLOCK);
const makeGetBlockHeader /*          */ = makeIx(typedefs.InteractionTag.GET_BLOCK_HEADER);
const makeGetCollection /*           */ = makeIx(typedefs.InteractionTag.GET_COLLECTION);
const makeGetNetworkParameters /*    */ = makeIx(typedefs.InteractionTag.GET_NETWORK_PARAMETERS);
const makeSubscribeEvents /*         */ = makeIx(typedefs.InteractionTag.SUBSCRIBE_EVENTS);
const makeGetNodeVerionInfo /*       */ = makeIx(typedefs.InteractionTag.GET_NODE_VERSION_INFO);
const is = wat => ix => ix.tag === wat;
const isUnknown /*                 */ = is(typedefs.InteractionTag.UNKNOWN);
const isScript /*                  */ = is(typedefs.InteractionTag.SCRIPT);
const isTransaction /*             */ = is(typedefs.InteractionTag.TRANSACTION);
const isGetTransactionStatus /*    */ = is(typedefs.InteractionTag.GET_TRANSACTION_STATUS);
const isGetTransaction /*          */ = is(typedefs.InteractionTag.GET_TRANSACTION);
const isGetAccount /*              */ = is(typedefs.InteractionTag.GET_ACCOUNT);
const isGetEvents /*               */ = is(typedefs.InteractionTag.GET_EVENTS);
const isPing /*                    */ = is(typedefs.InteractionTag.PING);
const isGetBlock /*                */ = is(typedefs.InteractionTag.GET_BLOCK);
const isGetBlockHeader /*          */ = is(typedefs.InteractionTag.GET_BLOCK_HEADER);
const isGetCollection /*           */ = is(typedefs.InteractionTag.GET_COLLECTION);
const isGetNetworkParameters /*    */ = is(typedefs.InteractionTag.GET_NETWORK_PARAMETERS);
const isGetNodeVersionInfo /*      */ = is(typedefs.InteractionTag.GET_NODE_VERSION_INFO);
const isSubscribeEvents /*         */ = is(typedefs.InteractionTag.SUBSCRIBE_EVENTS);

/**
 * Checks if an interaction has a successful status.
 *
 * @param ix The interaction to check
 * @returns True if the interaction status is OK, false otherwise
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { isOk } from "@onflow/sdk"
 *
 * // Check if a transaction was successful
 * const response = await fcl.send([
 *   fcl.transaction`transaction { prepare(account: AuthAccount) {} }`
 * ]);
 *
 * if (isOk(response)) {
 *   console.log("Transaction was successful");
 * } else {
 *   console.log("Transaction failed");
 * }
 */
const isOk /*  */ = ix => ix.status === typedefs.InteractionStatus.OK;

/**
 * Checks if an interaction has a failed status.
 *
 * @param ix The interaction to check
 * @returns True if the interaction status is BAD, false otherwise
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { isBad, why } from "@onflow/sdk"
 *
 * const response = await fcl.send([
 *   fcl.transaction`transaction { prepare(account: AuthAccount) {} }`
 * ]);
 *
 * if (isBad(response)) {
 *   console.log("Transaction failed:", why(response));
 * }
 */
const isBad /* */ = ix => ix.status === typedefs.InteractionStatus.BAD;

/**
 * Returns the reason for an interaction failure.
 *
 * @param ix The interaction to get the failure reason from
 * @returns The reason string or undefined if no reason is set
 *
 * @example
 * import { Bad, why, initInteraction } from "@onflow/sdk"
 *
 * const interaction = Bad(initInteraction(), "Network timeout");
 * console.log(why(interaction)); // "Network timeout"
 *
 * // Used with error handling
 * if (isBad(response)) {
 *   console.error("Error occurred:", why(response));
 * }
 */
const why /*   */ = ix => ix.reason;

/**
 * Checks if an object is an account resolver.
 *
 * @param account The object to check
 * @returns True if the object is an account resolver, false otherwise
 *
 * @example
 * import { isAccount, authorization } from "@onflow/sdk"
 *
 * const authz = authorization("0x123", signingFunction);
 * const accountResolver = { kind: "ACCOUNT", addr: "0x123" };
 * const regularObject = { name: "test" };
 *
 * console.log(isAccount(accountResolver)); // true
 * console.log(isAccount(regularObject)); // false
 */
const isAccount /*  */ = account => account.kind === typedefs.InteractionResolverKind.ACCOUNT;

/**
 * Checks if an object is an argument resolver.
 *
 * @param argument The object to check
 * @returns True if the object is an argument resolver, false otherwise
 *
 * @example
 * import { isArgument, arg } from "@onflow/sdk"
 *
 * const argumentResolver = { kind: "ARGUMENT", value: 42 };
 * const regularObject = { value: 42 };
 *
 * console.log(isArgument(argumentResolver)); // true
 * console.log(isArgument(regularObject)); // false
 *
 * // Check arguments in a script
 * const scriptArgs = [arg(10, t.Int), arg("hello", t.String)];
 * scriptArgs.forEach(arg => {
 *   if (isArgument(arg)) {
 *     console.log("Valid argument:", arg.value);
 *   }
 * });
 */
const isArgument /* */ = argument => argument.kind === typedefs.InteractionResolverKind.ARGUMENT;
const hardMode = ix => {
  for (let key of Object.keys(ix)) {
    if (!KEYS.has(key)) throw new Error(`"${key}" is an invalid root level Interaction property.`);
  }
  return ix;
};
const recPipe = async function (ix) {
  let fns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  try {
    ix = hardMode(await ix);
    if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);
    if (!fns.length) return ix;
    const [hd, ...rest] = fns;
    const cur = await hd;
    if (isFn$3(cur)) return recPipe(cur(ix), rest);
    if (isNull(cur) || !cur) return recPipe(ix, rest);
    if (isInteraction(cur)) return recPipe(cur, rest);
    throw new Error("Invalid Interaction Composition");
  } catch (e) {
    throw e;
  }
};

/**
 * Async pipe function to compose interactions.
 *
 * The pipe function is the foundation for composing multiple interaction builder functions together.
 * It sequentially applies builder functions to an interaction, allowing for complex interaction construction.
 * Each function in the pipe receives the result of the previous function and can modify or validate the interaction.
 *
 * Pipe has two main forms:
 * 1. `pipe(builderFunctions)`: Returns a builder function
 * 2. `pipe(interaction, builderFunctions)`: Directly executes the pipe on an interaction
 *
 * @param fns Array of builder functions to apply
 * @returns An interaction builder function when called with just functions, or a Promise<Interaction> when called with an interaction and functions
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Using pipe to create a reusable builder
 * const myTransactionBuilder = fcl.pipe([
 *   fcl.transaction`
 *     transaction(amount: UFix64) {
 *       prepare(account: AuthAccount) {
 *         log(amount)
 *       }
 *     }
 *   `,
 *   fcl.args([fcl.arg("10.0", fcl.t.UFix64)]),
 *   fcl.proposer(fcl.authz),
 *   fcl.payer(fcl.authz),
 *   fcl.authorizations([fcl.authz]),
 *   fcl.limit(100)
 * ]);
 *
 * // Use the builder
 * const interaction = await fcl.build([myTransactionBuilder]);
 *
 * // Pipe is used internally by build() and send()
 * await fcl.send([
 *   fcl.script`access(all) fun main(): Int { return 42 }`
 * ]); // This uses pipe internally
 */

function pipe() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  const [arg1, arg2] = args;
  if (isArray$1(arg1)) return d => pipe(d, arg1);
  const ix = arg1;
  const fns = arg2;
  return recPipe(ix, fns);
}
const identity$1 = function (v) {
  return v;
};

/**
 * Gets a value from an interaction object using a dot-notation key path.
 *
 * @param ix The interaction object
 * @param key The dot-notation key path (e.g., "message.arguments")
 * @param fallback The fallback value if the key is not found
 * @returns The value at the key path or the fallback value
 *
 * @example
 * import { get, put, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 *
 * // Set a value first
 * put("user.name", "Alice")(interaction);
 *
 * // Get the value
 * const userName = get(interaction, "user.name"); // "Alice"
 * const userAge = get(interaction, "user.age", 25); // 25 (fallback)
 *
 * // Get nested values
 * put("config.network.url", "https://access.mainnet.onflow.org")(interaction);
 * const networkUrl = get(interaction, "config.network.url");
 */
const get = function (ix, key) {
  let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return ix.assigns[key] == null ? fallback : ix.assigns[key];
};

/**
 * Sets a value in an interaction object using a dot-notation key path.
 *
 * @param key The dot-notation key path (e.g., "message.arguments")
 * @param value The value to set
 * @returns A function that takes an interaction and sets the value
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { put } from "@onflow/sdk"
 *
 * // Using put in a custom builder function
 * const setCustomData = (data) => put("custom.data", data);
 *
 * await fcl.send([
 *   fcl.script`access(all) fun main(): String { return "Hello" }`,
 *   setCustomData({ userId: 123, timestamp: Date.now() })
 * ]);
 *
 * // Direct usage
 * const interaction = initInteraction();
 * put("network.endpoint", "https://access.mainnet.onflow.org")(interaction);
 */
const put = (key, value) => ix => {
  ix.assigns[key] = value;
  return Ok(ix);
};

/**
 * Updates a value in an interaction object using a transformation function.
 *
 * @param key The dot-notation key path to update
 * @param fn The transformation function to apply to the existing value
 * @returns A function that takes an interaction and updates the value
 *
 * @example
 * import { update, put, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 *
 * // Set initial value
 * put("counter", 0)(interaction);
 *
 * // Increment counter
 * const increment = update("counter", (current) => (current || 0) + 1);
 * increment(interaction); // counter becomes 1
 * increment(interaction); // counter becomes 2
 *
 * // Update array
 * put("tags", ["flow", "blockchain"])(interaction);
 * const addTag = update("tags", (tags) => [...(tags || []), "web3"]);
 * addTag(interaction); // tags becomes ["flow", "blockchain", "web3"]
 */
const update = function (key) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
  return ix => {
    ix.assigns[key] = fn(ix.assigns[key], ix);
    return Ok(ix);
  };
};

/**
 * Removes a property from an interaction object using a dot-notation key path.
 *
 * @param key The dot-notation key path to remove
 * @returns A function that takes an interaction and removes the property
 *
 * @example
 * import { destroy, put, get, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 *
 * // Set some values
 * put("user.name", "Alice")(interaction);
 * put("user.email", "alice@example.com")(interaction);
 * put("user.temp", "temporary data")(interaction);
 *
 * console.log(get(interaction, "user.temp")); // "temporary data"
 *
 * // Remove temporary data
 * destroy("user.temp")(interaction);
 *
 * console.log(get(interaction, "user.temp")); // undefined
 * console.log(get(interaction, "user.name")); // "Alice" (still exists)
 */
const destroy = key => ix => {
  delete ix.assigns[key];
  return Ok(ix);
};

var ixModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Bad: Bad,
  Ok: Ok,
  destroy: destroy,
  get: get,
  initAccount: initAccount,
  initInteraction: initInteraction,
  interaction: interaction,
  isAccount: isAccount,
  isArgument: isArgument,
  isArray: isArray$1,
  isBad: isBad,
  isFn: isFn$3,
  isGetAccount: isGetAccount,
  isGetBlock: isGetBlock,
  isGetBlockHeader: isGetBlockHeader,
  isGetCollection: isGetCollection,
  isGetEvents: isGetEvents,
  isGetNetworkParameters: isGetNetworkParameters,
  isGetNodeVersionInfo: isGetNodeVersionInfo,
  isGetTransaction: isGetTransaction,
  isGetTransactionStatus: isGetTransactionStatus,
  isInteraction: isInteraction,
  isNull: isNull,
  isNumber: isNumber$1,
  isObj: isObj,
  isOk: isOk,
  isPing: isPing,
  isScript: isScript,
  isSubscribeEvents: isSubscribeEvents,
  isTransaction: isTransaction,
  isUnknown: isUnknown,
  makeArgument: makeArgument,
  makeGetAccount: makeGetAccount,
  makeGetBlock: makeGetBlock,
  makeGetBlockHeader: makeGetBlockHeader,
  makeGetCollection: makeGetCollection,
  makeGetEvents: makeGetEvents,
  makeGetNetworkParameters: makeGetNetworkParameters,
  makeGetNodeVerionInfo: makeGetNodeVerionInfo,
  makeGetTransaction: makeGetTransaction,
  makeGetTransactionStatus: makeGetTransactionStatus,
  makePing: makePing,
  makeScript: makeScript,
  makeSubscribeEvents: makeSubscribeEvents,
  makeTransaction: makeTransaction,
  makeUnknown: makeUnknown,
  pipe: pipe,
  prepAccount: prepAccount,
  put: put,
  update: update,
  why: why
});

/**
 * A builder function that creates an interaction from an array of builder functions.
 *
 * The build function takes an array of builder functions and applies them to create a complete interaction object. This is the foundation for constructing all interactions in Flow, whether they're scripts, transactions, or queries.
 *
 * Each builder function modifies specific parts of the interaction object, such as adding Cadence code, arguments, authorization details, or other configuration.
 *
 * @param fns The functions to apply to the interaction
 * @returns A promise of an interaction
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Build a script interaction
 * const scriptInteraction = await fcl.build([
 *   fcl.script`
 *     access(all) fun main(a: Int, b: Int): Int {
 *       return a + b
 *     }
 *   `,
 *   fcl.args([
 *     fcl.arg(1, fcl.t.Int),
 *     fcl.arg(2, fcl.t.Int)
 *   ])
 * ]);
 *
 * // Build a transaction interaction
 * const txInteraction = await fcl.build([
 *   fcl.transaction`
 *     transaction(name: String) {
 *       prepare(account: AuthAccount) {
 *         log("Hello, " + name)
 *       }
 *     }
 *   `,
 *   fcl.args([fcl.arg("World", fcl.t.String)]),
 *   fcl.proposer(proposerAuthz),
 *   fcl.payer(payerAuthz),
 *   fcl.authorizations([authorizerAuthz]),
 *   fcl.limit(100)
 * ]);
 */
function build() {
  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(initInteraction(), fns);
}

const DEFAULT_RESPONSE = {
  tag: null,
  transaction: null,
  transactionStatus: null,
  transactionId: null,
  encodedData: null,
  events: null,
  event: null,
  accountStatusEvent: null,
  account: null,
  block: null,
  blockHeader: null,
  blockDigest: null,
  latestBlock: null,
  collection: null,
  networkParameters: null,
  streamConnection: null,
  heartbeat: null,
  nodeVersionInfo: null
};

/**
 * Creates a default response object
 *
 * @returns A default response object
 *
 * @example
 * import { response } from "@onflow/sdk"
 *
 * // Create a default response object
 * const defaultResponse = response();
 * console.log(defaultResponse.transaction); // null
 * console.log(defaultResponse.account); // null
 * console.log(defaultResponse.block); // null
 *
 * // Typically used internally by the SDK to initialize responses
 * // You'll rarely need to use this directly in application code
 */
const response = () => ({
  ...DEFAULT_RESPONSE
});

/**
 * A builder function that returns the interaction to get the latest block.
 *
 * Use with 'fcl.atBlockId()' and 'fcl.atBlockHeight()' when building the interaction to get information for older blocks.
 *
 * Consider using the pre-built interaction 'fcl.block(options)' if you do not need to pair with any other builders.
 *
 * Block ID is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from 'GetLatestBlock').
 *
 * Block height expresses the height of the block on the chain. The latest block height increases by one for every valid block produced.
 *
 * @param isSealed If the latest block should be sealed or not. See block states
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * const latestSealedBlock = await fcl.send([
 *   fcl.getBlock(true) // isSealed = true
 * ]).then(fcl.decode);
 */
function getBlock() {
  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetBlock, ix => {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns the interaction to get an account by address.
 *
 * Consider using the pre-built interaction 'fcl.account(address)' if you do not need to pair with any other builders.
 *
 * Account address is a unique account identifier. Be mindful about the '0x' prefix, you should use the prefix as a default representation but be careful and safely handle user inputs without the prefix.
 *
 * @param address Address of the user account with or without a prefix (both formats are supported)
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // somewhere in an async function
 * // fcl.account is the same as this function
 * const getAccount = async (address) => {
 *   const account = await fcl.send([fcl.getAccount(address)]).then(fcl.decode);
 *   return account;
 * };
 */
function getAccount(addr) {
  return pipe([makeGetAccount, ix => {
    ix.account.addr = utilAddress.sansPrefix(addr);
    return Ok(ix);
  }]);
}

/**
 * Pipes a generic stream of data into a granular stream of decoded data.
 *
 * The data is decoded per channel and emitted in order. This function is particularly useful
 * for handling streaming responses from Flow Access API, such as event subscriptions or
 * real-time block updates. It ensures that data is properly decoded and emitted in the
 * correct order while maintaining the stream's event-driven nature.
 *
 * All topics for a given message will be emitted synchronously before moving on to the next
 * message. The internal queue ensures that data is emitted in order and avoids race conditions
 * when decoding.
 *
 * @param stream The raw stream connection to decode
 * @param decodeResponse Function to decode response data
 * @param customDecoders Optional custom decoders for specific data types
 * @returns A new stream connection with decoded data
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Create a subscription stream
 * const rawStream = await fcl.send([
 *   fcl.subscribeEvents({
 *     eventTypes: ["flow.AccountCreated"],
 *     startHeight: 0
 *   })
 * ]);
 *
 * // Decode the stream data
 * const decodedStream = fcl.decodeStream(
 *   rawStream,
 *   fcl.decodeResponse,
 *   {}
 * );
 *
 * // Listen for decoded events
 * decodedStream.on("events", (events) => {
 *   events.forEach(event => {
 *     console.log("Decoded event:", event);
 *   });
 * });
 *
 * decodedStream.on("error", (error) => {
 *   console.error("Stream error:", error);
 * });
 *
 * decodedStream.on("close", () => {
 *   console.log("Stream closed");
 * });
 */
const decodeStream = (stream, decodeResponse, customDecoders) => {
  const newStream = new EventEmitter();
  let queue = taskQueue();

  // Data is separated by topic & the decoded data is emitted in order
  // All topics for a given message will be emitted synchronously before moving on to the next message
  // The streamReady promise ensures that the data is emitted in order and avoids race conditions when decoding
  stream.on("data", async data => {
    const topics = Object.keys(data).filter(key => data[key] != null && key !== "tag");
    let newDataPromise = Promise.all(topics.map(async channel => {
      const partialResponse = {
        [channel]: data[channel]
      };
      const message = await decodeResponse(partialResponse, customDecoders);
      return {
        channel,
        message
      };
    }));
    queue.push(async () => {
      // Emit the new data
      const newData = await newDataPromise;
      newData.forEach(_ref => {
        let {
          channel,
          message
        } = _ref;
        newStream.emit(channel, message);
      });
    });
  });

  // Relay events from the original stream
  // These events are delivered in order as well so that the stream will
  // not emit more data after it has announced a contradictory state
  function relayEvent(event) {
    stream.on(event, message => {
      queue.push(async () => {
        newStream.emit(event, message);
      });
    });
  }
  relayEvent("close");
  relayEvent("error");
  return {
    on(channel, callback) {
      newStream.on(channel, callback);
      return this;
    },
    off(channel, callback) {
      newStream.off(channel, callback);
      return this;
    },
    close: () => {
      stream.close();
    }
  };
};
function taskQueue() {
  let queue = [];
  let running = false;
  async function run() {
    if (running) return;
    running = true;
    while (queue.length > 0) {
      const task = queue.shift();
      await task?.();
    }
    running = false;
  }
  return {
    push: task => {
      queue.push(task);
      run();
    }
  };
}

const latestBlockDeprecationNotice = () => {
  logger.log.deprecate({
    pkg: "@onflow/decode",
    subject: "Operating upon data of the latestBlock field of the response object",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
  });
};
const decodeImplicit = async i => i;
const decodeVoid = async () => null;
const decodeType = async type => {
  return type.staticType;
};
const decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;
const decodeArray = async (array, decoders, stack) => await Promise.all(array.map(v => new Promise(async res => res(await recurseDecode(v, decoders, [...stack, v.type])))));
const decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {
  acc = await acc;
  acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);
  return acc;
}, Promise.resolve({}));
const decodeComposite = async (composite, decoders, stack) => {
  const decoded = await composite.fields.reduce(async (acc, v) => {
    acc = await acc;
    acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);
    return acc;
  }, Promise.resolve({}));
  const decoder = composite.id && decoderLookup(decoders, composite.id);
  return decoder ? await decoder(decoded) : decoded;
};
const decodeInclusiveRange = async (range, decoders, stack) => {
  // Recursive decode for start, end, and step
  // We don't do all fields just in case there are future API changes
  // where fields added and are not Cadence values
  const keys = ["start", "end", "step"];
  const decoded = await Object.keys(range).reduce(async (acc, key) => {
    acc = await acc;
    if (keys.includes(key)) {
      acc[key] = await recurseDecode(range[key], decoders, [...stack, key]);
    }
    return acc;
  }, Promise.resolve({}));
  return decoded;
};
const defaultDecoders = {
  UInt: decodeImplicit,
  Int: decodeImplicit,
  UInt8: decodeImplicit,
  Int8: decodeImplicit,
  UInt16: decodeImplicit,
  Int16: decodeImplicit,
  UInt32: decodeImplicit,
  Int32: decodeImplicit,
  UInt64: decodeImplicit,
  Int64: decodeImplicit,
  UInt128: decodeImplicit,
  Int128: decodeImplicit,
  UInt256: decodeImplicit,
  Int256: decodeImplicit,
  Word8: decodeImplicit,
  Word16: decodeImplicit,
  Word32: decodeImplicit,
  Word64: decodeImplicit,
  Word128: decodeImplicit,
  Word256: decodeImplicit,
  UFix64: decodeImplicit,
  Fix64: decodeImplicit,
  String: decodeImplicit,
  Character: decodeImplicit,
  Bool: decodeImplicit,
  Address: decodeImplicit,
  Void: decodeVoid,
  Optional: decodeOptional,
  Reference: decodeImplicit,
  Array: decodeArray,
  Dictionary: decodeDictionary,
  Event: decodeComposite,
  Resource: decodeComposite,
  Struct: decodeComposite,
  Enum: decodeComposite,
  Type: decodeType,
  Path: decodeImplicit,
  Capability: decodeImplicit,
  InclusiveRange: decodeInclusiveRange
};
const decoderLookup = (decoders, lookup) => {
  const found = Object.keys(decoders).find(decoder => {
    if (/^\/.*\/$/.test(decoder)) {
      const reg = new RegExp(decoder.substring(1, decoder.length - 1));
      return reg.test(lookup);
    }
    return decoder === lookup;
  });
  return lookup && found && decoders[found];
};
const recurseDecode = async (decodeInstructions, decoders, stack) => {
  let decoder = decoderLookup(decoders, decodeInstructions.type);
  if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(".")}`);
  return await decoder(decodeInstructions.value, decoders, stack);
};

/**
 * @description - Decodes a response from Flow into JSON
 * @param decodeInstructions - The response object from Flow
 * @param customDecoders - An object of custom decoders
 * @param stack - The stack of the current decoding
 * @returns - The decoded response
 */
const decode$1 = async function (decodeInstructions) {
  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // Filter out all default decoders which are overridden by a custom decoder regex
  const filteredDecoders = Object.keys(defaultDecoders).filter(decoder => !Object.keys(customDecoders).find(customDecoder => new RegExp(customDecoder).test(decoder))).reduce((decoders, decoderKey) => {
    decoders[decoderKey] = defaultDecoders[decoderKey];
    return decoders;
  }, customDecoders);
  const decoders = {
    ...filteredDecoders,
    ...customDecoders
  };
  return recurseDecode(decodeInstructions, decoders, stack);
};

/**
 * Decodes a response from Flow into JSON
 *
 * @param response The response object from Flow
 * @param customDecoders An object of custom decoders
 * @returns The decoded response
 */
const decodeResponse = async function (response) {
  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (response.encodedData) {
    return decode$1(response.encodedData, customDecoders);
  } else if (response.transactionStatus) {
    return {
      ...response.transactionStatus,
      events: await Promise.all(response.transactionStatus.events.map(async function decodeEvents(e) {
        return {
          type: e.type,
          transactionId: e.transactionId,
          transactionIndex: e.transactionIndex,
          eventIndex: e.eventIndex,
          data: await decode$1(e.payload, customDecoders)
        };
      }))
    };
  } else if (response.transaction) {
    return response.transaction;
  } else if (response.events) {
    return await Promise.all(response.events.map(async function decodeEvents(e) {
      return {
        blockId: e.blockId,
        blockHeight: e.blockHeight,
        blockTimestamp: e.blockTimestamp,
        type: e.type,
        transactionId: e.transactionId,
        transactionIndex: e.transactionIndex,
        eventIndex: e.eventIndex,
        data: await decode$1(e.payload, customDecoders)
      };
    }));
  } else if (response.event) {
    const {
      payload,
      ...rest
    } = response.event;
    return {
      ...rest,
      data: await decode$1(payload, customDecoders)
    };
  } else if (response.accountStatusEvent) {
    const {
      payload,
      ...rest
    } = response.accountStatusEvent;
    return {
      ...rest,
      data: await decode$1(payload, customDecoders)
    };
  } else if (response.account) {
    return response.account;
  } else if (response.block) {
    return response.block;
  } else if (response.blockHeader) {
    return response.blockHeader;
  } else if (response.blockDigest) {
    return response.blockDigest;
  } else if (response.latestBlock) {
    latestBlockDeprecationNotice();
    return response.latestBlock;
  } else if (response.transactionId) {
    return response.transactionId;
  } else if (response.collection) {
    return response.collection;
  } else if (response.networkParameters) {
    const prefixRegex = /^flow-/;
    const rawChainId = response.networkParameters.chainId;
    let formattedChainId;
    if (rawChainId === "flow-emulator") {
      formattedChainId = "local";
    } else if (prefixRegex.test(rawChainId)) {
      formattedChainId = rawChainId.replace(prefixRegex, "");
    } else {
      formattedChainId = rawChainId;
    }
    return {
      chainId: formattedChainId
    };
  } else if (response.streamConnection) {
    return decodeStream(response.streamConnection, decodeResponse, customDecoders);
  } else if (response.heartbeat) {
    return response.heartbeat;
  } else if (response.nodeVersionInfo) {
    return response.nodeVersionInfo;
  }
  return null;
};

class SubscriptionsNotSupportedError extends Error {
  constructor() {
    super(`The current transport does not support subscriptions.  If you have provided a custom transport (e.g. via \`sdk.transport\` configuration), ensure that it implements the subscribe method.`);
    this.name = "SubscriptionsNotSupportedError";
  }
}

/**
 * Get the SDK transport object, either from the provided override or from the global config.
 *
 * The transport object handles communication with Flow Access Nodes, including sending transactions,
 * executing scripts, and managing subscriptions. This function resolves the transport configuration
 * from various sources with the following priority order:
 * 1. Provided override parameters
 * 2. Global SDK configuration
 * 3. Default HTTP transport
 *
 * @param override Override default configuration with custom transport or send function
 * @param override.send Custom send function for backwards compatibility with legacy configurations
 * @param override.transport Complete transport object with both send and subscribe capabilities
 * @returns The resolved SDK transport object with send and subscribe methods
 *
 * @throws {Error} When both transport and send options are provided simultaneously
 * @throws {SubscriptionsNotSupportedError} When attempting to subscribe using a legacy send-only transport
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { httpTransport } from "@onflow/transport-http";
 *
 * // Get default transport (usually HTTP transport)
 * const defaultTransport = await fcl.getTransport();
 *
 * // Override with custom transport
 * const customTransport = await fcl.getTransport({
 *   transport: httpTransport({
 *     accessNode: "https://rest-mainnet.onflow.org",
 *     timeout: 10000
 *   })
 * });
 */
function getGlobalTransport(cfg) {
  const transportOrSend = cfg["sdk.transport"] || cfg["sdk.send"] || transportHttp.httpTransport;

  // Backwards compatibility with legacy send function
  if (!isTransportObject(transportOrSend)) {
    return {
      send: transportOrSend,
      subscribe: () => {
        throw new SubscriptionsNotSupportedError();
      }
    };
  }
  return transportOrSend;
}
function isTransportObject(transport) {
  return transport.send !== undefined && transport.subscribe !== undefined && typeof transport.send === "function" && typeof transport.subscribe === "function";
}

const DEFAULT_COMPUTE_LIMIT = 10;
let cachedContext;
async function createGlobalContext() {
  const globalConfig = await config.config().all();
  return {
    get transport() {
      return getGlobalTransport(globalConfig);
    },
    get accessNodeUrl() {
      const accessNodeUrl = globalConfig["accessNode.api"];
      utilInvariant.invariant(!!accessNodeUrl, `Either opts.node or "accessNode.api" in config must be defined.`);
      return accessNodeUrl;
    },
    get computeLimit() {
      const computeLimit = globalConfig["fcl.limit"];
      if (!computeLimit) {
        logger.log.deprecate({
          pkg: "FCL/SDK",
          subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
          transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
        });
        return DEFAULT_COMPUTE_LIMIT;
      }
      return computeLimit;
    },
    get customResolver() {
      const customResolver = globalConfig["sdk.resolve"];
      return customResolver;
    },
    get customDecoders() {
      return Object.fromEntries(Object.entries(globalConfig).filter(_ref => {
        let [key] = _ref;
        return key.startsWith("decoder.");
      }));
    },
    get contracts() {
      return Object.fromEntries(Object.entries(globalConfig).filter(_ref2 => {
        let [key] = _ref2;
        return key.startsWith("system.contracts.");
      }).map(_ref3 => {
        let [key, value] = _ref3;
        return [key.replace("system.contracts.", ""), value];
      }));
    },
    get debug() {
      return Object.fromEntries(Object.entries(globalConfig).filter(_ref4 => {
        let [key] = _ref4;
        return key.startsWith("debug.");
      }));
    },
    get legacyContractIdentifiers() {
      return Object.fromEntries(Object.entries(globalConfig).filter(_ref5 => {
        let [key] = _ref5;
        return key.startsWith("0x");
      }));
    }
  };
}
async function getGlobalContext() {
  if (!cachedContext) {
    // Watch for changes in the config and recreate the context if needed
    config.config().subscribe(() => {
      cachedContext = createGlobalContext();
    });

    // Create the context for the first time
    cachedContext = createGlobalContext();
  }
  return cachedContext instanceof Promise ? cachedContext : cachedContext;
}
function withGlobalContext(fn) {
  return async function () {
    const context = await getGlobalContext();
    return fn(context)(...arguments);
  };
}

const isFn$2 = v => typeof v === "function";
const isString$1 = v => typeof v === "string";
const oldIdentifierPatternFn = () => /\b(0x\w+)\b/g;
function isOldIdentifierSyntax(cadence) {
  return oldIdentifierPatternFn().test(cadence);
}
const newIdentifierPatternFn = () => /import\s+"(\w+)"/g;
function isNewIdentifierSyntax(cadence) {
  return newIdentifierPatternFn().test(cadence);
}
function getContractIdentifierSyntaxMatches(cadence) {
  return cadence.matchAll(newIdentifierPatternFn());
}
function createResolveCadence(context) {
  return async function resolveCadence(ix) {
    if (!isTransaction(ix) && !isScript(ix)) return ix;
    var cadence = get(ix, "ix.cadence");
    utilInvariant.invariant(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");
    if (isFn$2(cadence)) cadence = await cadence({});
    utilInvariant.invariant(isString$1(cadence), "Cadence needs to be a string at this point.");
    utilInvariant.invariant(!isOldIdentifierSyntax(cadence) || !isNewIdentifierSyntax(cadence), "Both account identifier and contract identifier syntax not simultaneously supported.");
    if (isOldIdentifierSyntax(cadence)) {
      cadence = Object.entries(context.legacyContractIdentifiers || {}).reduce((cadence, _ref) => {
        let [key, value] = _ref;
        const regex = new RegExp("(\\b" + key + "\\b)", "g");
        return cadence.replace(regex, value);
      }, cadence);
    }
    if (isNewIdentifierSyntax(cadence)) {
      for (const [fullMatch, contractName] of getContractIdentifierSyntaxMatches(cadence)) {
        const address = context.contracts[contractName] || null;
        if (address) {
          cadence = cadence.replace(fullMatch, `import ${contractName} from ${utilAddress.withPrefix(address)}`);
        } else {
          logger__namespace.log({
            title: "Contract Placeholder not found",
            message: `Cannot find a value for contract placeholder ${contractName}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,
            level: logger__namespace.LEVELS.warn
          });
        }
      }
    }

    // We need to move this over in any case.
    ix.message.cadence = cadence;
    return ix;
  };
}
const resolveCadence = /* @__PURE__ */withGlobalContext(createResolveCadence);

const isFn$1 = v => typeof v === "function";
function cast(arg) {
  // prettier-ignore
  utilInvariant.invariant(typeof arg.xform != null, `No type specified for argument: ${arg.value}`);
  if (isFn$1(arg.xform)) return arg.xform(arg.value);
  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value);

  // prettier-ignore
  utilInvariant.invariant(false, `Invalid Argument`, arg);
}
async function handleArgResolution(arg) {
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  utilInvariant.invariant(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg.tempId}`);
  if (isFn$1(arg.resolveArgument)) {
    const resolvedArg = await arg.resolveArgument();
    return handleArgResolution(resolvedArg, depth - 1);
  } else {
    return arg;
  }
}

/**
 * Resolves transaction arguments by evaluating argument functions and converting them to appropriate types.
 *
 * This function processes all arguments in a transaction or script interaction, calling their transform functions
 * to convert JavaScript values into Cadence-compatible argument formats that can be sent to the Flow network.
 *
 * The resolution process includes:
 * - Calling argument resolver functions if present
 * - Applying type transformations using the xform field
 * - Handling recursive argument resolution up to a depth limit
 *
 * @param ix The interaction object containing arguments to resolve
 * @returns The interaction with resolved arguments ready for network transmission
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Arguments are automatically resolved during send()
 * await fcl.send([
 *   fcl.script`
 *     access(all) fun main(amount: UFix64, recipient: Address): String {
 *       return "Sending ".concat(amount.toString()).concat(" to ").concat(recipient.toString())
 *     }
 *   `,
 *   fcl.args([
 *     fcl.arg("100.0", fcl.t.UFix64),    // Will be resolved to Cadence UFix64
 *     fcl.arg("0x01", fcl.t.Address)     // Will be resolved to Cadence Address
 *   ])
 * ]).then(fcl.decode);
 *
 * // The resolveArguments function handles the conversion automatically
 */
async function resolveArguments(ix) {
  if (isTransaction(ix) || isScript(ix)) {
    for (let [id, arg] of Object.entries(ix.arguments)) {
      const res = await handleArgResolution(arg);
      ix.arguments[id].asArgument = cast(res);
    }
  }
  return ix;
}

/**
 * Encodes a transaction payload for signing.
 *
 * This function takes a transaction object and encodes it into a format suitable for signing.
 * The encoded payload contains all the transaction details except for the signatures.
 *
 * @param tx The transaction object to encode
 * @returns A hex-encoded string representing the transaction payload
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { encodeTransactionPayload } from "@onflow/sdk"
 *
 * // Build a transaction
 * const transaction = await fcl.build([
 *   fcl.transaction`
 *     transaction(amount: UFix64) {
 *       prepare(account: AuthAccount) {
 *         log("Transferring: ".concat(amount.toString()))
 *       }
 *     }
 *   `,
 *   fcl.args([fcl.arg("10.0", fcl.t.UFix64)]),
 *   fcl.proposer(proposerAuthz),
 *   fcl.payer(payerAuthz),
 *   fcl.authorizations([authorizerAuthz]),
 *   fcl.limit(100)
 * ]);
 *
 * // Encode the transaction payload for signing
 * const encodedPayload = encodeTransactionPayload(transaction);
 * console.log("Encoded payload:", encodedPayload);
 * // Returns a hex string like "f90145b90140..."
 */
const encodeTransactionPayload = tx => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));

/**
 * Encodes a complete transaction envelope including payload and signatures.
 *
 * This function encodes the full transaction including both the payload and all signatures.
 * This is the final step before submitting a transaction to the Flow network.
 *
 * @param tx The transaction object to encode
 * @returns A hex-encoded string representing the complete transaction envelope
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { encodeTransactionEnvelope } from "@onflow/sdk"
 *
 * // Assuming you have a fully built and signed transaction
 * const signedTransaction = await fcl.build([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Hello, Flow!")
 *       }
 *     }
 *   `,
 *   fcl.proposer(authz),
 *   fcl.payer(authz),
 *   fcl.authorizations([authz]),
 *   fcl.limit(100)
 * ]);
 *
 * // Add signatures to the transaction (this is usually done automatically)
 * // signedTransaction.payloadSigs = [...];
 * // signedTransaction.envelopeSigs = [...];
 *
 * // Encode the complete transaction envelope
 * const encodedEnvelope = encodeTransactionEnvelope(signedTransaction);
 * console.log("Encoded envelope:", encodedEnvelope);
 * // Returns a hex string ready for network submission
 */
const encodeTransactionEnvelope = tx => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));

/**
 * Encodes a transaction ID from a voucher by computing its hash.
 *
 * A voucher is an intermediary object that contains transaction details before final encoding.
 * This function computes the transaction ID that would result from submitting the transaction.
 *
 * @param voucher The voucher object containing transaction details
 * @returns A hex-encoded string representing the transaction ID
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { encodeTxIdFromVoucher } from "@onflow/sdk"
 *
 * // Create a voucher (usually done internally by FCL)
 * const voucher = {
 *   cadence: `
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Hello")
 *       }
 *     }
 *   `,
 *   arguments: [],
 *   refBlock: "abc123...",
 *   computeLimit: 100,
 *   proposalKey: {
 *     address: "0x123456789abcdef0",
 *     keyId: 0,
 *     sequenceNum: 42
 *   },
 *   payer: "0x123456789abcdef0",
 *   authorizers: ["0x123456789abcdef0"],
 *   payloadSigs: [],
 *   envelopeSigs: []
 * };
 *
 * // Calculate the transaction ID
 * const txId = encodeTxIdFromVoucher(voucher);
 * console.log("Transaction ID:", txId);
 * // Returns a transaction ID that can be used to track the transaction
 */
const encodeTxIdFromVoucher = voucher => sha3_256(rlpEncode(prepareVoucher(voucher)));
const rightPaddedHexBuffer = (value, pad) => rlp.Buffer.from(value.padEnd(pad * 2, "0"), "hex");
const leftPaddedHexBuffer = (value, pad) => rlp.Buffer.from(value.padStart(pad * 2, "0"), "hex");
const TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(rlp.Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");
const prependTransactionDomainTag = tx => TRANSACTION_DOMAIN_TAG + tx;
const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);
const blockBuffer = block => leftPaddedHexBuffer(block, 32);
const argumentToString = arg => rlp.Buffer.from(JSON.stringify(arg), "utf8");
const scriptBuffer = script => rlp.Buffer.from(script, "utf8");
const signatureBuffer = signature => rlp.Buffer.from(signature, "hex");
const rlpEncode = v => {
  return rlp.encode(v).toString("hex");
};
const sha3_256 = msg => {
  const sha = new sha3.SHA3(256);
  sha.update(rlp.Buffer.from(msg, "hex"));
  return sha.digest().toString("hex");
};
const preparePayload = tx => {
  validatePayload(tx);
  return [scriptBuffer(tx.cadence || ""), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock || ""), tx.computeLimit, addressBuffer(utilAddress.sansPrefix(tx.proposalKey.address || "")), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(utilAddress.sansPrefix(tx.payer)), tx.authorizers.map(authorizer => addressBuffer(utilAddress.sansPrefix(authorizer)))];
};
const prepareEnvelope = tx => {
  validateEnvelope(tx);
  return [preparePayload(tx), preparePayloadSignatures(tx)];
};
const preparePayloadSignatures = tx => {
  const signers = collectSigners(tx);
  return tx.payloadSigs?.map(sig => {
    return {
      signerIndex: signers.get(utilAddress.sansPrefix(sig.address)) || "",
      keyId: sig.keyId,
      sig: sig.sig
    };
  }).sort((a, b) => {
    if (a.signerIndex > b.signerIndex) return 1;
    if (a.signerIndex < b.signerIndex) return -1;
    if (a.keyId > b.keyId) return 1;
    if (a.keyId < b.keyId) return -1;
    return 0;
  }).map(sig => {
    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
  });
};
const collectSigners = tx => {
  const signers = new Map();
  let i = 0;
  const addSigner = addr => {
    if (!signers.has(addr)) {
      signers.set(addr, i);
      i++;
    }
  };
  if (tx.proposalKey.address) {
    addSigner(tx.proposalKey.address);
  }
  addSigner(tx.payer);
  tx.authorizers.forEach(addSigner);
  return signers;
};
const prepareVoucher = voucher => {
  validateVoucher(voucher);
  const signers = collectSigners(voucher);
  const prepareSigs = sigs => {
    return sigs.map(_ref => {
      let {
        address,
        keyId,
        sig
      } = _ref;
      return {
        signerIndex: signers.get(utilAddress.sansPrefix(address)) || "",
        keyId,
        sig
      };
    }).sort((a, b) => {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
      return 0;
    }).map(sig => {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };
  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(utilAddress.sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(utilAddress.sansPrefix(voucher.payer)), voucher.authorizers.map(authorizer => addressBuffer(utilAddress.sansPrefix(authorizer)))], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
};
const validatePayload = tx => {
  payloadFields.forEach(field => checkField(tx, field));
  proposalKeyFields.forEach(field => checkField(tx.proposalKey, field, "proposalKey"));
};
const validateEnvelope = tx => {
  payloadSigsFields.forEach(field => checkField(tx, field));
  tx.payloadSigs?.forEach((sig, index) => {
    payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
  });
};
const validateVoucher = voucher => {
  payloadFields.forEach(field => checkField(voucher, field));
  proposalKeyFields.forEach(field => checkField(voucher.proposalKey, field, "proposalKey"));
  payloadSigsFields.forEach(field => checkField(voucher, field));
  voucher.payloadSigs.forEach((sig, index) => {
    payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
  });
  envelopeSigsFields.forEach(field => checkField(voucher, field));
  voucher.envelopeSigs.forEach((sig, index) => {
    envelopeSigFields.forEach(field => checkField(sig, field, "envelopeSigs", index));
  });
};
const isNumber = v => typeof v === "number";
const isString = v => typeof v === "string";
const isObject = v => v !== null && typeof v === "object";
const isArray = v => isObject(v) && v instanceof Array;
const payloadFields = [{
  name: "cadence",
  check: isString
}, {
  name: "arguments",
  check: isArray
}, {
  name: "refBlock",
  check: isString,
  defaultVal: "0"
}, {
  name: "computeLimit",
  check: isNumber
}, {
  name: "proposalKey",
  check: isObject
}, {
  name: "payer",
  check: isString
}, {
  name: "authorizers",
  check: isArray
}];
const proposalKeyFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sequenceNum",
  check: isNumber
}];
const payloadSigsFields = [{
  name: "payloadSigs",
  check: isArray
}];
const payloadSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
const envelopeSigsFields = [{
  name: "envelopeSigs",
  check: isArray
}];
const envelopeSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
const checkField = (obj, field, base, index) => {
  const {
    name,
    check,
    defaultVal
  } = field;
  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
  if (obj[name] == null) throw missingFieldError(name, base, index);
  if (!check(obj[name])) throw invalidFieldError(name, base, index);
};
const printFieldName = (field, base, index) => {
  if (!!base) return index == null ? `${base}.${field}` : `${base}.${index}.${field}`;
  return field;
};
const missingFieldError = (field, base, index) => new Error(`Missing field ${printFieldName(field, base, index)}`);
const invalidFieldError = (field, base, index) => new Error(`Invalid field ${printFieldName(field, base, index)}`);

/**
 * Identifies signers for the transaction payload (authorizers + proposer, excluding payer).
 *
 * This function determines which accounts need to sign the transaction payload. Payload signers include
 * all authorizers and the proposer, but exclude the payer (who signs the envelope).
 *
 * @param ix The interaction object
 * @returns Array of account tempIds that need to sign the payload
 *
 * @example
 * import { findInsideSigners, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * // Assume we have account tempIds: "proposer-123", "auth-456", "payer-789"
 * interaction.proposer = "proposer-123";
 * interaction.authorizations = ["auth-456"];
 * interaction.payer = "payer-789";
 *
 * const insideSigners = findInsideSigners(interaction);
 * console.log(insideSigners); // ["auth-456", "proposer-123"]
 * // Note: payer is excluded from payload signers
 */
function findInsideSigners(ix) {
  // Inside Signers Are: (authorizers + proposer) - payer
  let inside = new Set(ix.authorizations);
  if (ix.proposer) {
    inside.add(ix.proposer);
  }
  if (Array.isArray(ix.payer)) {
    ix.payer.forEach(p => inside.delete(p));
  } else {
    inside.delete(ix.payer);
  }
  return Array.from(inside);
}

/**
 * Identifies signers for the transaction envelope (payer accounts only).
 *
 * This function determines which accounts need to sign the transaction envelope. Envelope signers
 * are only the payer accounts, who are responsible for transaction fees.
 *
 * @param ix The interaction object
 * @returns Array of account tempIds that need to sign the envelope
 *
 * @example
 * import { findOutsideSigners, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * interaction.proposer = "proposer-123";
 * interaction.authorizations = ["auth-456"];
 * interaction.payer = "payer-789";
 *
 * const outsideSigners = findOutsideSigners(interaction);
 * console.log(outsideSigners); // ["payer-789"]
 * // Only the payer signs the envelope
 *
 * // Multiple payers example
 * interaction.payer = ["payer-789", "payer-abc"];
 * const multiplePayerSigners = findOutsideSigners(interaction);
 * console.log(multiplePayerSigners); // ["payer-789", "payer-abc"]
 */
function findOutsideSigners(ix) {
  // Outside Signers Are: (payer)
  let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
  return Array.from(outside);
}

/**
 * Creates a signable voucher object from an interaction for signing purposes.
 *
 * A voucher is a standardized representation of a transaction that contains all the necessary
 * information for signing and submitting to the Flow network. This function transforms an
 * interaction object into a voucher format.
 *
 * @param ix The interaction object containing transaction details
 * @returns A voucher object containing all transaction data and signatures
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { createSignableVoucher } from "@onflow/sdk"
 *
 * // Build a transaction interaction
 * const interaction = await fcl.build([
 *   fcl.transaction`
 *     transaction(amount: UFix64) {
 *       prepare(account: AuthAccount) {
 *         log(amount)
 *       }
 *     }
 *   `,
 *   fcl.args([fcl.arg("10.0", fcl.t.UFix64)]),
 *   fcl.proposer(proposerAuthz),
 *   fcl.payer(payerAuthz),
 *   fcl.authorizations([authorizerAuthz]),
 *   fcl.limit(100)
 * ]);
 *
 * // Create a voucher for signing
 * const voucher = createSignableVoucher(interaction);
 * console.log(voucher.cadence); // The Cadence script
 * console.log(voucher.arguments); // The transaction arguments
 * console.log(voucher.proposalKey); // Proposer account details
 * console.log(voucher.authorizers); // List of authorizer addresses
 *
 * // The voucher can now be signed and submitted
 */
const createSignableVoucher = ix => {
  const buildAuthorizers = () => {
    const authorizations = ix.authorizations.map(cid => utilAddress.withPrefix(ix.accounts[cid].addr)).reduce((prev, current) => {
      return prev.find(item => item === current) ? prev : [...prev, current];
    }, []);
    return authorizations;
  };
  const buildInsideSigners = () => findInsideSigners(ix).map(id => ({
    address: utilAddress.withPrefix(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));
  const buildOutsideSigners = () => findOutsideSigners(ix).map(id => ({
    address: utilAddress.withPrefix(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));
  const proposalKey = ix.proposer ? {
    address: utilAddress.withPrefix(ix.accounts[ix.proposer].addr),
    keyId: ix.accounts[ix.proposer].keyId,
    sequenceNum: ix.accounts[ix.proposer].sequenceNum
  } : {};
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
    proposalKey,
    payer: utilAddress.withPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
    authorizers: buildAuthorizers(),
    payloadSigs: buildInsideSigners(),
    envelopeSigs: buildOutsideSigners()
  };
};

/**
 * Converts a voucher object to a transaction ID.
 *
 * This function computes the transaction ID by encoding and hashing the voucher.
 * The transaction ID can be used to track the transaction status on the Flow network.
 *
 * @param voucher The voucher object to convert
 * @returns A transaction ID string
 *
 * @example
 * import { voucherToTxId, createSignableVoucher } from "@onflow/sdk"
 * import * as fcl from "@onflow/fcl";
 *
 * // Create a voucher from an interaction
 * const interaction = await fcl.build([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Hello, Flow!")
 *       }
 *     }
 *   `,
 *   fcl.proposer(authz),
 *   fcl.payer(authz),
 *   fcl.authorizations([authz])
 * ]);
 *
 * const voucher = createSignableVoucher(interaction);
 *
 * // Calculate the transaction ID
 * const txId = voucherToTxId(voucher);
 * console.log("Transaction ID:", txId);
 * // Returns something like: "a1b2c3d4e5f6789..."
 *
 * // You can use this ID to track the transaction
 * const txStatus = await fcl.tx(txId).onceSealed();
 * console.log("Transaction status:", txStatus);
 */
const voucherToTxId = voucher => {
  return encodeTxIdFromVoucher(voucher);
};

const MAX_DEPTH_LIMIT = 5;
const idof$1 = acct => `${utilAddress.withPrefix(acct.addr)}-${acct.keyId}`;
const isFn = v => v && (Object.prototype.toString.call(v) === "[object Function]" || "function" === typeof v || v instanceof Function);
const genAccountId = function () {
  for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
    ids[_key] = arguments[_key];
  }
  return ids.join("-");
};
var ROLES = /*#__PURE__*/function (ROLES) {
  ROLES["PAYER"] = "payer";
  ROLES["PROPOSER"] = "proposer";
  ROLES["AUTHORIZATIONS"] = "authorizations";
  return ROLES;
}(ROLES || {});
function debug$1() {
  const SPACE = " ";
  const SPACE_COUNT_PER_INDENT = 4;
  const DEBUG_MESSAGE = [];
  return [function () {
    let msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    DEBUG_MESSAGE.push(Array(indent * SPACE_COUNT_PER_INDENT).fill(SPACE).join("-") + msg);
  }, function () {
    return DEBUG_MESSAGE.reduce((prev, curr) => prev + "\n" + curr);
  }];
}
function recurseFlatMap(el) {
  let depthLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  if (depthLimit <= 0) return el;
  if (!Array.isArray(el)) return el;
  return recurseFlatMap(el.flatMap(e => e), depthLimit - 1);
}

/**
 * Builds a pre-signable object containing interaction data before signing.
 *
 * @param acct The account to create the pre-signable for
 * @param ix The interaction object containing transaction details
 * @returns A pre-signable object conforming to the FCL pre-signable standard
 */
function buildPreSignable(acct, ix) {
  try {
    return {
      f_type: "PreSignable",
      f_vsn: "1.0.1",
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildPreSignable", error);
    throw error;
  }
}
async function removeUnusedIxAccounts(ix, opts) {
  const payerTempIds = Array.isArray(ix.payer) ? ix.payer : [ix.payer];
  const authorizersTempIds = Array.isArray(ix.authorizations) ? ix.authorizations : [ix.authorizations];
  const proposerTempIds = ix.proposer === null ? [] : Array.isArray(ix.proposer) ? ix.proposer : [ix.proposer];
  const ixAccountKeys = Object.keys(ix.accounts);
  const uniqueTempIds = [...new Set(payerTempIds.concat(authorizersTempIds, proposerTempIds))];
  for (const ixAccountKey of ixAccountKeys) {
    if (!uniqueTempIds.find(id => id === ixAccountKey)) {
      delete ix.accounts[ixAccountKey];
    }
  }
}
function addAccountToIx(ix, newAccount) {
  if (typeof newAccount.addr === "string" && (typeof newAccount.keyId === "number" || typeof newAccount.keyId === "string")) {
    newAccount.tempId = idof$1(newAccount);
  } else {
    newAccount.tempId = newAccount.tempId || uuid.v4();
  }
  const existingAccount = ix.accounts[newAccount.tempId] || newAccount;
  if (!ix.accounts[newAccount.tempId]) {
    ix.accounts[newAccount.tempId] = newAccount;
  }
  ix.accounts[newAccount.tempId].role.proposer = existingAccount.role.proposer || newAccount.role.proposer;
  ix.accounts[newAccount.tempId].role.payer = existingAccount.role.payer || newAccount.role.payer;
  ix.accounts[newAccount.tempId].role.authorizer = existingAccount.role.authorizer || newAccount.role.authorizer;
  return ix.accounts[newAccount.tempId];
}
function uniqueAccountsFlatMap(accounts) {
  const flatMapped = recurseFlatMap(accounts);
  const seen = new Set();
  const uniqueAccountsFlatMapped = flatMapped.map(account => {
    const accountId = genAccountId(account.tempId, account.role.payer, account.role.proposer, account.role.authorizer, account.role.param);
    if (seen.has(accountId)) return null;
    seen.add(accountId);
    return account;
  }).filter(e => e !== null);
  return uniqueAccountsFlatMapped;
}

// Resolve single account, returns new account tempIds (if they exist)
async function resolveSingleAccount(ix, currentAccountTempId) {
  let depthLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_DEPTH_LIMIT;
  let {
    debugLogger
  } = arguments.length > 3 ? arguments[3] : undefined;
  if (depthLimit <= 0) {
    throw new Error(`recurseResolveAccount Error: Depth limit (${MAX_DEPTH_LIMIT}) reached. Ensure your authorization functions resolve to an account after ${MAX_DEPTH_LIMIT} resolves.`);
  }
  let account = ix.accounts[currentAccountTempId];
  if (!account) return [[], false];
  debugLogger(`account: ${account.tempId}`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
  if (account?.resolve) {
    if (isFn(account?.resolve)) {
      debugLogger(`account: ${account.tempId} -- cache MISS`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
      const {
        resolve,
        ...accountWithoutResolve
      } = account;
      let resolvedAccounts = await resolve(accountWithoutResolve, buildPreSignable(accountWithoutResolve, ix));
      resolvedAccounts = Array.isArray(resolvedAccounts) ? resolvedAccounts : [resolvedAccounts];
      let flatResolvedAccounts = recurseFlatMap(resolvedAccounts);
      flatResolvedAccounts = flatResolvedAccounts.map(flatResolvedAccount => addAccountToIx(ix, flatResolvedAccount));
      account.resolve = flatResolvedAccounts.map(flatResolvedAccount => flatResolvedAccount.tempId);
      account = addAccountToIx(ix, account);
      return [flatResolvedAccounts.map(flatResolvedAccount => flatResolvedAccount.tempId), true];
    } else {
      debugLogger(`account: ${account.tempId} -- cache HIT`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
      return [account.resolve, false];
    }
  }
  return [account.tempId ? [account.tempId] : [], false];
}
const getAccountTempIDs = rawTempIds => {
  if (rawTempIds === null) {
    return [];
  }
  return Array.isArray(rawTempIds) ? rawTempIds : [rawTempIds];
};
async function replaceRoles(ix, oldAccountTempId, newAccounts) {
  // Replace roles in the interaction with any resolved accounts
  // e.g. payer -> [oldAccountTempId, anotherId] => payer -> [newAccountTempId, anotherId]
  for (let role of Object.values(ROLES)) {
    if (role === ROLES.AUTHORIZATIONS || role === ROLES.PAYER) {
      ix[role] = getAccountTempIDs(ix[role]).reduce((acc, acctTempId) => {
        if (acctTempId === oldAccountTempId) {
          return acc.concat(...newAccounts.filter(x => {
            return role === ROLES.PAYER && x.role.payer || role === ROLES.AUTHORIZATIONS && x.role.authorizer;
          }).map(acct => acct.tempId));
        }
        return acc.concat(acctTempId);
      }, []);
    } else if (role === ROLES.PROPOSER) {
      const proposerAccts = newAccounts.filter(x => x.role.proposer);
      if (proposerAccts.length > 1) {
        throw new Error(`replaceRoles Error: Multiple proposer keys were resolved, but only one is allowed`);
      }
      ix[role] = proposerAccts[0]?.tempId ?? ix[role];
    }
  }
}
async function resolveAccountsByIds(ix, accountTempIds) {
  let depthLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_DEPTH_LIMIT;
  let {
    debugLogger
  } = arguments.length > 3 ? arguments[3] : undefined;
  utilInvariant.invariant(ix && typeof ix === "object", "resolveAccountType Error: ix not defined");
  let newTempIds = new Set();
  for (let accountId of accountTempIds) {
    let account = ix.accounts[accountId];
    utilInvariant.invariant(Boolean(account), `resolveAccountType Error: account not found`);
    const [resolvedAccountTempIds, foundNewAccounts] = await resolveSingleAccount(ix, accountId, depthLimit, {
      debugLogger
    });

    // If new accounts were resolved, add them to the set so they can be explored next iteration
    if (foundNewAccounts) {
      const resolvedAccounts = resolvedAccountTempIds.map(resolvedAccountTempId => ix.accounts[resolvedAccountTempId]);
      const flatResolvedAccounts = uniqueAccountsFlatMap(resolvedAccounts);

      // Add new tempIds to the set so they can be used next iteration
      flatResolvedAccounts.forEach(x => newTempIds.add(x.tempId));

      // Update any roles in the interaction based on the new accounts
      replaceRoles(ix, accountId, flatResolvedAccounts);
    }
  }

  // Ensure all payers are of the same account
  let payerAddress;
  for (const payerTempID of ix[ROLES.PAYER]) {
    let pAcct = ix.accounts[payerTempID];
    if (!payerAddress) payerAddress = pAcct.addr;else if (payerAddress !== pAcct.addr) {
      throw new Error("resolveAccountType Error: payers from different accounts detected");
    }
  }
  return newTempIds;
}

/**
 * Resolves account authorization functions and validates account configurations for transactions.
 *
 * @param ix The interaction object containing accounts to resolve
 * @param opts Configuration options for resolution
 * @returns The interaction with resolved accounts
 */
async function resolveAccounts(ix) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (isTransaction(ix)) {
    if (!Array.isArray(ix.payer)) {
      logger.log.deprecate({
        pkg: "FCL",
        subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
        message: "See changelog for more info."
      });
    }
    let [debugLogger, getDebugMessage] = debug$1();
    try {
      // BFS, resolving one level of accounts at a time
      let depthLimit = MAX_DEPTH_LIMIT;
      let frontier = new Set([...getAccountTempIDs(ix[ROLES.PAYER]), ...getAccountTempIDs(ix[ROLES.PROPOSER]), ...getAccountTempIDs(ix[ROLES.AUTHORIZATIONS])]);
      while (frontier.size > 0) {
        if (depthLimit <= 0) {
          throw new Error(`resolveAccounts Error: Depth limit (${MAX_DEPTH_LIMIT}) reached. Ensure your authorization functions resolve to an account after ${MAX_DEPTH_LIMIT} resolves.`);
        }
        frontier = await resolveAccountsByIds(ix, frontier, depthLimit, {
          debugLogger
        });
        depthLimit--;
      }
      await removeUnusedIxAccounts(ix, {
        debugLogger
      });

      // Ensure at least one account for each role is resolved (except for authorizations)
      for (const role of Object.values(ROLES)) {
        utilInvariant.invariant(getAccountTempIDs(ix[role]).length > 0 || role === ROLES.AUTHORIZATIONS, `resolveAccountType Error: no accounts for role "${role}" found`);
      }
      if (opts.enableDebug) {
        console.debug(getDebugMessage());
      }
    } catch (error) {
      console.error("=== SAD PANDA ===\n\n", error, "\n\n=== SAD PANDA ===");
      throw error;
    }
  }
  return ix;
}

/**
 * Resolves signatures for a transaction by coordinating the signing process for inside and outside signers.
 *
 * @param ix The interaction object containing transaction details
 * @returns The interaction object with resolved signatures
 */
async function resolveSignatures(ix) {
  if (isTransaction(ix)) {
    try {
      let insideSigners = findInsideSigners(ix);
      const insidePayload = encodeTransactionPayload(prepForEncoding(ix));

      // Promise.all could potentially break the flow if there are multiple inside signers trying to resolve at the same time
      // causing multiple triggers of authz function that tries to render multiple auth iiframes/tabs/extensions
      // as an alternative, use this:
      // for(const insideSigner of insideSigners) {
      //   await fetchSignature(ix, insidePayload)(insideSigner);
      // }
      await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));
      let outsideSigners = findOutsideSigners(ix);
      const outsidePayload = encodeTransactionEnvelope({
        ...prepForEncoding(ix),
        payloadSigs: insideSigners.map(id => ({
          address: ix.accounts[id].addr || "",
          keyId: ix.accounts[id].keyId || 0,
          sig: ix.accounts[id].signature || ""
        }))
      });

      // Promise.all could potentially break the flow if there are multiple outside signers trying to resolve at the same time
      // causing multiple triggers of authz function that tries to render multiple auth iframes/tabs/extensions
      // as an alternative, use this:
      // for(const outsideSigner of outsideSigners) {
      //   await fetchSignature(ix, outsidePayload)(outsideSigner);
      // }
      await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));
    } catch (error) {
      console.error("Signatures", error, {
        ix
      });
      throw error;
    }
  }
  return ix;
}
function fetchSignature(ix, payload) {
  return async function innerFetchSignature(id) {
    const acct = ix.accounts[id];
    if (acct.signature != null && acct.signature !== undefined) return;
    const {
      signature
    } = await acct.signingFunction(buildSignable(acct, payload, ix));
    ix.accounts[id].signature = signature;
  };
}

/**
 * Builds a signable object that can be signed by an authorization function.
 *
 * @param acct The account to create the signable for
 * @param message The encoded message to be signed
 * @param ix The interaction object containing transaction details
 * @returns A signable object conforming to the FCL signable standard
 */
function buildSignable(acct, message, ix) {
  try {
    return {
      f_type: "Signable",
      f_vsn: "1.0.1",
      message,
      addr: utilAddress.sansPrefix(acct.addr),
      keyId: acct.keyId,
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildSignable", error);
    throw error;
  }
}
function prepForEncoding(ix) {
  const payerAddress = utilAddress.sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr || "");
  const proposalKey = ix.proposer ? {
    address: utilAddress.sansPrefix(ix.accounts[ix.proposer].addr) || "",
    keyId: ix.accounts[ix.proposer].keyId || 0,
    sequenceNum: ix.accounts[ix.proposer].sequenceNum || 0
  } : {};
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
    proposalKey,
    payer: payerAddress,
    authorizers: ix.authorizations.map(cid => utilAddress.sansPrefix(ix.accounts[cid].addr) || "").reduce((prev, current) => {
      return prev.find(item => item === current) ? prev : [...prev, current];
    }, [])
  };
}

/**
 * Executes validator functions that have been attached to an interaction to perform validation checks.
 *
 * @param ix The interaction object containing validators to execute
 * @returns The interaction after running all validators
 */
async function resolveValidators(ix) {
  const validators = get(ix, "ix.validators", []);
  return pipe(ix, validators.map(cb => ix => cb(ix, {
    Ok,
    Bad
  })));
}

/**
 * Normalizes account addresses by removing the "0x" prefix from all account addresses in the interaction.
 *
 * @param ix The interaction object to normalize
 * @returns The interaction with normalized account addresses
 */
async function resolveFinalNormalization(ix) {
  for (let key of Object.keys(ix.accounts)) {
    ix.accounts[key].addr = utilAddress.sansPrefix(ix.accounts[key].addr);
  }
  return ix;
}

/**
 * Resolves voucher intercept functions by calling them with the current voucher.
 *
 * @param ix The interaction object to resolve voucher intercepts for
 * @returns The interaction after voucher intercept processing
 */
async function resolveVoucherIntercept(ix) {
  const fn = get(ix, "ix.voucher-intercept");
  if (isFn$3(fn)) {
    await fn(createSignableVoucher(ix));
  }
  return ix;
}

function createResolveComputeLimit(context) {
  return async function resolveComputeLimit(ix) {
    if (isTransaction(ix)) {
      ix.message.computeLimit = ix.message.computeLimit || context.computeLimit;
    }
    return ix;
  };
}

const noop = v => v;
const debug = function (key) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
  return async ix => {
    const accts = ix => ["\nAccounts:", {
      proposer: ix.proposer,
      authorizations: ix.authorizations,
      payer: ix.payer
    }, "\n\nDetails:", ix.accounts].filter(Boolean);
    const log = function () {
      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
        msg[_key] = arguments[_key];
      }
      console.log(`debug[${key}] ---\n`, ...msg, "\n\n\n---");
    };
    if (await config.config.get(`debug.${key}`)) await fn(ix, log, accts);
    return ix;
  };
};
function createResolve(context) {
  const resolve = async ix => pipe([createResolveCadence(context), debug("cadence", (ix, log) => log(ix.message.cadence)), createResolveComputeLimit(context), debug("compute limit", (ix, log) => log(ix.message.computeLimit)), resolveArguments, debug("arguments", (ix, log) => log(ix.message.arguments, ix.message)), resolveAccounts, debug("accounts", (ix, log, accts) => log(...accts(ix))), /* special */createExecFetchRef(context), /* special */createExecFetchSequenceNumber(context), resolveSignatures, debug("signatures", (ix, log, accts) => log(...accts(ix))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", (ix, log) => log(ix))])(ix);
  return resolve;
}

/**
 * Resolves an interaction by applying a series of resolvers in sequence.
 *
 * This is the main resolver function that takes a built interaction and prepares it
 * for submission to the Flow blockchain by applying all necessary resolvers.
 *
 * The resolve function uses a pipeline approach, applying each resolver in sequence
 * to transform the interaction from its initial built state to a fully resolved state
 * ready for transmission to the Flow Access API.
 *
 * @param interaction The interaction object to resolve
 * @returns A promise that resolves to the fully resolved interaction
 * @example
 * import { resolve, build, script } from "@onflow/sdk"
 *
 * const interaction = await build([
 *   script`
 *     access(all) fun main(): String {
 *       return "Hello, World!"
 *     }
 *   `
 * ])
 *
 * const resolved = await resolve(interaction)
 */
const resolve = /* @__PURE__ */withGlobalContext(createResolve);
function createExecFetchRef(context) {
  return async function execFetchRef(ix) {
    if (isTransaction(ix) && ix.message.refBlock == null) {
      const sendFn = context.transport.send;
      ix.message.refBlock = (await sendFn(build([getBlock()]), {
        response,
        Buffer: rlp.Buffer,
        ix: ixModule
      }, {
        get node() {
          return context.accessNodeUrl;
        }
      }).then(decodeResponse)).id;
    }
    return ix;
  };
}
function createExecFetchSequenceNumber(context) {
  return async function execFetchSequenceNumber(ix) {
    if (isTransaction(ix)) {
      var acct = Object.values(ix.accounts).find(a => a.role.proposer);
      utilInvariant.invariant(acct !== undefined, `Transactions require a proposer`);
      if (acct && acct.sequenceNum == null) {
        const sendFn = context.transport.send;
        ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {
          response,
          Buffer: rlp.Buffer,
          ix: ixModule
        }, {
          get node() {
            return context.accessNodeUrl;
          }
        }).then(decodeResponse).then(acctResponse => acctResponse.keys).then(keys => keys.find(key => key.index === acct.keyId)).then(key => key.sequenceNumber);
      }
    }
    return ix;
  };
}

function createSend(context) {
  async function send() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const transport = opts.transport || context.transport;
    const sendFn = transport.send?.bind?.(transport);
    utilInvariant.invariant(!!sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    const resolveFn = opts.resolve || context.customResolver || createResolve(context);
    opts.node = opts.node || context.accessNodeUrl;
    if (Array.isArray(args)) args = pipe(initInteraction(), args);
    return sendFn(await resolveFn(args), {
      response,
      ix: ixModule,
      Buffer: rlp.Buffer
    }, opts);
  }
  return send;
}

/**
 * Sends arbitrary scripts, transactions, and requests to Flow.
 *
 * This method consumes an array of builders that are to be resolved and sent. The builders required to be included in the array depend on the interaction that is being built.
 *
 * WARNING: Must be used in conjunction with 'fcl.decode(response)' to get back correct keys and all values in JSON.
 *
 * @param args An array of builders (functions that take an interaction object and return a new interaction object)
 * @param opts Additional optional options for the request
 * @param opts.node Custom node endpoint to use for this request
 * @param opts.resolve Custom resolve function to use for processing the interaction
 * @returns A promise that resolves to a ResponseObject containing the data returned from the chain. Should always be decoded with fcl.decode() to get back appropriate JSON keys and values.
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // a script only needs to resolve the arguments to the script
 * const response = await fcl.send([fcl.script`${script}`, fcl.args(args)]);
 * // note: response values are encoded, call await fcl.decode(response) to get JSON
 *
 * // a transaction requires multiple 'builders' that need to be resolved prior to being sent to the chain - such as setting the authorizations.
 * const response = await fcl.send([
 *   fcl.transaction`
 *     ${transaction}
 *   `,
 *   fcl.args(args),
 *   fcl.proposer(proposer),
 *   fcl.authorizations(authorizations),
 *   fcl.payer(payer),
 *   fcl.limit(9999)
 * ]);
 * // note: response contains several values
 */
const send = /* @__PURE__ */withGlobalContext(createSend);

function createSubscribeRawAsync(contextPromise) {
  /**
   * Subscribe to a topic without decoding the data.
   * @param params - The parameters for the subscription.
   * @param opts - Additional options for the subscription.
   * @returns A promise that resolves once the subscription is active.
   */
  function subscribeRaw(_ref) {
    let {
      topic,
      args,
      onData,
      onError
    } = _ref;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    async function subscribe() {
      try {
        const context = await contextPromise;
        const transport = opts.transport || context.transport;
        const node = opts.node || context.accessNodeUrl;
        utilInvariant.invariant(!!node, `SDK Send Error: Either opts.node or "accessNode.api" in config must be defined.`);

        // Subscribe using the resolved transport
        return transport.subscribe({
          topic,
          args,
          onData,
          onError
        }, {
          node,
          ...opts
        });
      } catch (e) {
        onError(e instanceof Error ? e : new Error(String(e)));
        return;
      }
    }
    let subscriptionPromise = subscribe();
    return {
      unsubscribe: () => {
        subscriptionPromise.then(sub => sub?.unsubscribe?.());
      }
    };
  }
  return subscribeRaw;
}
function createSubscribeRaw(context) {
  return createSubscribeRawAsync(context);
}

/**
 * Subscribe to a topic without decoding the data.
 *
 * This function creates a raw subscription to Flow blockchain data streams without automatic decoding.
 * It's useful when you need more control over data processing or want to handle raw responses directly.
 * For most use cases, consider using the `subscribe()` function instead which provides automatic decoding.
 *
 * Available topics include: `events`, `blocks`, `block_headers`, `block_digests`, `transaction_statuses`, `account_statuses`.
 *
 * @param params The parameters for the subscription including topic, arguments, and callbacks
 * @param params.topic The subscription topic (e.g., 'events', 'blocks', 'transaction_statuses')
 * @param params.args Parameters specific to the topic (e.g., event types, block height, transaction ID)
 * @param params.onData Callback function called with raw data when new messages are received
 * @param params.onError Callback function called if an error occurs during the subscription
 * @param opts Additional options for the subscription
 * @param opts.node Custom node endpoint to be used for the subscription
 * @param opts.transport Custom transport implementation for handling the connection
 * @returns A subscription object with an unsubscribe method
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { SubscriptionTopic } from "@onflow/sdk";
 *
 * // Subscribe to raw event data without automatic decoding
 * const rawSubscription = fcl.subscribeRaw({
 *   topic: SubscriptionTopic.EVENTS,
 *   args: {
 *     eventTypes: ["A.7e60df042a9c0868.FlowToken.TokensWithdrawn"]
 *   },
 *   onData: (rawData) => {
 *     console.log("Raw event data:", rawData);
 *     // Handle raw data manually - no automatic decoding
 *   },
 *   onError: (error) => {
 *     console.error("Raw subscription error:", error);
 *   }
 * });
 *
 * // Subscribe to raw block data
 * const blockSubscription = fcl.subscribeRaw({
 *   topic: SubscriptionTopic.BLOCKS,
 *   args: {
 *     blockStatus: "finalized"
 *   },
 *   onData: (rawBlock) => {
 *     console.log("Raw block data:", rawBlock);
 *   },
 *   onError: (error) => {
 *     console.error("Error:", error);
 *   }
 * });
 *
 * // Unsubscribe when done
 * rawSubscription.unsubscribe();
 */
function subscribeRaw(_ref2) {
  let {
    topic,
    args,
    onData,
    onError
  } = _ref2;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const contextPromise = getGlobalContext();
  return createSubscribeRawAsync(contextPromise)({
    topic,
    args,
    onData,
    onError
  }, opts);
}

function createSubscribeAsync(contextPromise) {
  /**
   * Subscribe to a topic and decode the data.
   * @param params - The parameters for the subscription.
   * @param opts - Additional options for the subscription.
   * @returns A promise that resolves when the subscription is active.
   */
  function subscribe(_ref) {
    let {
      topic,
      args,
      onData,
      onError
    } = _ref;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const sub = createSubscribeRawAsync(contextPromise)({
      topic,
      args,
      onData: data => {
        decodeResponse(data).then(onData).catch(e => {
          onError(new Error(`Failed to decode response: ${e.message}`));
          sub?.unsubscribe?.();
        });
      },
      onError
    }, opts);
    return sub;
  }
  return subscribe;
}
function createSubscribe(context) {
  return createSubscribeAsync(context);
}

/**
 * Subscribe to real-time data from the Flow blockchain and automatically decode the responses.
 *
 * This is a utility function used for subscribing to real-time data from the WebSocket Streaming API. Data returned will be automatically decoded via the 'decode' function.
 *
 * Available topics include: `events`, `blocks`, `block_headers`, `block_digests`, `transaction_statuses`, `account_statuses`.
 *
 * @param params The parameters for the subscription including topic, arguments, and callbacks
 * @param params.topic The subscription topic (e.g., 'events', 'blocks', 'transaction_statuses')
 * @param params.args Parameters specific to the topic (e.g., event types, block height, transaction ID)
 * @param params.onData Callback function called with decoded data when new messages are received
 * @param params.onError Callback function called if an error occurs during the subscription
 * @param opts Additional options for the subscription
 * @param opts.node Custom node endpoint to be used for the subscription
 * @param opts.transport Custom transport implementation for handling the connection
 * @returns A subscription object that allows you to manage the subscription (e.g., to unsubscribe later)
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { SubscriptionTopic } from "@onflow/sdk";
 *
 * // Subscribe to events
 * const subscription = fcl.subscribe({
 *   topic: SubscriptionTopic.EVENTS,
 *   args: {
 *     eventTypes: ["A.7e60df042a9c0868.FlowToken.TokensWithdrawn"]
 *   },
 *   onData: (events) => {
 *     console.log("Received events:", events);
 *   },
 *   onError: (error) => {
 *     console.error("Subscription error:", error);
 *   }
 * });
 *
 * // Subscribe to blocks
 * const blockSubscription = fcl.subscribe({
 *   topic: SubscriptionTopic.BLOCKS,
 *   args: {
 *     blockStatus: "finalized"
 *   },
 *   onData: (block) => {
 *     console.log("New block:", block);
 *   },
 *   onError: (error) => {
 *     console.error("Block subscription error:", error);
 *   }
 * });
 *
 * // Later, to unsubscribe:
 * subscription.unsubscribe();
 * blockSubscription.unsubscribe();
 */
function subscribe(_ref2) {
  let {
    topic,
    args,
    onData,
    onError
  } = _ref2;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const contextPromise = getGlobalContext();
  const sub = createSubscribeRawAsync(contextPromise)({
    topic,
    args,
    onData: data => {
      decodeResponse(data).then(onData).catch(e => {
        onError(new Error(`Failed to decode response: ${e.message}`));
        sub?.unsubscribe?.();
      });
    },
    onError
  }, opts);
  return sub;
}

function createDecode(context) {
  async function decode(response) {
    return decodeResponse(response, context.customDecoders);
  }
  return decode;
}

/**
 * Decodes the response from 'fcl.send()' into the appropriate JSON representation of any values returned from Cadence code.
 *
 * The response from Flow contains encoded values that need to be decoded into JavaScript types. This function handles that conversion, including complex types like structs, arrays, and dictionaries.
 *
 * @param response Should be the response returned from 'fcl.send([...])'
 * @returns A JSON representation of the raw string response depending on the cadence code executed. The return value can be a single value and type or an object with multiple types.
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Simple script to add 2 numbers
 * const response = await fcl.send([
 *   fcl.script`
 *     access(all) fun main(int1: Int, int2: Int): Int {
 *       return int1 + int2
 *     }
 *   `,
 *   fcl.args([fcl.arg(1, fcl.t.Int), fcl.arg(2, fcl.t.Int)])
 * ]);
 *
 * const decoded = await fcl.decode(response);
 * console.log(decoded); // 3
 * console.log(typeof decoded); // "number"
 *
 * // Complex return types
 * const complexResponse = await fcl.send([
 *   fcl.script`
 *     access(all) fun main(): {String: Int} {
 *       return {"foo": 1, "bar": 2}
 *     }
 *   `
 * ]);
 *
 * const complexDecoded = await fcl.decode(complexResponse);
 * console.log(complexDecoded); // {foo: 1, bar: 2}
 */
const decode = /* @__PURE__ */withGlobalContext(createDecode);

const findPayloadSigners = voucher => {
  // Payload Signers Are: (authorizers + proposer) - payer
  const payload = new Set(voucher.authorizers);
  payload.add(voucher.proposalKey.address);
  payload.delete(voucher.payer);
  return Array.from(payload).map(addr => utilAddress.withPrefix(addr));
};
const findEnvelopeSigners = voucher => {
  // Envelope Signers Are: (payer)
  const envelope = new Set([voucher.payer]);
  return Array.from(envelope).map(addr => utilAddress.withPrefix(addr));
};
class UnableToDetermineMessageEncodingTypeForSignerAddress extends Error {
  constructor(signerAddress) {
    const msg = `
        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. 
        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.
      `.trim();
    super(msg);
    this.name = "Unable To Determine Message Encoding For Signer Addresss";
  }
}

/**
 * Encodes a message from a signable object for a specific signer address.
 *
 * This function determines whether the signer should sign the transaction payload or envelope
 * based on their role in the transaction (authorizer, proposer, or payer), then encodes the
 * appropriate message for signing.
 *
 * Payload signers include authorizers and proposers (but not payers)
 * Envelope signers include only payers
 *
 * The encoded message is what gets signed by the account's private key to create the transaction signature.
 *
 * @param signable The signable object containing transaction data and voucher
 * @param signerAddress The address of the signer to encode the message for
 * @returns An encoded message string suitable for signing with the account's private key
 *
 * @throws {UnableToDetermineMessageEncodingTypeForSignerAddress} When the signer address is not found in authorizers, proposer, or payer roles
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // This function is typically used internally by authorization functions
 * // when implementing custom wallet connectors or signing flows
 *
 * const signable = {
 *   voucher: {
 *     cadence: "transaction { prepare(acct: AuthAccount) {} }",
 *     authorizers: ["0x01"],
 *     proposalKey: { address: "0x01", keyId: 0, sequenceNum: 42 },
 *     payer: "0x02",
 *     refBlock: "a1b2c3",
 *     computeLimit: 100,
 *     arguments: [],
 *     payloadSigs: []
 *   }
 * };
 *
 * // For an authorizer (payload signer)
 * const authorizerMessage = fcl.encodeMessageFromSignable(signable, "0x01");
 * console.log("Authorizer signs:", authorizerMessage);
 *
 * // For a payer (envelope signer)
 * const payerMessage = fcl.encodeMessageFromSignable(signable, "0x02");
 * console.log("Payer signs:", payerMessage);
 */
const encodeMessageFromSignable = (signable, signerAddress) => {
  let payloadSigners = findPayloadSigners(signable.voucher);
  let envelopeSigners = findEnvelopeSigners(signable.voucher);
  const isPayloadSigner = payloadSigners.includes(utilAddress.withPrefix(signerAddress));
  const isEnvelopeSigner = envelopeSigners.includes(utilAddress.withPrefix(signerAddress));
  if (!isPayloadSigner && !isEnvelopeSigner) {
    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
  }
  const message = {
    cadence: signable.voucher.cadence,
    refBlock: signable.voucher.refBlock,
    computeLimit: signable.voucher.computeLimit,
    arguments: signable.voucher.arguments,
    proposalKey: {
      ...signable.voucher.proposalKey,
      address: utilAddress.sansPrefix(signable.voucher.proposalKey.address)
    },
    payer: utilAddress.sansPrefix(signable.voucher.payer),
    authorizers: signable.voucher.authorizers.map(utilAddress.sansPrefix),
    payloadSigs: signable.voucher.payloadSigs.map(ps => ({
      ...ps,
      address: utilAddress.sansPrefix(ps.address)
    }))
  };
  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
};

/**
 * A builder function that adds a validator to a transaction.
 *
 * Validators are functions that run during transaction building to check for invalid configurations or parameters.
 * They help catch errors early before submitting transactions to the network, preventing failed transactions
 * and wasted compute costs.
 *
 * @param cb The validator function that takes an interaction and returns it (or throws an error if invalid)
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Custom validator to ensure account has sufficient balance
 * const validateBalance = (ix) => {
 *   if (ix.message.computeLimit > 1000) {
 *     throw new Error("Compute limit too high for this account");
 *   }
 *   return ix;
 * };
 *
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         // Transaction logic
 *       }
 *     }
 *   `,
 *   fcl.validator(validateBalance),
 *   fcl.limit(500) // This will pass validation
 * ]);
 */
function validator(cb) {
  return update("ix.validators", validators => Array.isArray(validators) ? [...validators, cb] : [cb]);
}

/**
 * A builder function that returns a partial interaction to a block at a specific height.
 *
 * Use with other interactions like 'fcl.getBlock()' to get a full interaction at the specified block height.
 *
 * Block height expresses the height of the block on the chain. The latest block height increases by one for every valid block produced.
 *
 * @param height The height of the block to execute the interaction at
 * @returns A partial interaction to be paired with another interaction such as 'fcl.getBlock()' or 'fcl.getAccount()'
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get block at specific height
 * await fcl.send([fcl.getBlock(), fcl.atBlockHeight(123)]).then(fcl.decode);
 *
 * // Get account at specific block height
 * await fcl.send([
 *   fcl.getAccount("0x1d007d755706c469"),
 *   fcl.atBlockHeight(12345)
 * ]).then(fcl.decode);
 *
 * // Execute script at specific block height
 * await fcl.send([
 *   fcl.script`
 *     access(all) fun main(): UFix64 {
 *       return getCurrentBlock().height
 *     }
 *   `,
 *   fcl.atBlockHeight(100)
 * ]).then(fcl.decode);
 */
function atBlockHeight(height) {
  return pipe([ix => {
    ix.block.height = height;
    return ix;
  }, validator(ix => {
    if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
    if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
    return ix;
  })]);
}

/**
 * A builder function that returns a partial interaction to a block at a specific block ID.
 *
 * Use with other interactions like 'fcl.getBlock()' to get a full interaction at the specified block ID.
 *
 * Block ID is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from 'GetLatestBlock').
 *
 * @param id The ID of the block to execute the interaction at
 * @returns A partial interaction to be paired with another interaction such as 'fcl.getBlock()' or 'fcl.getAccount()'
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get block by ID
 * await fcl.send([fcl.getBlock(), fcl.atBlockId("23232323232")]).then(fcl.decode);
 *
 * // Get account at specific block ID
 * await fcl.send([
 *   fcl.getAccount("0x1d007d755706c469"),
 *   fcl.atBlockId("9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3")
 * ]).then(fcl.decode);
 *
 * // Execute script at specific block
 * await fcl.send([
 *   fcl.script`
 *     access(all) fun main(): UFix64 {
 *       return getCurrentBlock().timestamp
 *     }
 *   `,
 *   fcl.atBlockId("a1b2c3d4e5f6")
 * ]).then(fcl.decode);
 */
function atBlockId(id) {
  return pipe([ix => {
    ix.block.id = id;
    return Ok(ix);
  }, validator((ix, _ref) => {
    let {
      Ok,
      Bad
    } = _ref;
    if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
    if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
    if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
    return Ok(ix);
  })]);
}

/**
 * A builder function that returns a partial interaction to query the latest block with the given finality state.
 *
 * Use with other interactions like 'fcl.getBlock()' to get the latest block information.
 * Block finality determines whether you get the latest executed block or the latest sealed block.
 *
 * - Executed blocks (soft-finality): Latest block that has been executed but may not be final
 * - Sealed blocks (hard-finality): Latest block that has been sealed and is considered final
 *
 * @param isSealed Block finality state, defaults to latest executed block ("soft-finality"), set to true for sealed blocks ("hard-finality")
 * @returns A function that processes a partial interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get latest executed block (soft finality)
 * await fcl.send([fcl.getBlock(), fcl.atLatestBlock()]).then(fcl.decode);
 *
 * // Get latest sealed block (hard finality)
 * await fcl.send([fcl.getBlock(), fcl.atLatestBlock(true)]).then(fcl.decode);
 *
 * // Get account from latest sealed block
 * await fcl.send([
 *   fcl.getAccount("0x1d007d755706c469"),
 *   fcl.atLatestBlock(true)
 * ]).then(fcl.decode);
 *
 * // Execute script against latest executed block
 * await fcl.send([
 *   fcl.script`
 *     access(all) fun main(): UFix64 {
 *       return getCurrentBlock().height
 *     }
 *   `,
 *   fcl.atLatestBlock()
 * ]).then(fcl.decode);
 */
function atLatestBlock() {
  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return pipe([ix => {
    ix.block.isSealed = isSealed;
    return ix;
  }, validator(ix => {
    if (ix.block.id) throw new Error("Unable to specify both block finality and block id.");
    if (ix.block.height) throw new Error("Unable to specify both block finality and block height.");
    return ix;
  })]);
}

function createAccount(context) {
  async function account(address) {
    let {
      height,
      id,
      isSealed
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 ? arguments[2] : undefined;
    utilInvariant.invariant(!(id && height || id && isSealed || height && isSealed), `Method: account -- Only one of the following parameters can be provided: id, height, isSealed`);

    // Get account by ID
    if (id) return await createSend(context)([getAccount(address), atBlockId(id)], opts).then(decodeResponse);

    // Get account by height
    if (height) return await createSend(context)([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);

    // Get account by latest block
    return await createSend(context)([getAccount(address), atLatestBlock(isSealed ?? false)], opts).then(decodeResponse);
  }
  return account;
}

/**
 * Retrieve any account from Flow network's latest block or from a specified block height.
 *
 * Account address is a unique account identifier. Be mindful about the '0x' prefix, you should use the prefix as a default representation but be careful and safely handle user inputs without the prefix.
 *
 * An account includes the following data:
 * - Address: the account address.
 * - Balance: balance of the account.
 * - Contracts: list of contracts deployed to the account.
 * - Keys: list of keys associated with the account.
 *
 * @param address Address of the account
 * @param queryOptions Query parameters
 * @param queryOptions.height Block height to query
 * @param queryOptions.id Block ID to query
 * @param queryOptions.isSealed Block finality
 * @param opts Optional parameters
 * @returns A promise that resolves to an Account object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get account from latest block height
 * const account = await fcl.account("0x1d007d755706c469");
 * console.log("Address:", account.address);
 * console.log("Balance:", account.balance);
 * console.log("Keys:", account.keys);
 * console.log("Contracts:", Object.keys(account.contracts));
 *
 * // Get account at a specific block height
 * const historicalAccount = await fcl.account("0x1d007d755706c469", {
 *   height: 12345
 * });
 *
 * // Get account at a specific block ID
 * const accountAtBlock = await fcl.account("0x1d007d755706c469", {
 *   id: "9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3"
 * });
 *
 * // Get account from sealed block
 * const sealedAccount = await fcl.account("0x1d007d755706c469", {
 *   isSealed: true
 * });
 *
 * // Alternative using builder pattern
 * fcl.send([
 *   fcl.getAccount("0x1d007d755706c469"),
 *   fcl.atBlockHeight(123)
 * ]).then(fcl.decode);
 */
const account = /* @__PURE__ */withGlobalContext(createAccount);

function createBlock(context) {
  async function block() {
    let {
      sealed = false,
      id,
      height
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    utilInvariant.invariant(!(sealed && id || sealed && height), `Method: block -- Cannot pass "sealed" with "id" or "height"`);
    utilInvariant.invariant(!(id && height), `Method: block -- Cannot pass "id" and "height" simultaneously`);

    // Get block by ID
    if (id) return await createSend(context)([getBlock(), atBlockId(id)], opts).then(decodeResponse);

    // Get block by height
    if (height) return await createSend(context)([getBlock(), atBlockHeight(height)], opts).then(decodeResponse);

    // Get latest block
    return await createSend(context)([getBlock(sealed)], opts).then(decodeResponse);
  }
  return block;
}

/**
 * Query the network for block by id, height or get the latest block.
 *
 * Block ID is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from `GetLatestBlock`).
 *
 * Block height expresses the height of the block on the chain. The latest block height increases by one for every valid block produced.
 *
 * @param queryOptions Query parameters
 * @param queryOptions.sealed Whether to query for a sealed block
 * @param queryOptions.height Block height to query
 * @param queryOptions.id Block ID to query
 * @param opts Optional parameters
 * @returns A promise that resolves to a Block object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get latest block
 * const latestBlock = await fcl.block(); // Get the latest finalized block
 * const latestSealedBlock = await fcl.block({sealed: true}); // Get the latest sealed block
 *
 * // Get block by ID (uses builder function)
 * await fcl.send([fcl.getBlock(), fcl.atBlockId("23232323232")]).then(fcl.decode);
 *
 * // Get block at height (uses builder function)
 * await fcl.send([fcl.getBlock(), fcl.atBlockHeight(123)]).then(fcl.decode)
 */
const block = /* @__PURE__ */withGlobalContext(createBlock);

/**
 * A builder function for the Get Node Version Info interaction.
 *
 * Creates an interaction to retrieve version information from the connected Flow Access Node.
 * This includes details about the node's software version, protocol version, and spork information.
 *
 * Consider using the pre-built interaction 'fcl.nodeVersionInfo()' if you do not need to pair with any other builders.
 *
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get node version information using builder
 * const versionInfo = await fcl.send([
 *   fcl.getNodeVersionInfo()
 * ]).then(fcl.decode);
 *
 * console.log("Node version:", versionInfo.semver);
 * console.log("Protocol version:", versionInfo.protocol_version);
 * console.log("Spork ID:", versionInfo.spork_id);
 *
 * // Use with other builders if needed
 * const interaction = await fcl.build([
 *   fcl.getNodeVersionInfo()
 *   // other builders can be added here
 * ]);
 */
function getNodeVersionInfo() {
  return pipe([makeGetNodeVerionInfo, ix => {
    return Ok(ix);
  }]);
}

/**
 * Retrieve version information from the connected Flow Access Node.
 *
 * This function returns detailed information about the Flow node's version, including the protocol version, spork information, and node-specific details. This is useful for debugging, compatibility checks, and understanding the network state.
 *
 * @param opts Optional parameters for the request
 * @returns A promise that resolves to a block response
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get node version information
 * const versionInfo = await fcl.nodeVersionInfo();
 * console.log(versionInfo);
 * // {
 * //   semver: "v0.37.13",
 * //   commit: "12345abcd",
 * //   spork_id: "mainnet-23",
 * //   protocol_version: "2.13.10",
 * //   spork_root_block_height: "88483760",
 * //   node_root_block_height: "88483760"
 * // }
 *
 * // Check compatibility
 * const info = await fcl.nodeVersionInfo();
 * if (info.protocol_version.startsWith("2.13")) {
 *   console.log("Compatible with current protocol version");
 * }
 */
async function nodeVersionInfo() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return await send([getNodeVersionInfo()], opts).then(decodeResponse);
}

/**
 * An object that contains all the information needed for FCL to sign a message with the user's signature.
 * Note: These values are destructed from the payload object in the first argument of a signing function.
 */

/**
 * The object that contains all the information needed by FCL to authorize a user's transaction.
 */

/**
 * A signing function consumes a payload and produces a signature for a transaction.
 * This function is always async.
 * Only write your own signing function if you are writing your own custom authorization function.
 */

/**
 * A utility builder to set the authorizations on a transaction.
 *
 * Authorizations define the accounts that are responsible for paying the transaction fees and providing signatures for the transaction.
 * You can have multiple authorizers in a single transaction (multi-signature transactions).
 *
 * Read more about [transaction roles](https://docs.onflow.org/concepts/transaction-signing/) and [signing transactions](https://docs.onflow.org/concepts/accounts-and-keys/).
 *
 * @param ax An array of authorization functions that produce account authorization details
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Single authorizer (most common case)
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(acct: AuthAccount) {
 *         log("Hello from: ".concat(acct.address.toString()))
 *       }
 *     }
 *   `,
 *   authorizations: [fcl.authz] // Current user authorization
 * });
 *
 * // Multiple authorizers - both accounts must approve
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(acct1: AuthAccount, acct2: AuthAccount) {
 *         log("Transaction signed by both accounts")
 *       }
 *     }
 *   `,
 *   authorizations: [userOneAuthz, userTwoAuthz]
 * });
 *
 * // Using builder pattern
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(acct: AuthAccount) {
 *         acct.save("Hello, World!", to: /storage/greeting)
 *       }
 *     }
 *   `,
 *   fcl.authorizations([fcl.authz]),
 *   fcl.proposer(fcl.authz),
 *   fcl.payer(fcl.authz),
 *   fcl.limit(100)
 * ]);
 */
function authorizations() {
  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(ax.map(authz => {
    return prepAccount(authz, {
      role: typedefs.TransactionRole.AUTHORIZER
    });
  }));
}

/**
 * Creates an authorization function for use in transactions.
 *
 * An authorization function must produce the information of the user that is going to sign and a signing function to use the information to produce a signature.
 *
 * Read more about [authorization functions](https://docs.onflow.org/fcl/reference/authorization-function/) and [transaction roles](https://docs.onflow.org/concepts/transaction-signing/).
 *
 * @param addr The address of the account that will sign the transaction
 * @param signingFunction A function that produces signatures for the account
 * @param keyId The index of the key to use for signing (optional)
 * @param sequenceNum The sequence number for the account key (optional)
 * @returns A partial interaction account object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { ec as EC } from "elliptic";
 *
 * // Create a signing function
 * const signingFunction = ({ message }) => {
 *   // Your signing logic here
 *   return {
 *     addr: "0x123456789abcdef0",
 *     keyId: 0,
 *     signature: "your_signature_here"
 *   };
 * };
 *
 * // Create authorization
 * const authz = fcl.authorization(
 *   "0x123456789abcdef0", // account address
 *   signingFunction,     // signing function
 *   0,                   // key ID
 *   42                   // sequence number
 * );
 *
 * // Use in transaction
 * await fcl.mutate({
 *   cadence: `transaction { prepare(acct: AuthAccount) {} }`,
 *   proposer: authz,
 *   payer: authz,
 *   authorizations: [authz]
 * });
 */
function authorization(addr, signingFunction, keyId, sequenceNum) {
  return {
    addr,
    signingFunction,
    keyId,
    sequenceNum
  };
}

/**
 * A builder function that returns the interaction to get events.
 *
 * Events are emitted by Cadence code during transaction execution and provide insights into what happened during execution.
 * This function queries for events of a specific type within a range of block heights.
 *
 * @param eventType The type of event to get (e.g., "A.1654653399040a61.FlowToken.TokensWithdrawn")
 * @param start The start block height to query from
 * @param end The end block height to query to
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get FlowToken transfer events from blocks 1000 to 2000
 * const events = await fcl.send([
 *   fcl.getEvents("A.1654653399040a61.FlowToken.TokensDeposited", 1000, 2000)
 * ]).then(fcl.decode);
 *
 * console.log("Found events:", events.length);
 * events.forEach(event => {
 *   console.log("Event data:", event.data);
 *   console.log("Transaction ID:", event.transactionId);
 * });
 */
function getEvents(eventType, start, end) {
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns all instances of a particular event (by name) within a height range.
 *
 * The block range provided must be from the current spork.
 *
 * The block range provided must be 250 blocks or lower per request.
 *
 * Event type is a string that follow a standard format: A.{AccountAddress}.{ContractName}.{EventName}
 *
 * Please read more about [events in the documentation](https://docs.onflow.org/cadence/language/events/).
 *
 * Block height range expresses the height of the start and end block in the chain.
 *
 * @param eventType The type of event to get
 * @param startHeight The height of the block to start looking for events (inclusive)
 * @param endHeight The height of the block to stop looking for events (inclusive)
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get events at block height range
 * await fcl
 *   .send([
 *     fcl.getEventsAtBlockHeightRange(
 *       "A.7e60df042a9c0868.FlowToken.TokensWithdrawn", // event name
 *       35580624, // block to start looking for events at
 *       35580624 // block to stop looking for events at
 *     ),
 *   ])
 *   .then(fcl.decode);
 */
function getEventsAtBlockHeightRange(eventType, startHeight, endHeight) {
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.start = startHeight;
    ix.events.end = endHeight;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns all instances of a particular event (by name) within a set of blocks, specified by block ids.
 *
 * The block range provided must be from the current spork.
 *
 * Event type is a string that follow a standard format: A.{AccountAddress}.{ContractName}.{EventName}
 *
 * Please read more about [events in the documentation](https://docs.onflow.org/cadence/language/events/).
 *
 * @param eventType The type of event to get
 * @param blockIds The ids of the blocks to scan for events
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * const events = await fcl.send([
 *   fcl.getEventsAtBlockIds("A.7e60df042a9c0868.FlowToken.TokensWithdrawn", [
 *     "c4f239d49e96d1e5fbcf1f31027a6e582e8c03fcd9954177b7723fdb03d938c7",
 *     "5dbaa85922eb194a3dc463c946cc01c866f2ff2b88f3e59e21c0d8d00113273f"
 *   ])
 * ]).then(fcl.decode);
 */
function getEventsAtBlockIds(eventType, blockIds) {
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.blockIds = blockIds;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns the interaction to get a block header.
 *
 * A block header contains metadata about a block without the full transaction details, making it more
 * lightweight than fetching the entire block. This is useful when you only need block metadata like
 * timestamp, height, parent hash, etc.
 *
 * Use with 'fcl.atBlockId()' and 'fcl.atBlockHeight()' when building the interaction to get headers for specific blocks.
 *
 * @param isSealed Block finality state, true for sealed blocks, false for finalized blocks, null for latest
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get latest sealed block header
 * const sealedHeader = await fcl.send([
 *   fcl.getBlockHeader(true)
 * ]).then(fcl.decode);
 *
 * console.log("Block height:", sealedHeader.height);
 * console.log("Block timestamp:", sealedHeader.timestamp);
 * console.log("Parent block ID:", sealedHeader.parentId);
 *
 * // Get header for specific block
 * const blockHeader = await fcl.send([
 *   fcl.getBlockHeader(),
 *   fcl.atBlockHeight(12345)
 * ]).then(fcl.decode);
 *
 * // Get latest finalized block header
 * const finalizedHeader = await fcl.send([
 *   fcl.getBlockHeader(false)
 * ]).then(fcl.decode);
 */
function getBlockHeader() {
  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetBlockHeader, ix => {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns a collection containing a list of transaction IDs by its collection ID.
 *
 * A collection is a batch of transactions that have been included in a block. Each collection has a unique ID
 * which is the SHA3-256 hash of the collection payload. Collections are used to group related transactions
 * together for more efficient processing by the network.
 *
 * The collection ID provided must be from the current spork. Collections from past sporks are currently unavailable.
 *
 * @param collectionID The ID of the collection to retrieve
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get a collection and see what transactions it contains
 * const collection = await fcl.send([
 *   fcl.getCollection("cccdb0c67d015dc7f6444e8f62a3244ed650215ed66b90603006c70c5ef1f6e5")
 * ]).then(fcl.decode);
 *
 * console.log("Collection ID:", collection.id);
 * console.log("Transaction IDs:", collection.transactionIds);
 * console.log("Total transactions:", collection.transactionIds.length);
 *
 * // Process each transaction in the collection
 * for (const txId of collection.transactionIds) {
 *   const transaction = await fcl.send([
 *     fcl.getTransaction(txId)
 *   ]).then(fcl.decode);
 *   console.log("Transaction:", transaction);
 * }
 */
function getCollection() {
  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetCollection, ix => {
    ix.collection.id = id;
    return ix;
  }]);
}

/**
 * A builder function that returns the status of transaction.
 *
 * The transaction id provided must be from the current spork.
 *
 * Consider using 'fcl.tx(id)' instead of calling this method directly for real-time transaction monitoring.
 *
 * @param transactionId The id of the transaction to get the status of
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * const status = await fcl.send([
 *   fcl.getTransactionStatus("9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3")
 * ]).then(fcl.decode);
 */
function getTransactionStatus(transactionId) {
  return pipe([makeGetTransactionStatus, ix => {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns the interaction to get a transaction by id.
 *
 * Transaction id is a hash of the encoded transaction payload and can be calculated before submitting the transaction to the network.
 * Transaction status represents the state of a transaction in the blockchain. Status can change until it is finalized.
 *
 * The transaction id provided must be from the current spork.
 *
 * Consider using 'fcl.tx(id).onceExecuted()' instead of calling this method directly for real-time transaction monitoring.
 *
 * @param transactionId The id of the transaction to get
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * const tx = await fcl.send([
 *   fcl.getTransaction("9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3")
 * ]).then(fcl.decode);
 */
function getTransaction(id) {
  return pipe([makeGetTransaction, ix => {
    ix.transaction.id = id;
    return Ok(ix);
  }]);
}

/**
 * A builder function that returns the interaction to get network parameters.
 *
 * Network parameters contain important configuration information about the Flow network,
 * including the chain ID, which is essential for signing transactions correctly.
 * This information is crucial for ensuring transactions are submitted to the correct network.
 *
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Get network parameters to verify chain ID
 * const params = await fcl.send([
 *   fcl.getNetworkParameters()
 * ]).then(fcl.decode);
 *
 * console.log("Chain ID:", params.chainId);
 * console.log("Network:", params.name);
 *
 * // Use this to verify you're connected to the right network
 * if (params.chainId === "flow-mainnet") {
 *   console.log("Connected to Flow Mainnet");
 * } else if (params.chainId === "flow-testnet") {
 *   console.log("Connected to Flow Testnet");
 * }
 */
function getNetworkParameters() {
  return pipe([makeGetNetworkParameters, ix => {
    return Ok(ix);
  }]);
}

/**
 * A utility builder to set the compute limit on a transaction.
 *
 * The compute limit is the maximum amount of computation that can be performed during transaction execution.
 * Setting an appropriate compute limit helps prevent infinite loops and ensures predictable transaction costs.
 *
 * Read more about [computation cost](https://docs.onflow.org/concepts/fees/#computation-cost) and [transaction fees](https://docs.onflow.org/concepts/fees/).
 *
 * @param limit The maximum amount of computation for the transaction
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         // Complex transaction logic here
 *       }
 *     }
 *   `,
 *   limit: 1000 // Set compute limit to 1000
 * });
 *
 * // Using builder pattern
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         // Transaction logic
 *       }
 *     }
 *   `,
 *   fcl.limit(9999) // Set higher limit for complex operations
 * ]);
 */
function limit(limit) {
  return ix => {
    ix.message.computeLimit = limit;
    return ix;
  };
}

/**
 * A utility builder to be used with other builders to pass in arguments with a value and supported type.
 *
 * A transaction can accept zero or more arguments that are passed into the Cadence script. The arguments on the transaction must match the number and order declared in the Cadence script.
 * This function returns a Partial Interaction that contains the arguments and types passed in. This alone is a partial and incomplete interaction.
 *
 * @param ax An array of argument objects created with fcl.arg()
 * @returns A Partial Interaction object containing the arguments and types passed in
 *
 * @example
 * import * as fcl from "@onflow/fcl"
 *
 * await fcl.mutate({
 *   cadence: `
 *     transaction(amount: UFix64, to: Address) {
 *       prepare(signer: AuthAccount) {
 *         // transaction logic
 *       }
 *     }
 *   `,
 *   args: (arg, t) => [
 *     arg("10.0", t.UFix64), // Will be the first argument `amount: UFix64`
 *     arg("0xba1132bc08f82fe2", t.Address), // Will be the second argument `to: Address`
 *   ],
 * })
 */
function args(ax) {
  return pipe(ax.map(makeArgument));
}

/**
 * A utility builder to be used with fcl.args[...] to create FCL supported arguments for interactions.
 *
 * Arguments are used to pass data to Cadence scripts and transactions. The arguments must match the number and order declared in the Cadence script.
 * This function creates an ArgumentObject that holds the value and type passed in.
 *
 * @param value Any value that you are looking to pass to other builders
 * @param xform A type supported by Flow (FType descriptor)
 * @returns An ArgumentObject that holds the value and type passed in
 *
 * @example
 * import * as fcl from "@onflow/fcl"
 *
 * const result = await fcl.query({
 *   cadence: `
 *     access(all) fun main(a: Int, b: Int, addr: Address): Int {
 *       log(addr)
 *       return a + b
 *     }
 *   `,
 *   args: (arg, t) => [
 *     arg(7, t.Int), // a: Int
 *     arg(6, t.Int), // b: Int
 *     arg("0xba1132bc08f82fe2", t.Address), // addr: Address
 *   ],
 * });
 */
function arg(value, xform) {
  return {
    value,
    xform
  };
}

/**
 * A builder function that adds the proposer to a transaction.
 *
 * The proposer is responsible for providing the proposal key and paying the network fee for the transaction.
 * The proposer key is used to specify the sequence number and prevent replay attacks.
 *
 * Every transaction requires exactly one proposer.
 *
 * Read more about [transaction roles](https://docs.onflow.org/concepts/transaction-signing/#proposer) and [signing transactions](https://docs.onflow.org/concepts/accounts-and-keys/).
 *
 * @param authz The authorization object for the proposer
 * @returns A function that takes an interaction object and returns a new interaction object with the proposer added
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Using the current user as proposer
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Hello from proposer!")
 *       }
 *     }
 *   `,
 *   proposer: fcl.authz
 * });
 *
 * // Using builder pattern
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Transaction executed")
 *       }
 *     }
 *   `,
 *   fcl.proposer(proposerAuthz),
 *   fcl.payer(payerAuthz),
 *   fcl.authorizations([authorizerAuthz]),
 *   fcl.limit(100)
 * ]);
 */
function proposer(authz) {
  return prepAccount(authz, {
    role: typedefs.TransactionRole.PROPOSER
  });
}

/**
 * A builder function that adds payer account(s) to a transaction.
 *
 * Every transaction requires at least one payer.
 *
 * The payer is the account that pays the transaction fee for executing the transaction on the network.
 * The payer account must have sufficient Flow tokens to cover the transaction fees.
 *
 * Read more about [transaction roles](https://docs.onflow.org/concepts/transaction-signing/#payer) and [transaction fees](https://docs.onflow.org/concepts/fees/).
 *
 * @param ax An account address or an array of account addresses
 * @returns A function that takes an interaction object and returns a new interaction object with the payer(s) added
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Using current user as payer (most common case)
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(acct: AuthAccount) {
 *         log("Transaction fees paid by: ".concat(acct.address.toString()))
 *       }
 *     }
 *   `,
 *   payer: fcl.authz // Current user as payer
 * });
 *
 * // Using custom payer with builder pattern
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(acct: AuthAccount) {
 *         // Transaction logic
 *       }
 *     }
 *   `,
 *   fcl.proposer(fcl.authz),        // Current user as proposer
 *   fcl.authorizations([fcl.authz]), // Current user as authorizer
 *   fcl.payer(customPayerAuthz)     // Custom payer pays fees
 * ]);
 *
 * // Multiple payers (advanced use case)
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(acct: AuthAccount) {
 *         // Transaction logic
 *       }
 *     }
 *   `,
 *   fcl.payer([payerAuthz1, payerAuthz2]) // Multiple payers split fees
 * ]);
 */
function payer() {
  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  if (!Array.isArray(ax)) ax = [ax];
  return pipe(ax.map(authz => {
    return prepAccount(authz, {
      role: typedefs.TransactionRole.PAYER
    });
  }));
}

/**
 * A builder function that creates a ping interaction to test connectivity to the Flow Access Node.
 *
 * The ping interaction is a simple way to test if the Flow Access Node is reachable and responding. This is useful for health checks, connectivity testing, and debugging network issues.
 *
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Simple ping to test connectivity
 * try {
 *   const response = await fcl.send([fcl.ping()]);
 *   console.log("Access Node is reachable");
 * } catch (error) {
 *   console.error("Access Node is not reachable:", error);
 * }
 *
 * // Use ping for health checks
 * const healthCheck = async () => {
 *   try {
 *     await fcl.send([fcl.ping()]);
 *     return { status: "healthy", timestamp: new Date().toISOString() };
 *   } catch (error) {
 *     return { status: "unhealthy", error: error.message, timestamp: new Date().toISOString() };
 *   }
 * };
 *
 * const health = await healthCheck();
 * console.log("Health status:", health);
 */
function ping() {
  return makePing;
}

/**
 * A builder function that sets the reference block for a transaction.
 *
 * The reference block specifies an expiration window (measured in blocks) during which a transaction is considered valid by the network.
 * A transaction will be rejected if it is submitted past its expiry block. Flow calculates transaction expiry using the reference block field.
 *
 * @param refBlock The reference block ID
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Set specific reference block for transaction
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Transaction with custom reference block")
 *       }
 *     }
 *   `,
 *   fcl.ref("a1b2c3d4e5f6789..."), // Custom reference block ID
 *   fcl.proposer(fcl.authz),
 *   fcl.payer(fcl.authz),
 *   fcl.authorizations([fcl.authz]),
 *   fcl.limit(100)
 * ]);
 *
 * // Usually, you don't need to set reference block manually
 * // as FCL will automatically set it to the latest block
 */
function ref(refBlock) {
  return pipe([ix => {
    ix.message.refBlock = refBlock;
    return Ok(ix);
  }]);
}

/**
 * A builder function that creates a script interaction. Scripts allow you to write arbitrary non-mutating Cadence code on the Flow blockchain and return data.
 *
 * You can learn more about [Cadence here](https://cadence-lang.org/docs/language), but we are now only interested in executing the script code and getting back the data.
 *
 * We can execute a script using the latest state of the Flow blockchain or we can choose to execute the script at a specific time in history defined by a block height or block ID.
 *
 * Block ID is SHA3-256 hash of the entire block payload, but you can get that value from the block response properties.
 *
 * Block height expresses the height of the block in the chain.
 *
 * @param args The arguments to pass to the template
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * const result = await fcl.query({
 *   cadence: `
 *     access(all) fun main(a: Int, b: Int, addr: Address): Int {
 *       log(addr)
 *       return a + b
 *     }
 *   `,
 *   args: (arg, t) => [
 *     arg(7, t.Int), // a: Int
 *     arg(6, t.Int), // b: Int
 *     arg("0xba1132bc08f82fe2", t.Address), // addr: Address
 *   ],
 * });
 *
 * console.log(result); // 13
 */
function script() {
  return pipe([makeScript, put("ix.cadence", utilTemplate.template(...arguments))]);
}

const DEFAULT_SCRIPT_ACCOUNTS = [];
const DEFAULT_REF = null;

/**
 * A template builder to use a Cadence transaction for an interaction. FCL "mutate" does the work of building, signing, and sending a transaction behind the scenes.
 *
 * Flow supports great flexibility when it comes to transaction signing, we can define multiple authorizers (multi-sig transactions) and have different payer account than proposer.
 *
 * @param args The arguments to pass to the template
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl"
 *
 * // Basic transaction usage
 * await fcl.mutate({
 *   cadence: `
 *     transaction(a: Int) {
 *       prepare(acct: &Account) {
 *         log(acct)
 *         log(a)
 *       }
 *     }
 *   `,
 *   args: (arg, t) => [
 *     arg(6, t.Int)
 *   ],
 *   limit: 50
 * })
 *
 * // Single party, single signature
 * // Proposer, payer and authorizer are the same account
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(acct: &Account) {}
 *     }
 *   `,
 *   authz: currentUser, // Optional. Will default to currentUser if not provided.
 *   limit: 50,
 * })
 *
 * // Multiple parties
 * // Proposer and authorizer are the same account, but different payer
 * await fcl.mutate({
 *   cadence: `
 *     transaction {
 *       prepare(acct: &Account) {}
 *     }
 *   `,
 *   proposer: authzFn,
 *   payer: authzTwoFn,
 *   authorizations: [authzFn],
 *   limit: 50,
 * })
 */
function transaction() {
  return pipe([makeTransaction, put("ix.cadence", utilTemplate.template(...arguments)), ix => {
    ix.message.refBlock = ix.message.refBlock || DEFAULT_REF;
    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
    return Ok(ix);
  }]);
}

function invariant() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length > 1) {
    const [predicate, message] = args;
    return invariant((ix, _ref) => {
      let {
        Ok,
        Bad
      } = _ref;
      return predicate ? Ok(ix) : Bad(ix, message);
    });
  }
  const [fn] = args;
  return ix => fn(ix, {
    Ok,
    Bad
  });
}

/**
 * A builder function that intercepts and modifies a voucher.
 *
 * This function is useful for debugging, logging, or making modifications to
 * the transaction data. The voucher contains all the transaction details in their final form.
 *
 * @param fn The function to intercept and potentially modify the voucher
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Intercept voucher for logging
 * await fcl.send([
 *   fcl.transaction`
 *     transaction {
 *       prepare(account: AuthAccount) {
 *         log("Transaction executed")
 *       }
 *     }
 *   `,
 *   fcl.voucherIntercept((voucher) => {
 *     console.log("Voucher details:", {
 *       cadence: voucher.cadence,
 *       proposalKey: voucher.proposalKey,
 *       payer: voucher.payer,
 *       authorizers: voucher.authorizers,
 *       computeLimit: voucher.computeLimit
 *     });
 *   }),
 *   fcl.proposer(fcl.authz),
 *   fcl.payer(fcl.authz),
 *   fcl.authorizations([fcl.authz])
 * ]);
 */
function voucherIntercept(fn) {
  return put("ix.voucher-intercept", fn);
}

/**
 * Subscribe to events with the given filter and parameters.
 *
 * Creates a subscription to listen for real-time events from the Flow blockchain. This function configures
 * the subscription parameters for filtering specific events based on type, addresses, contracts, and other criteria.
 *
 * Events are emitted by Cadence code during transaction execution and provide insights into what happened.
 * Subscriptions allow you to listen for these events in real-time without polling.
 *
 * @param filter The filter configuration for the event subscription
 * @param filter.startBlockId Optional block ID to start subscription from
 * @param filter.startHeight Optional block height to start subscription from
 * @param filter.eventTypes Array of event types to filter for
 * @param filter.addresses Array of account addresses to filter events from
 * @param filter.contracts Array of contract names to filter events from
 * @param filter.heartbeatInterval Interval for heartbeat messages in milliseconds
 * @returns A function that processes an interaction object
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Subscribe to FlowToken transfer events
 * const subscription = await fcl.send([
 *   fcl.subscribeEvents({
 *     eventTypes: [
 *       "A.1654653399040a61.FlowToken.TokensWithdrawn",
 *       "A.1654653399040a61.FlowToken.TokensDeposited"
 *     ],
 *     startHeight: 1000000, // Start from specific block height
 *     heartbeatInterval: 3000 // 3 second heartbeat
 *   })
 * ]);
 *
 * // Subscribe to events from specific contracts
 * const contractSubscription = await fcl.send([
 *   fcl.subscribeEvents({
 *     contracts: ["FlowToken", "FungibleToken"],
 *     addresses: ["0x1654653399040a61"]
 *   })
 * ]);
 *
 * // Handle the subscription data elsewhere using fcl.subscribe()
 */
function subscribeEvents(_ref) {
  let {
    startBlockId,
    startHeight,
    eventTypes,
    addresses,
    contracts,
    heartbeatInterval
  } = _ref;
  utilInvariant.invariant(!(startBlockId && startHeight), `SDK Subscribe Events Error: Cannot set both startBlockId and startHeight.`);
  return pipe([makeSubscribeEvents, ix => {
    ix.subscribeEvents.startBlockId = startBlockId ?? null;
    ix.subscribeEvents.startHeight = startHeight ?? null;
    ix.subscribeEvents.eventTypes = eventTypes ?? null;
    ix.subscribeEvents.addresses = addresses ?? null;
    ix.subscribeEvents.contracts = contracts ?? null;
    ix.subscribeEvents.heartbeatInterval = heartbeatInterval ?? null;
    return Ok(ix);
  }]);
}

/**
 * Resolves the sequence number for the proposer account by querying the blockchain.
 *
 * @param config Configuration containing the node endpoint
 * @returns A function that resolves the proposer sequence number for an interaction
 */
const resolveProposerSequenceNumber = _ref => {
  let {
    node
  } = _ref;
  return async ix => {
    if (!isTransaction(ix)) return Ok(ix);
    if (ix.accounts[ix.proposer].sequenceNum) return Ok(ix);
    const sendFn = await config.config.first(["sdk.transport", "sdk.send"], transportHttp.send);
    utilInvariant.invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    const response$1 = await sendFn(await build([getAccount(ix.accounts[ix.proposer].addr)]), {
      response: response,
      Buffer: rlp.Buffer,
      ix: ixModule
    }, {
      node
    });
    const decoded = await decodeResponse(response$1);
    ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
    return Ok(ix);
  };
};

async function getRefId(opts) {
  const node = await config.config().get("accessNode.api");
  const sendFn = await config.config.first(["sdk.transport", "sdk.send"], transportHttp.send);
  utilInvariant.invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
  var ix;
  ix = await pipe(initInteraction(), [getBlock()]);
  ix = await sendFn(ix, {
    response,
    Buffer: rlp.Buffer,
    ix: ixModule
  }, {
    node
  });
  ix = await decodeResponse(ix);
  return ix.id;
}

/**
 * Resolves the reference block ID for a transaction by querying the latest block from the network.
 *
 * @param opts Optional configuration parameters
 * @returns A function that resolves the reference block ID for an interaction
 */
function resolveRefBlockId(opts) {
  return async ix => {
    if (!isTransaction(ix)) return Ok(ix);
    if (ix.message.refBlock) return Ok(ix);
    ix.message.refBlock = await getRefId();
    return Ok(ix);
  };
}

function mockAccountResponse(ix) {
  let numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  // prettier-ignore
  utilInvariant.invariant(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix);
  // prettier-ignore
  utilInvariant.invariant(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
  const address = ix.account.addr;
  return {
    account: {
      addr: address,
      keys: Array.from({
        length: numberOfKeys
      }, (_, i) => ({
        index: i,
        sequenceNumber: 42
      }))
    }
  };
}
function mockGetBlockResponse(ix) {
  return {
    tag: "GET_BLOCK",
    block: {
      id: "32"
    }
  };
}
const identity = v => v;
function mockSend() {
  let fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
  return async function execSend(ix) {
    ix = await ix;
    switch (true) {
      case isGetAccount(ix):
        return mockAccountResponse(ix);
      case isGetBlock(ix):
        return mockGetBlockResponse();
      default:
        return fallback(ix);
    }
  };
}

/**
 * Generates a unique identifier for an account based on its address and key ID.
 *
 * @param acct The account object
 * @returns A string identifier in the format "address-keyId"
 */
const idof = acct => `${utilAddress.withPrefix(acct.addr)}-${acct.keyId}`;

/**
 * Generates a test signature string for an account.
 *
 * @param opts Partial account object containing address and keyId
 * @returns A test signature string in the format "SIGNATURE.address.keyId"
 */
function sig(opts) {
  return ["SIGNATURE", opts.addr, opts.keyId].join(".");
}
/**
 * Creates a test authorization function for testing transactions.
 *
 * @param opts Optional configuration including custom signing function
 * @returns An authorization function that can be used in tests
 */
function authzFn() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    const acct = {
      ...account,
      ...opts,
      resolve: null,
      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
    };
    return acct;
    function fallbackSigningFunction(_signable) {
      return {
        addr: acct.addr,
        keyId: acct.keyId,
        signature: sig(acct)
      };
    }
  };
}
/**
 * Creates a test authorization resolver that can be used for testing account resolution.
 *
 * @param opts Optional configuration including temporary ID
 * @returns A function that returns an account with resolve capability
 */
function authzResolve() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    const {
      tempId,
      ...rest
    } = opts;
    return {
      ...account,
      tempId: tempId || "WITH_RESOLVE",
      resolve: authzFn(rest)
    };
  };
}
const ROLE = {
  proposer: false,
  authorizer: false,
  payer: false
};
/**
 * Creates a test authorization resolver that handles multiple accounts with different roles.
 *
 * @param opts Configuration including authorizations array and optional proposer/payer
 * @returns A function that returns an account with multi-role resolve capability
 */
function authzResolveMany() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    authorizations: []
  };
  return function (account) {
    const tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
    return {
      ...account,
      tempId,
      resolve: () => [opts.proposer && authzFn(opts.proposer)({
        role: {
          ...ROLE,
          proposer: true
        }
      }), ...opts.authorizations.map(authzFn).map(d => d({
        role: {
          ...ROLE,
          authorizer: true
        }
      })), opts.payer && authzFn(opts.payer)({
        role: {
          ...ROLE,
          payer: true
        }
      })].filter(Boolean)
    };
  };
}

/**
 * Creates a deep test authorization resolver with nested resolution for complex testing scenarios.
 *
 * @param opts Configuration including authorizations array and optional proposer/payer
 * @param depth The depth of nesting for the resolver (default: 1)
 * @returns A function that returns an account with deep nested resolve capability
 */
function authzDeepResolveMany() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    authorizations: []
  };
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return function (account) {
    const tempId = opts.tempId || "AUTHZ_DEEP_RESOLVE_MANY";
    return {
      ...account,
      tempId,
      resolve: depth > 0 ? authzDeepResolveMany(opts, depth - 1)(account).resolve : authzResolveMany(opts)(account).resolve
    };
  };
}

/**
 * Runs a set of functions on an interaction
 *
 * This is a utility function for testing that builds and resolves an interaction with the provided builder functions.
 * It automatically adds a reference block and then resolves the interaction for testing purposes.
 *
 * @param fns An array of functions to run on the interaction
 * @returns A promise that resolves to the resolved interaction
 *
 * @example
 * import { run } from "@onflow/sdk"
 * import * as fcl from "@onflow/fcl";
 *
 * // Test a simple script interaction
 * const result = await run([
 *   fcl.script`
 *     access(all) fun main(): Int {
 *       return 42
 *     }
 *   `
 * ]);
 *
 * console.log(result.cadence); // The Cadence script
 * console.log(result.tag); // "SCRIPT"
 *
 * // Test a transaction with arguments
 * const txResult = await run([
 *   fcl.transaction`
 *     transaction(amount: UFix64) {
 *       prepare(account: AuthAccount) {
 *         log(amount)
 *       }
 *     }
 *   `,
 *   fcl.args([fcl.arg("10.0", fcl.t.UFix64)])
 * ]);
 *
 * console.log(txResult.message.arguments); // The resolved arguments
 */
const run = function () {
  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return build([ref("123"), ...fns]).then(resolve);
};

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  authzDeepResolveMany: authzDeepResolveMany,
  authzFn: authzFn,
  authzResolve: authzResolve,
  authzResolveMany: authzResolveMany,
  idof: idof,
  mockSend: mockSend,
  run: run,
  sig: sig
});

const VERSION = "1.10.0";

const flowMainnet = {
  "flow.network": "mainnet",
  "accessNode.api": "https://rest-mainnet.onflow.org",
  "discovery.wallet": "https://fcl-discovery.onflow.org/authn"
};
const flowTestnet = {
  "flow.network": "testnet",
  "accessNode.api": "https://rest-testnet.onflow.org",
  "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn"
};
const flowEmulator = {
  "flow.network": "local",
  "accessNode.api": "http://127.0.0.1:8888",
  "discovery.wallet": "http://localhost:8701/fcl/authn"
};

/**
 * Options for configuring the SDK client.
 */

/**
 * Creates a new SDK context with the provided configuration.
 */
function createContext(_ref) {
  let {
    accessNodeUrl,
    transport,
    computeLimit,
    customResolver,
    customDecoders = {},
    contracts = {}
  } = _ref;
  if (!transport) {
    throw new Error("Transport must be provided to create SDK context");
  }

  // Ensure transport is an instance of SdkTransport
  if (typeof transport.send !== "function") {
    throw new Error("Invalid transport provided, must implement send method");
  }
  if (typeof transport.subscribe !== "function") {
    throw new Error("Invalid transport provided, must implement subscribe method");
  }
  if (!accessNodeUrl) {
    throw new Error("Access node must be provided to create SDK context");
  }
  if (typeof accessNodeUrl !== "string") {
    throw new Error("Access node must be a string URL");
  }
  if (typeof computeLimit !== "number" || computeLimit <= 0) {
    throw new Error("Compute limit must be a positive number");
  }
  return {
    transport,
    accessNodeUrl,
    computeLimit,
    customResolver,
    customDecoders,
    debug: {},
    contracts,
    legacyContractIdentifiers: {}
  };
}

/**
 * Creates an SDK client with the provided options.
 * @param options - Configuration options for the SDK client.
 * @returns A client object with methods to interact with the Flow blockchain.
 * @example
 * const client = createSdkClient({
 *  accessNodeUrl: "https://rest-mainnet.onflow.org",
 *  transport: myTransport,
 *  computeLimit: 1000,
 * })
 * client.send([myScript, myTransaction])
 *   .then(client.decode)
 *   .catch(error => console.error("Error sending request:", error))
 */
function createSdkClient(options) {
  const context = createContext(options);
  return {
    send: createSend(context),
    subscribe: createSubscribe(context),
    subscribeRaw: createSubscribeRaw(context),
    account: createAccount(context),
    block: createBlock(context),
    resolve: createResolve(context),
    decode: createDecode(context)
  };
}

/**
 * Legacy function for setting parameters on an interaction.
 *
 * @deprecated This function has been removed. Use `args` instead.
 *
 * @param params The parameters to set
 */
const params = params => logger__namespace.log.deprecate({
  pkg: "FCL/SDK",
  message: `The params builder has been removed from the Flow JS-SDK/FCL.`,
  transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
  level: logger__namespace.LEVELS.error
});

/**
 * Legacy function for setting a single parameter on an interaction.
 *
 * @deprecated This function has been removed. Use `arg` instead.
 *
 * @param params The parameter to set
 */
const param = params => logger__namespace.log.deprecate({
  pkg: "FCL/SDK",
  message: `The param builder has been removed from the Flow JS-SDK/FCL.`,
  transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
  level: logger__namespace.LEVELS.error
});

Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () { return config.config; }
});
Object.defineProperty(exports, "cadence", {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
Object.defineProperty(exports, "cdc", {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
exports.t = types__namespace;
exports.SubscriptionsNotSupportedError = SubscriptionsNotSupportedError;
exports.TestUtils = index;
exports.VERSION = VERSION;
exports.account = account;
exports.arg = arg;
exports.args = args;
exports.atBlockHeight = atBlockHeight;
exports.atBlockId = atBlockId;
exports.atLatestBlock = atLatestBlock;
exports.authorization = authorization;
exports.authorizations = authorizations;
exports.block = block;
exports.build = build;
exports.createSdkClient = createSdkClient;
exports.createSignableVoucher = createSignableVoucher;
exports.decode = decode;
exports.destroy = destroy;
exports.encodeMessageFromSignable = encodeMessageFromSignable;
exports.encodeTransactionEnvelope = encodeTransactionEnvelope;
exports.encodeTransactionPayload = encodeTransactionPayload;
exports.encodeTxIdFromVoucher = encodeTxIdFromVoucher;
exports.flowEmulator = flowEmulator;
exports.flowMainnet = flowMainnet;
exports.flowTestnet = flowTestnet;
exports.get = get;
exports.getAccount = getAccount;
exports.getBlock = getBlock;
exports.getBlockHeader = getBlockHeader;
exports.getCollection = getCollection;
exports.getEvents = getEvents;
exports.getEventsAtBlockHeightRange = getEventsAtBlockHeightRange;
exports.getEventsAtBlockIds = getEventsAtBlockIds;
exports.getNetworkParameters = getNetworkParameters;
exports.getNodeVersionInfo = getNodeVersionInfo;
exports.getTransaction = getTransaction;
exports.getTransactionStatus = getTransactionStatus;
exports.initInteraction = initInteraction;
exports.interaction = interaction;
exports.invariant = invariant;
exports.isBad = isBad;
exports.isGetAccount = isGetAccount;
exports.isGetBlock = isGetBlock;
exports.isGetBlockHeader = isGetBlockHeader;
exports.isGetCollection = isGetCollection;
exports.isGetEvents = isGetEvents;
exports.isGetNetworkParameters = isGetNetworkParameters;
exports.isGetNodeVersionInfo = isGetNodeVersionInfo;
exports.isGetTransaction = isGetTransaction;
exports.isGetTransactionStatus = isGetTransactionStatus;
exports.isOk = isOk;
exports.isPing = isPing;
exports.isScript = isScript;
exports.isTransaction = isTransaction;
exports.isUnknown = isUnknown;
exports.limit = limit;
exports.nodeVersionInfo = nodeVersionInfo;
exports.param = param;
exports.params = params;
exports.payer = payer;
exports.ping = ping;
exports.pipe = pipe;
exports.proposer = proposer;
exports.put = put;
exports.ref = ref;
exports.resolve = resolve;
exports.resolveAccounts = resolveAccounts;
exports.resolveArguments = resolveArguments;
exports.resolveCadence = resolveCadence;
exports.resolveFinalNormalization = resolveFinalNormalization;
exports.resolveProposerSequenceNumber = resolveProposerSequenceNumber;
exports.resolveRefBlockId = resolveRefBlockId;
exports.resolveSignatures = resolveSignatures;
exports.resolveValidators = resolveValidators;
exports.resolveVoucherIntercept = resolveVoucherIntercept;
exports.response = response;
exports.script = script;
exports.send = send;
exports.subscribe = subscribe;
exports.subscribeEvents = subscribeEvents;
exports.subscribeRaw = subscribeRaw;
exports.transaction = transaction;
exports.update = update;
exports.validator = validator;
exports.voucherIntercept = voucherIntercept;
exports.voucherToTxId = voucherToTxId;
exports.why = why;
Object.keys(typedefs).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return typedefs[k]; }
  });
});
//# sourceMappingURL=sdk.js.map
