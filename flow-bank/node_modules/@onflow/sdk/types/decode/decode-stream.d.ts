import { StreamConnection } from "@onflow/typedefs";
type DecodeResponseFn = (response: Record<string, any>, customDecoders?: Record<string, any>) => Promise<any>;
/**
 * Pipes a generic stream of data into a granular stream of decoded data.
 *
 * The data is decoded per channel and emitted in order. This function is particularly useful
 * for handling streaming responses from Flow Access API, such as event subscriptions or
 * real-time block updates. It ensures that data is properly decoded and emitted in the
 * correct order while maintaining the stream's event-driven nature.
 *
 * All topics for a given message will be emitted synchronously before moving on to the next
 * message. The internal queue ensures that data is emitted in order and avoids race conditions
 * when decoding.
 *
 * @param stream The raw stream connection to decode
 * @param decodeResponse Function to decode response data
 * @param customDecoders Optional custom decoders for specific data types
 * @returns A new stream connection with decoded data
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Create a subscription stream
 * const rawStream = await fcl.send([
 *   fcl.subscribeEvents({
 *     eventTypes: ["flow.AccountCreated"],
 *     startHeight: 0
 *   })
 * ]);
 *
 * // Decode the stream data
 * const decodedStream = fcl.decodeStream(
 *   rawStream,
 *   fcl.decodeResponse,
 *   {}
 * );
 *
 * // Listen for decoded events
 * decodedStream.on("events", (events) => {
 *   events.forEach(event => {
 *     console.log("Decoded event:", event);
 *   });
 * });
 *
 * decodedStream.on("error", (error) => {
 *   console.error("Stream error:", error);
 * });
 *
 * decodedStream.on("close", () => {
 *   console.log("Stream closed");
 * });
 */
export declare const decodeStream: (stream: StreamConnection<{
    data: any;
}>, decodeResponse: DecodeResponseFn, customDecoders?: Record<string, any>) => StreamConnection<any>;
export {};
