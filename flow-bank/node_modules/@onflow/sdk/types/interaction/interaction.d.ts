import { TransactionRole, Interaction, InteractionAccount } from "@onflow/typedefs";
import { TypeDescriptorInput, TypeDescriptor } from "@onflow/types";
export type AuthorizationFn = (acct: InteractionAccount) => InteractionAccount;
export type AccountAuthorization = (AuthorizationFn & Partial<InteractionAccount>) | Partial<InteractionAccount>;
type CadenceArgument<T extends TypeDescriptor<any, any>> = {
    value: TypeDescriptorInput<T>;
    xform: T;
};
export { CadenceArgument };
export type InteractionBuilderFn = (ix: Interaction) => Interaction | Promise<Interaction>;
/**
 * Creates a new interaction object with default values.
 *
 * @returns A new interaction object initialized with default values
 */
export declare const initInteraction: () => Interaction;
/**
 * Creates a new interaction object with default values.
 *
 * @deprecated Use initInteraction() instead. This function will be removed in a future version.
 *
 * @returns A new interaction object initialized with default values
 */
export declare const interaction: () => Interaction;
/**
 * Checks if a value is a number.
 *
 * @param d The value to check
 * @returns True if the value is a number, false otherwise
 *
 * @example
 * import { isNumber } from "@onflow/sdk"
 *
 * console.log(isNumber(42)); // true
 * console.log(isNumber("42")); // false
 * console.log(isNumber(3.14)); // true
 * console.log(isNumber(null)); // false
 */
export declare const isNumber: (d: any) => d is number;
/**
 * Checks if a value is an array.
 *
 * @param d The value to check
 * @returns True if the value is an array, false otherwise
 *
 * @example
 * import { isArray } from "@onflow/sdk"
 *
 * console.log(isArray([1, 2, 3])); // true
 * console.log(isArray("hello")); // false
 * console.log(isArray({})); // false
 * console.log(isArray(null)); // false
 */
export declare const isArray: (d: any) => d is any[];
/**
 * Checks if a value is an object (but not null).
 *
 * @param d The value to check
 * @returns True if the value is an object and not null, false otherwise
 *
 * @example
 * import { isObj } from "@onflow/sdk"
 *
 * console.log(isObj({})); // true
 * console.log(isObj({name: "Alice"})); // true
 * console.log(isObj(null)); // false
 * console.log(isObj("string")); // false
 * console.log(isObj([])); // true (arrays are objects)
 */
export declare const isObj: (d: any) => d is Record<string, any>;
/**
 * Checks if a value is null or undefined.
 *
 * @param d The value to check
 * @returns True if the value is null or undefined, false otherwise
 *
 * @example
 * import { isNull } from "@onflow/sdk"
 *
 * console.log(isNull(null)); // true
 * console.log(isNull(undefined)); // true
 * console.log(isNull("")); // false
 * console.log(isNull(0)); // false
 * console.log(isNull(false)); // false
 */
export declare const isNull: (d: any) => d is null;
/**
 * Checks if a value is a function.
 *
 * @param d The value to check
 * @returns True if the value is a function, false otherwise
 *
 * @example
 * import { isFn } from "@onflow/sdk"
 *
 * console.log(isFn(() => {})); // true
 * console.log(isFn(function() {})); // true
 * console.log(isFn("function")); // false
 * console.log(isFn({})); // false
 */
export declare const isFn: (d: any) => d is Function;
/**
 * Checks if an object is a valid interaction.
 *
 * @param ix The object to check
 * @returns True if the object is a valid interaction, false otherwise
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { isInteraction, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * console.log(isInteraction(interaction)); // true
 * console.log(isInteraction({})); // false
 * console.log(isInteraction(null)); // false
 *
 * // Check if a builder result is a valid interaction
 * const built = await fcl.build([fcl.script`access(all) fun main(): Int { return 42 }`]);
 * console.log(isInteraction(built)); // true
 */
export declare const isInteraction: (ix: unknown) => boolean;
/**
 * Marks an interaction as successful and returns the interaction object.
 *
 * @param ix The interaction to mark as successful
 * @returns The interaction object with status set to OK
 *
 * @example
 * import { Ok, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * const successfulInteraction = Ok(interaction);
 * console.log(successfulInteraction.status); // "OK"
 */
export declare const Ok: (ix: Interaction) => Interaction;
/**
 * Marks an interaction as failed with a specific reason and returns the interaction object.
 *
 * @param ix The interaction to mark as failed
 * @param reason The reason for the failure
 * @returns The interaction object with status set to BAD and reason set
 *
 * @example
 * import { Bad, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 * const failedInteraction = Bad(interaction, "Invalid transaction signature");
 * console.log(failedInteraction.status); // "BAD"
 * console.log(failedInteraction.reason); // "Invalid transaction signature"
 */
export declare const Bad: (ix: Interaction, reason: string) => Interaction;
interface IPrepAccountOpts {
    role?: TransactionRole | null;
}
/**
 * Creates a new account object with default values.
 *
 * @returns A new account object initialized with default values
 *
 * @example
 * import { initAccount } from "@onflow/sdk"
 *
 * const account = initAccount();
 * console.log(account.addr); // null
 * console.log(account.keyId); // null
 * console.log(account.role.proposer); // false
 *
 * // Typically used internally by other functions
 * // You'll more commonly use authorization() or prepAccount()
 */
export declare const initAccount: () => InteractionAccount;
/**
 * Prepares and configures an account for use in an interaction with a specific role.
 *
 * @param acct The account authorization function or account object
 * @param opts Configuration options including the role for the account
 * @returns A function that adds the prepared account to an interaction
 */
export declare const prepAccount: (acct: AccountAuthorization, opts?: IPrepAccountOpts) => (ix: Interaction) => Interaction;
/**
 * Creates an argument resolver and adds it to an interaction.
 *
 * This function is typically used internally by the SDK to handle arguments in scripts and transactions.
 * For most use cases, you should use `fcl.arg()` instead of this function directly.
 *
 * @param arg The argument configuration object
 * @returns A function that adds the argument to an interaction
 *
 * @example
 * import { makeArgument, initInteraction } from "@onflow/sdk"
 * import * as fcl from "@onflow/fcl";
 *
 * const interaction = initInteraction();
 *
 * // Create an argument resolver (usually you'd use fcl.arg instead)
 * const argResolver = {
 *   value: 42,
 *   xform: fcl.t.Int,
 *   resolve: (value, xform) => ({ value, xform })
 * };
 *
 * // Add the argument to the interaction
 * makeArgument(argResolver)(interaction);
 *
 * console.log(interaction.message.arguments.length); // 1
 *
 * // Preferred way - use fcl.arg instead:
 * // fcl.args([fcl.arg(42, fcl.t.Int)])
 */
export declare const makeArgument: (arg: Record<string, any>) => (ix: Interaction) => Interaction;
export declare const makeUnknown: (ix: Interaction) => Interaction;
export declare const makeScript: (ix: Interaction) => Interaction;
export declare const makeTransaction: (ix: Interaction) => Interaction;
export declare const makeGetTransactionStatus: (ix: Interaction) => Interaction;
export declare const makeGetTransaction: (ix: Interaction) => Interaction;
export declare const makeGetAccount: (ix: Interaction) => Interaction;
export declare const makeGetEvents: (ix: Interaction) => Interaction;
export declare const makePing: (ix: Interaction) => Interaction;
export declare const makeGetBlock: (ix: Interaction) => Interaction;
export declare const makeGetBlockHeader: (ix: Interaction) => Interaction;
export declare const makeGetCollection: (ix: Interaction) => Interaction;
export declare const makeGetNetworkParameters: (ix: Interaction) => Interaction;
export declare const makeSubscribeEvents: (ix: Interaction) => Interaction;
export declare const makeGetNodeVerionInfo: (ix: Interaction) => Interaction;
export declare const isUnknown: (ix: Interaction) => boolean;
export declare const isScript: (ix: Interaction) => boolean;
export declare const isTransaction: (ix: Interaction) => boolean;
export declare const isGetTransactionStatus: (ix: Interaction) => boolean;
export declare const isGetTransaction: (ix: Interaction) => boolean;
export declare const isGetAccount: (ix: Interaction) => boolean;
export declare const isGetEvents: (ix: Interaction) => boolean;
export declare const isPing: (ix: Interaction) => boolean;
export declare const isGetBlock: (ix: Interaction) => boolean;
export declare const isGetBlockHeader: (ix: Interaction) => boolean;
export declare const isGetCollection: (ix: Interaction) => boolean;
export declare const isGetNetworkParameters: (ix: Interaction) => boolean;
export declare const isGetNodeVersionInfo: (ix: Interaction) => boolean;
export declare const isSubscribeEvents: (ix: Interaction) => boolean;
/**
 * Checks if an interaction has a successful status.
 *
 * @param ix The interaction to check
 * @returns True if the interaction status is OK, false otherwise
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { isOk } from "@onflow/sdk"
 *
 * // Check if a transaction was successful
 * const response = await fcl.send([
 *   fcl.transaction`transaction { prepare(account: AuthAccount) {} }`
 * ]);
 *
 * if (isOk(response)) {
 *   console.log("Transaction was successful");
 * } else {
 *   console.log("Transaction failed");
 * }
 */
export declare const isOk: (ix: Interaction) => boolean;
/**
 * Checks if an interaction has a failed status.
 *
 * @param ix The interaction to check
 * @returns True if the interaction status is BAD, false otherwise
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { isBad, why } from "@onflow/sdk"
 *
 * const response = await fcl.send([
 *   fcl.transaction`transaction { prepare(account: AuthAccount) {} }`
 * ]);
 *
 * if (isBad(response)) {
 *   console.log("Transaction failed:", why(response));
 * }
 */
export declare const isBad: (ix: Interaction) => boolean;
/**
 * Returns the reason for an interaction failure.
 *
 * @param ix The interaction to get the failure reason from
 * @returns The reason string or undefined if no reason is set
 *
 * @example
 * import { Bad, why, initInteraction } from "@onflow/sdk"
 *
 * const interaction = Bad(initInteraction(), "Network timeout");
 * console.log(why(interaction)); // "Network timeout"
 *
 * // Used with error handling
 * if (isBad(response)) {
 *   console.error("Error occurred:", why(response));
 * }
 */
export declare const why: (ix: Interaction) => string | null;
/**
 * Checks if an object is an account resolver.
 *
 * @param account The object to check
 * @returns True if the object is an account resolver, false otherwise
 *
 * @example
 * import { isAccount, authorization } from "@onflow/sdk"
 *
 * const authz = authorization("0x123", signingFunction);
 * const accountResolver = { kind: "ACCOUNT", addr: "0x123" };
 * const regularObject = { name: "test" };
 *
 * console.log(isAccount(accountResolver)); // true
 * console.log(isAccount(regularObject)); // false
 */
export declare const isAccount: (account: Record<string, any>) => boolean;
/**
 * Checks if an object is an argument resolver.
 *
 * @param argument The object to check
 * @returns True if the object is an argument resolver, false otherwise
 *
 * @example
 * import { isArgument, arg } from "@onflow/sdk"
 *
 * const argumentResolver = { kind: "ARGUMENT", value: 42 };
 * const regularObject = { value: 42 };
 *
 * console.log(isArgument(argumentResolver)); // true
 * console.log(isArgument(regularObject)); // false
 *
 * // Check arguments in a script
 * const scriptArgs = [arg(10, t.Int), arg("hello", t.String)];
 * scriptArgs.forEach(arg => {
 *   if (isArgument(arg)) {
 *     console.log("Valid argument:", arg.value);
 *   }
 * });
 */
export declare const isArgument: (argument: Record<string, any>) => boolean;
type MaybePromise<T> = T | Promise<T>;
/**
 * Async pipe function to compose interactions.
 *
 * The pipe function is the foundation for composing multiple interaction builder functions together.
 * It sequentially applies builder functions to an interaction, allowing for complex interaction construction.
 * Each function in the pipe receives the result of the previous function and can modify or validate the interaction.
 *
 * Pipe has two main forms:
 * 1. `pipe(builderFunctions)`: Returns a builder function
 * 2. `pipe(interaction, builderFunctions)`: Directly executes the pipe on an interaction
 *
 * @param fns Array of builder functions to apply
 * @returns An interaction builder function when called with just functions, or a Promise<Interaction> when called with an interaction and functions
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 *
 * // Using pipe to create a reusable builder
 * const myTransactionBuilder = fcl.pipe([
 *   fcl.transaction`
 *     transaction(amount: UFix64) {
 *       prepare(account: AuthAccount) {
 *         log(amount)
 *       }
 *     }
 *   `,
 *   fcl.args([fcl.arg("10.0", fcl.t.UFix64)]),
 *   fcl.proposer(fcl.authz),
 *   fcl.payer(fcl.authz),
 *   fcl.authorizations([fcl.authz]),
 *   fcl.limit(100)
 * ]);
 *
 * // Use the builder
 * const interaction = await fcl.build([myTransactionBuilder]);
 *
 * // Pipe is used internally by build() and send()
 * await fcl.send([
 *   fcl.script`access(all) fun main(): Int { return 42 }`
 * ]); // This uses pipe internally
 */
declare function pipe(fns: (InteractionBuilderFn | false)[]): InteractionBuilderFn;
declare function pipe(ix: MaybePromise<Interaction>, fns: (InteractionBuilderFn | false)[]): Promise<Interaction>;
export { pipe };
/**
 * Gets a value from an interaction object using a dot-notation key path.
 *
 * @param ix The interaction object
 * @param key The dot-notation key path (e.g., "message.arguments")
 * @param fallback The fallback value if the key is not found
 * @returns The value at the key path or the fallback value
 *
 * @example
 * import { get, put, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 *
 * // Set a value first
 * put("user.name", "Alice")(interaction);
 *
 * // Get the value
 * const userName = get(interaction, "user.name"); // "Alice"
 * const userAge = get(interaction, "user.age", 25); // 25 (fallback)
 *
 * // Get nested values
 * put("config.network.url", "https://access.mainnet.onflow.org")(interaction);
 * const networkUrl = get(interaction, "config.network.url");
 */
export declare const get: (ix: Interaction, key: string, fallback?: any) => any;
/**
 * Sets a value in an interaction object using a dot-notation key path.
 *
 * @param key The dot-notation key path (e.g., "message.arguments")
 * @param value The value to set
 * @returns A function that takes an interaction and sets the value
 *
 * @example
 * import * as fcl from "@onflow/fcl";
 * import { put } from "@onflow/sdk"
 *
 * // Using put in a custom builder function
 * const setCustomData = (data) => put("custom.data", data);
 *
 * await fcl.send([
 *   fcl.script`access(all) fun main(): String { return "Hello" }`,
 *   setCustomData({ userId: 123, timestamp: Date.now() })
 * ]);
 *
 * // Direct usage
 * const interaction = initInteraction();
 * put("network.endpoint", "https://access.mainnet.onflow.org")(interaction);
 */
export declare const put: (key: string, value: any) => (ix: Interaction) => Interaction;
/**
 * Updates a value in an interaction object using a transformation function.
 *
 * @param key The dot-notation key path to update
 * @param fn The transformation function to apply to the existing value
 * @returns A function that takes an interaction and updates the value
 *
 * @example
 * import { update, put, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 *
 * // Set initial value
 * put("counter", 0)(interaction);
 *
 * // Increment counter
 * const increment = update("counter", (current) => (current || 0) + 1);
 * increment(interaction); // counter becomes 1
 * increment(interaction); // counter becomes 2
 *
 * // Update array
 * put("tags", ["flow", "blockchain"])(interaction);
 * const addTag = update("tags", (tags) => [...(tags || []), "web3"]);
 * addTag(interaction); // tags becomes ["flow", "blockchain", "web3"]
 */
export declare const update: <T>(key: string, fn?: (v: T | T[], ...args: any[]) => T | T[]) => (ix: Interaction) => Interaction;
/**
 * Removes a property from an interaction object using a dot-notation key path.
 *
 * @param key The dot-notation key path to remove
 * @returns A function that takes an interaction and removes the property
 *
 * @example
 * import { destroy, put, get, initInteraction } from "@onflow/sdk"
 *
 * const interaction = initInteraction();
 *
 * // Set some values
 * put("user.name", "Alice")(interaction);
 * put("user.email", "alice@example.com")(interaction);
 * put("user.temp", "temporary data")(interaction);
 *
 * console.log(get(interaction, "user.temp")); // "temporary data"
 *
 * // Remove temporary data
 * destroy("user.temp")(interaction);
 *
 * console.log(get(interaction, "user.temp")); // undefined
 * console.log(get(interaction, "user.name")); // "Alice" (still exists)
 */
export declare const destroy: (key: string) => (ix: Interaction) => Interaction;
