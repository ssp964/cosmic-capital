let RpcErrorCode = /*#__PURE__*/function (RpcErrorCode) {
  RpcErrorCode[RpcErrorCode["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  RpcErrorCode[RpcErrorCode["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  RpcErrorCode[RpcErrorCode["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  RpcErrorCode[RpcErrorCode["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  RpcErrorCode[RpcErrorCode["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  return RpcErrorCode;
}({});
class RpcError extends Error {
  constructor(code, message, data) {
    super(message);
    this.code = code;
    this.message = message;
    this.data = data;
  }
}

var ReservedRpcMethods = /*#__PURE__*/function (ReservedRpcMethods) {
  ReservedRpcMethods["HELLO"] = "rpc_hello";
  return ReservedRpcMethods;
}(ReservedRpcMethods || {});
class RpcClient {
  id = 0;
  setSend = () => {};
  _send = (() => new Promise(resolve => {
    this.setSend = resolve;
  }))();
  peerInfo = (() => new Promise((resolve, reject) => {
    this.resolvePeerInfo = resolve;
    this.rejectPeerInfo = reject;
  }))();
  enabledNotifications = [];
  requestHandlers = (() => ({}))();
  subscriptions = (() => ({}))();
  messageListeners = [];
  constructor(_ref) {
    let {
      notifications
    } = _ref;
    this.enabledNotifications = notifications || [];
    this.on(ReservedRpcMethods.HELLO, info => {
      this.resolvePeerInfo(info);
      return this.ownInfo();
    });
  }
  connect(_ref2) {
    let {
      send
    } = _ref2;
    this.setSend(send);
    this.requestWithoutConnection(ReservedRpcMethods.HELLO, this.ownInfo()).then(info => {
      this.resolvePeerInfo(info);
    }).catch(this.rejectPeerInfo);
  }
  ownInfo() {
    return {
      requests: Object.keys(this.requestHandlers),
      notifications: this.enabledNotifications
    };
  }
  async send(msg) {
    return (await this._send)(msg);
  }
  receive(msg) {
    if (msg?.jsonrpc !== "2.0") {
      return;
    }
    if ("method" in msg) {
      if ("id" in msg) {
        this.handleRequest(msg);
      } else {
        this.handleNotification(msg);
      }
    }
    this.messageListeners.forEach(listener => listener(msg));
  }
  async handleRequest(msg) {
    const handler = this.requestHandlers[msg.method];
    if (handler) {
      try {
        const result = await handler(msg.params);
        this.send({
          jsonrpc: "2.0",
          id: msg.id,
          result
        });
      } catch (error) {
        if (error instanceof RpcError) {
          this.send({
            jsonrpc: "2.0",
            id: msg.id,
            error: {
              code: error.code,
              message: error.message,
              data: error.data
            }
          });
        } else {
          this.send({
            jsonrpc: "2.0",
            id: msg.id,
            error: {
              code: RpcErrorCode.INTERNAL_ERROR,
              message: error?.message
            }
          });
        }
      }
    } else {
      this.send({
        jsonrpc: "2.0",
        id: msg.id,
        error: {
          code: RpcErrorCode.METHOD_NOT_FOUND,
          message: `Method not found: ${msg.method}`
        }
      });
    }
  }
  handleNotification(msg) {
    if (this.subscriptions[msg.method]) {
      this.subscriptions[msg.method].forEach(handler => handler(msg.params));
    }
  }
  onMessage(listener) {
    this.messageListeners.push(listener);
    return () => {
      this.messageListeners = this.messageListeners.filter(l => l !== listener);
    };
  }
  async notify(method, params) {
    await this.onceConnected();
    this.send({
      jsonrpc: "2.0",
      method,
      params
    });
  }
  async request(method, params) {
    await this.onceConnected();
    return this.requestWithoutConnection(method, params);
  }
  async requestWithoutConnection(method, params) {
    const id = this.id++;
    let unsub = () => {};
    const result = new Promise((resolve, reject) => {
      unsub = this.onMessage(msg => {
        if (msg.id === id && ("result" in msg || "error" in msg)) {
          if (msg.error) {
            const rpcError = new RpcError(msg.error.code, msg.error.message, msg.error.data);
            reject(rpcError);
          }
          resolve(msg.result);
        }
      });
    }).finally(unsub);
    this.send({
      jsonrpc: "2.0",
      method,
      params,
      id
    });
    return result;
  }
  on(method, handler) {
    this.requestHandlers[method] = handler;
  }
  subscribe(method, handler) {
    this.subscriptions[method] = this.subscriptions[method] || new Set();
    this.subscriptions[method].add(handler);
  }
  unsubscribe(method, handler) {
    this.subscriptions[method]?.delete(handler);
  }
  async onceConnected() {
    return this.peerInfo.then(() => {});
  }
  async getAvailableRequests() {
    return this.peerInfo.then(info => info.requests);
  }
  async getAvailableNotifications() {
    return this.peerInfo.then(info => info.notifications);
  }
}

export { RpcClient, RpcError, RpcErrorCode };
//# sourceMappingURL=index.module.js.map
