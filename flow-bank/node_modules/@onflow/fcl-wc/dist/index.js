'use strict';

var fclCore = require('@onflow/fcl-core');
var utilInvariant = require('@onflow/util-invariant');
var utilLogger = require('@onflow/util-logger');
require('@walletconnect/utils');
var preact = require('preact');
var jsxRuntime = require('preact/jsx-runtime');
var universalProvider = require('@walletconnect/universal-provider');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fclCore__namespace = /*#__PURE__*/_interopNamespaceDefault(fclCore);

let FLOW_METHODS = /*#__PURE__*/function (FLOW_METHODS) {
  FLOW_METHODS["FLOW_AUTHN"] = "flow_authn";
  FLOW_METHODS["FLOW_PRE_AUTHZ"] = "flow_pre_authz";
  FLOW_METHODS["FLOW_AUTHZ"] = "flow_authz";
  FLOW_METHODS["FLOW_USER_SIGN"] = "flow_user_sign";
  return FLOW_METHODS;
}({});
let REQUEST_TYPES = /*#__PURE__*/function (REQUEST_TYPES) {
  REQUEST_TYPES["SESSION_REQUEST"] = "session_proposal";
  REQUEST_TYPES["SIGNING_REQUEST"] = "signing_request";
  return REQUEST_TYPES;
}({});
const SERVICE_PLUGIN_NAME = "fcl-plugin-service-walletconnect";
const WC_SERVICE_METHOD = "WC/RPC";

const PRE_AUTHZ_SERVICE_TYPE = "pre-authz";
function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}
function openDeeplink(url) {
  if (url.startsWith("http")) {
    // Workaround for https://github.com/rainbow-me/rainbowkit/issues/524.
    // Using 'window.open' causes issues on iOS in non-Safari browsers and
    // WebViews where a blank tab is left behind after connecting.
    // This is especially bad in some WebView scenarios (e.g. following a
    // link from Twitter) where the user doesn't have any mechanism for
    // closing the blank tab.
    // For whatever reason, links with a target of "_blank" don't suffer
    // from this problem, and programmatically clicking a detached link
    // element with the same attributes also avoids the issue.
    const link = document.createElement("a");
    link.href = url;
    link.target = "_blank";
    link.rel = "noreferrer noopener";
    link.click();
  } else {
    window.open(url, "_blank");
  }
}
function shouldDeepLink(_ref) {
  let {
    service,
    user
  } = _ref;
  // Only deeplink on mobile
  if (!isMobile()) return false;

  // If this is an authn request, the user has already been deeplinked by connectWc
  if (service.endpoint === FLOW_METHODS.FLOW_AUTHN) return false;

  // If there was a pre-authz WC request, the user has already been deeplinked
  if (service.endpoint === FLOW_METHODS.FLOW_AUTHZ && user?.services?.find(s => s.method === WC_SERVICE_METHOD && s.type === PRE_AUTHZ_SERVICE_TYPE)) return false;
  return true;
}
function preloadImage(url) {
  if (!url) return;
  const img = new Image();
  img.src = url;
}

// Create a new session proposal with the WalletConnect client
async function createSessionProposal(_ref) {
  let {
    provider,
    existingPairing,
    network
  } = _ref;
  const _network = network || (await fclCore__namespace.getChainId());
  const requiredNamespaces = {
    flow: {
      methods: [FLOW_METHODS.FLOW_AUTHN, FLOW_METHODS.FLOW_PRE_AUTHZ, FLOW_METHODS.FLOW_AUTHZ, FLOW_METHODS.FLOW_USER_SIGN],
      chains: [`flow:${_network}`],
      events: ["chainChanged", "accountsChanged"]
    }
  };
  let cleanup;
  const uri = new Promise((resolve, reject) => {
    const onDisplayUri = uri => {
      resolve(uri);
    };
    provider.on("display_uri", onDisplayUri);
    cleanup = () => {
      provider.removeListener("display_uri", onDisplayUri);
      reject(new Error("WalletConnect Session Request aborted"));
    };
  });
  const sessionPromise = provider.connect({
    pairingTopic: existingPairing?.topic,
    namespaces: requiredNamespaces
  }).finally(() => {
    cleanup();
  });
  return {
    uri: await uri,
    approval: () => sessionPromise
  };
}
const request = async _ref2 => {
  let {
    method,
    body,
    session,
    provider,
    isExternal,
    abortSignal,
    disableNotifications
  } = _ref2;
  const [chainId, addr, address] = makeSessionData(session);
  const data = JSON.stringify({
    ...body,
    addr,
    address
  });
  const result = await Promise.race([provider.client.request({
    request: {
      method,
      params: [data]
    },
    chainId,
    topic: provider.session?.topic
  }), new Promise((_, reject) => {
    if (abortSignal?.aborted) {
      reject(new Error("WalletConnect Request aborted"));
    }
    abortSignal?.addEventListener("abort", () => {
      reject(new Error("WalletConnect Request aborted"));
    });
  })]);
  if (typeof result !== "object" || result == null) return;
  switch (result.status) {
    case "APPROVED":
      function addSessionInfo(service) {
        if (service.method === "WC/RPC") {
          return {
            ...service,
            params: {
              ...service.params,
              ...(isExternal ? {
                externalProvider: session.topic
              } : {}),
              ...(disableNotifications ? {
                disableNotifications
              } : {})
            }
          };
        }
        return service;
      }
      if (method === FLOW_METHODS.FLOW_AUTHN) {
        const services = (result?.data?.services ?? []).map(addSessionInfo);
        return {
          ...(result.data ? result.data : {}),
          services
        };
      }
      if (method === FLOW_METHODS.FLOW_PRE_AUTHZ) {
        return {
          ...result.data,
          ...(result.data?.proposer ? {
            proposer: addSessionInfo(result.data.proposer)
          } : {}),
          payer: [...result.data?.payer?.map(addSessionInfo)],
          authorization: [...result.data?.authorization?.map(addSessionInfo)]
        };
      }
      return result.data;
    case "DECLINED":
      throw new Error(`Declined: ${result.reason || "No reason supplied"}`);
    case "REDIRECT":
      return result.data;
    default:
      throw new Error(`Declined: No reason supplied`);
  }
};
function makeSessionData(session) {
  const [namespace, reference, address] = Object.values(session.namespaces).map(namespace => namespace.accounts).flat().filter(account => account.startsWith("flow:"))[0].split(":");
  const chainId = `${namespace}:${reference}`;
  const addr = address;
  return [chainId, addr, address];
}

var css_248z = "*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:\"\"}:host,html{-webkit-text-size-adjust:100%;font-feature-settings:normal;-webkit-tap-highlight-color:transparent;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-feature-settings:normal;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em;font-variation-settings:normal}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]:where(:not([hidden=until-found])){display:none}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.sr-only{clip:rect(0,0,0,0);border-width:0;height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.fixed{position:fixed}.bottom-3{bottom:.75rem}.left-3{left:.75rem}.right-3{right:.75rem}.z-\\[2147483647\\]{z-index:2147483647}.mx-auto{margin-left:auto;margin-right:auto}.ml-2{margin-left:.5rem}.ml-3{margin-left:.75rem}.mt-1{margin-top:.25rem}.flex{display:flex}.inline-flex{display:inline-flex}.h-10{height:2.5rem}.h-5{height:1.25rem}.w-10{width:2.5rem}.w-5{width:1.25rem}.max-w-sm{max-width:24rem}.grow{flex-grow:1}@keyframes slideUp{0%{transform:translateY(100%)}to{transform:translateY(0)}}.animate-slideUp{animation:slideUp .2s ease-out forwards}.self-start{align-self:flex-start}.self-center{align-self:center}.overflow-hidden{overflow:hidden}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-md{border-radius:.375rem}.border{border-width:1px}.border-gray-200{--tw-border-opacity:1;border-color:rgb(229 231 235/var(--tw-border-opacity,1))}.border-transparent{border-color:transparent}.bg-transparent{background-color:transparent}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity,1))}.p-0{padding:0}.p-2{padding:.5rem}.p-4{padding:1rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-medium{font-weight:500}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity,1))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity,1))}.text-gray-900{--tw-text-opacity:1;color:rgb(17 24 39/var(--tw-text-opacity,1))}.shadow-lg{--tw-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -4px rgba(0,0,0,.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color),0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.hover\\:text-gray-500:hover{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity,1))}.focus\\:border-transparent:focus{border-color:transparent}.focus\\:ring-0:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.dark\\:border-gray-600:is(.dark *){--tw-border-opacity:1;border-color:rgb(75 85 99/var(--tw-border-opacity,1))}.dark\\:bg-gray-700:is(.dark *){--tw-bg-opacity:1;background-color:rgb(55 65 81/var(--tw-bg-opacity,1))}.dark\\:text-gray-100:is(.dark *){--tw-text-opacity:1;color:rgb(243 244 246/var(--tw-text-opacity,1))}.dark\\:text-gray-200:is(.dark *){--tw-text-opacity:1;color:rgb(229 231 235/var(--tw-text-opacity,1))}.dark\\:text-gray-300:is(.dark *){--tw-text-opacity:1;color:rgb(209 213 219/var(--tw-text-opacity,1))}.dark\\:hover\\:text-gray-300:hover:is(.dark *){--tw-text-opacity:1;color:rgb(209 213 219/var(--tw-text-opacity,1))}@media (min-width:768px){.md\\:bottom-4{bottom:1rem}.md\\:left-auto{left:auto}.md\\:right-4{right:1rem}.md\\:self-start{align-self:flex-start}}";

function Notification(_ref) {
  let {
    title,
    message,
    icon,
    onClick,
    onDismiss,
    animate
  } = _ref;
  return jsxRuntime.jsxs("div", {
    className: `fixed bottom-3 left-3 right-3 mx-auto z-[2147483647] flex max-w-sm
        overflow-hidden rounded-lg border border-gray-200 bg-white p-4 shadow-lg
        md:bottom-4 md:left-auto md:right-4 dark:bg-gray-700 dark:border-gray-600
        ${animate ? "animate-slideUp" : ""}`,
    role: "alert",
    onClick: e => {
      if (onClick) {
        e.stopPropagation();
        onClick?.();
      }
    },
    children: [icon && jsxRuntime.jsx("img", {
      className: "h-10 w-10 self-center rounded-md md:self-start",
      src: icon,
      alt: title
    }), jsxRuntime.jsxs("div", {
      className: "ml-3 grow",
      children: [jsxRuntime.jsx("p", {
        className: "text-sm font-medium text-gray-900 dark:text-gray-100",
        children: title
      }), jsxRuntime.jsx("p", {
        className: "mt-1 text-sm text-gray-500 dark:text-gray-300",
        children: message
      })]
    }), jsxRuntime.jsxs("button", {
      className: `ml-2 inline-flex rounded-full text-gray-400 hover:text-gray-500 focus:ring-0
          dark:text-gray-200 dark:hover:text-gray-300 ${isMobile() ? "self-center p-2" : "self-start p-0 bg-transparent border-transparent focus:border-transparent"}`,
      onClick: e => {
        e.stopPropagation();
        onDismiss?.();
      },
      children: [jsxRuntime.jsx("span", {
        className: "sr-only",
        children: "Close"
      }), jsxRuntime.jsx("svg", {
        className: "h-5 w-5",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        "aria-hidden": "true",
        children: jsxRuntime.jsx("path", {
          fillRule: "evenodd",
          d: "M14.354 5.646a.5.5 0 00-.708 0L10 9.293 5.354 4.646a.5.5 0 00-.708.708L9.293 10l-4.647 4.646a.5.5 0 00.708.708L10 10.707l4.646 4.647a.5.5 0 00.708-.708L10.707 10l4.647-4.646a.5.5 0 000-.708z"
        })
      })]
    })]
  });
}

let renderRoot = null;
let id = 0;
let dismissTimeout = null;
function createRenderRoot() {
  const shadowHost = document.createElement("div");
  const shadowRoot = shadowHost.attachShadow({
    mode: "open"
  });
  const container = document.createElement("div");
  shadowRoot.appendChild(container);
  document.body.appendChild(shadowHost);
  const style = document.createElement("style");
  style.textContent = css_248z;
  shadowRoot.appendChild(style);

  // Subscribe to root dark mode changes to inherit the theme
  const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
  const listener = () => {
    container.classList.toggle("dark", mediaQuery.matches);
  };
  mediaQuery.addEventListener("change", listener);
  listener();
  return container;
}

/**
 * Show a notification to the user.  Only one notification can be shown at a time and will replace any existing notification.
 */
function showNotification(_ref) {
  let {
    title,
    message,
    icon,
    onClick,
    onDismiss,
    debounceDelay = 0
  } = _ref;
  if (!renderRoot) {
    renderRoot = createRenderRoot();
  }

  // Don't animate if we are replacing an existing notification
  const animate = !dismissTimeout;
  if (dismissTimeout) {
    clearTimeout(dismissTimeout);
    dismissTimeout = null;
  }
  preact.render(jsxRuntime.jsx(Notification, {
    title: title,
    message: message,
    icon: icon,
    onClick: onClick,
    onDismiss: () => {
      onDismiss?.();
      dismissUi();
    },
    animate: animate
  }, id++), renderRoot);
  function dismissUi() {
    if (renderRoot) {
      preact.render(null, renderRoot);
    }
  }
  return {
    dismiss: () => {
      // We need to delay the dismiss to debounce any subsequent notifications
      // This is important when there is both a FCL/WC authz and pre-authz service
      dismissTimeout = setTimeout(() => {
        dismissTimeout = null;
        dismissUi();
      }, debounceDelay);
    }
  };
}

var img = "data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3e%3c!--!Font Awesome Free 6.7.1 by %40fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons%2c Inc.--%3e%3cpath d='M16 64C16 28.7 44.7 0 80 0L304 0c35.3 0 64 28.7 64 64l0 384c0 35.3-28.7 64-64 64L80 512c-35.3 0-64-28.7-64-64L16 64zM224 448a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM304 64L80 64l0 320 224 0 0-320z'/%3e%3c/svg%3e";

function createStore(initialState) {
  const subscribers = new Set();
  let state = initialState;
  const subscribe = subscriber => {
    subscribers.add(subscriber);
    return () => {
      subscribers.delete(subscriber);
    };
  };
  const setState = newState => {
    state = newState;
    subscribers.forEach(subscriber => subscriber(state));
  };
  const getState = () => state;
  return {
    subscribe,
    setState,
    getState
  };
}

let providerStore = createStore({});
const makeServicePlugin = function (provider) {
  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    };
  return {
    name: SERVICE_PLUGIN_NAME,
    f_type: "ServicePlugin",
    type: "discovery-service",
    serviceStrategy: {
      method: WC_SERVICE_METHOD,
      exec: makeExec(provider, config, import('@walletconnect/modal').then(m => m.WalletConnectModal))
    },
    services: []
  };
};
const makeExec = (signerPromise, config, WalletConnectModal) => {
  return async _ref => {
    let {
      service,
      body,
      opts,
      abortSignal,
      user,
      config
    } = _ref;
    // Preload provider image
    preloadImage(service.provider?.icon);
    const {
      wcRequestHook,
      pairingModalOverride,
      disableNotifications: _appDisabledNotifications
    } = config;
    const appDisabledNotifications = service.params?.disableNotifications ?? _appDisabledNotifications;
    const resolvedProvider = await resolveProvider({
      provider: signerPromise,
      externalProviderOrTopic: service.params?.externalProvider
    });
    utilInvariant.invariant(!!resolvedProvider, "WalletConnect is not initialized");
    const {
      provider: provider,
      isExternal
    } = resolvedProvider;
    let session = provider.session ?? null,
      pairing;
    const method = service.endpoint;
    const appLink = validateAppLink(service);

    // If the user is already connected to this session, use it
    if (!!session?.topic && session?.topic === service.params?.externalProvider && method === FLOW_METHODS.FLOW_AUTHN) {
      return user;
    }
    if (session == null) {
      session = await new Promise((resolve, reject) => {
        function onClose() {
          reject(`Declined: Externally Halted`);
        }
        connectWc(WalletConnectModal)({
          service,
          onClose,
          appLink,
          provider,
          method,
          pairing,
          wcRequestHook,
          pairingModalOverride,
          abortSignal,
          network: config.client.network
        }).then(resolve, reject);
      });
    }
    if (wcRequestHook && wcRequestHook instanceof Function) {
      wcRequestHook({
        type: REQUEST_TYPES.SIGNING_REQUEST,
        method,
        service,
        session: session ?? null,
        pairing: null,
        uri: null
      });
    }

    // Deeplink to the wallet app if necessary
    if (shouldDeepLink({
      service,
      user
    })) {
      openDeeplink(appLink);
    }

    // Show notification to the user if not disabled by app developer or wallet
    const walletDisabledNotifications = session?.sessionProperties?.["fclWc.disableNotificationsOnMobile"] === "true";
    const notification = !appDisabledNotifications && !walletDisabledNotifications ? showWcRequestNotification({
      user,
      service
    }) : null;

    // Make request to the WalletConnect client and return the result
    return await request({
      method,
      body,
      session,
      provider,
      abortSignal,
      isExternal,
      disableNotifications: service.params?.disableNotifications
    }).finally(() => notification?.dismiss());
    function validateAppLink(_ref2) {
      let {
        uid
      } = _ref2;
      if (!(uid && /^(ftp|http|https):\/\/[^ "]+$/.test(uid))) {
        utilLogger.log({
          title: "WalletConnect Service Warning",
          message: `service.uid should be a valid universal link url. Found: ${uid}`,
          level: utilLogger.LEVELS.warn
        });
      }
      return uid;
    }
  };
};

// Connect to WalletConnect directly from the browser via deep link or WalletConnectModal
function connectWc(WalletConnectModal) {
  return async _ref3 => {
    let {
      service,
      onClose,
      appLink,
      provider,
      method,
      pairing,
      wcRequestHook,
      pairingModalOverride,
      abortSignal,
      network
    } = _ref3;
    const projectId = provider.providerOpts.projectId;
    utilInvariant.invariant(!!projectId, "Cannot establish connection, WalletConnect projectId is undefined");
    let _uri = null,
      walletConnectModal = null;
    try {
      const {
        uri,
        approval
      } = await createSessionProposal({
        provider,
        existingPairing: pairing,
        network
      });
      if (wcRequestHook && wcRequestHook instanceof Function) {
        wcRequestHook({
          type: REQUEST_TYPES.SESSION_REQUEST,
          method,
          service,
          session: null,
          pairing: pairing ?? null,
          uri: uri ?? null
        });
      }
      if (isMobile()) {
        const queryString = new URLSearchParams({
          uri: uri
        }).toString();
        let url = pairing == null ? appLink + "?" + queryString : appLink;
        openDeeplink(url);
      } else if (!pairing) {
        if (!pairingModalOverride) {
          walletConnectModal = new (await WalletConnectModal)({
            projectId
          });

          // Open WalletConnectModal
          walletConnectModal.openModal({
            uri,
            onClose
          });

          // Subscribe to modal state changes
          const unsubscribeModal = walletConnectModal.subscribeModal(state => {
            if (state.open === false) {
              onClose?.();
              unsubscribeModal();
            }
          });
        } else {
          pairingModalOverride(uri, onClose);
        }
      }
      const session = await Promise.race([approval(), new Promise((_, reject) => {
        if (abortSignal?.aborted) {
          reject(new Error("Session request aborted"));
        }
        abortSignal?.addEventListener("abort", () => {
          reject(new Error("Session request aborted"));
        });
      })]);
      if (session == null) {
        throw new Error("Session request failed");
      }
      return session;
    } catch (error) {
      if (error instanceof Error) {
        utilLogger.log({
          title: `${error.name} Error establishing WalletConnect session`,
          message: `
          ${error.message}
          uri: ${_uri}
        `,
          level: utilLogger.LEVELS.error
        });
      }
      onClose();
      throw error;
    } finally {
      walletConnectModal?.closeModal();
    }
  };
}

/**
 * Show a notification for a WalletConnect request.
 * @param service - The service that is requesting the user's attention.
 * @param user - The user that is being requested to sign a transaction.
 * @returns A close function to dismiss the notification.
 */
function showWcRequestNotification(_ref4) {
  let {
    service,
    user
  } = _ref4;
  const authnService = user?.services?.find(s => s.type === "authn");
  const walletProvider = authnService?.provider || service.provider;
  return showNotification({
    title: walletProvider?.name || "Mobile Wallet",
    message: isMobile() ? "Tap to view request in app" : "Pending request on your mobile device",
    icon: walletProvider?.icon || img,
    onClick: isMobile() && service.uid ? () => openDeeplink(service.uid) : undefined,
    debounceDelay: service.type === "pre-authz" ? 500 : 0
  });
}
async function resolveProvider(_ref5) {
  let {
    provider,
    externalProviderOrTopic
  } = _ref5;
  if (!externalProviderOrTopic) {
    const resolved = await provider;
    return resolved ? {
      provider: resolved,
      isExternal: false
    } : null;
  }

  // If it's a UniversalProvider instance, use it directly and store it.
  if (typeof externalProviderOrTopic !== "string") {
    const topic = externalProviderOrTopic.session?.topic;
    if (!topic) {
      throw new Error("Cannot resolve provider: UniversalProvider is not initialized");
    }
    providerStore.setState({
      [topic]: externalProviderOrTopic
    });
    return {
      provider: externalProviderOrTopic,
      isExternal: true
    };
  }
  const externalTopic = externalProviderOrTopic;
  if (externalTopic) {
    // Check if an external provider was passed in the options.
    let storedProvider = providerStore.getState()[externalTopic];
    if (!storedProvider) {
      // No provider from opts and nothing in store yetâ€”wait for it.
      let unsubStore;
      let timeout;
      storedProvider = await new Promise((resolve, reject) => {
        unsubStore = providerStore.subscribe(() => {
          const provider = providerStore.getState()[externalTopic];
          if (provider) {
            resolve(provider);
          }
        });

        // If the provider is not defined after 5 seconds, reject the promise.
        timeout = setTimeout(() => {
          reject(new Error(`Provider for external topic ${externalTopic} not found after 5 seconds`));
        }, 5000);
      }).finally(() => {
        clearTimeout(timeout);
        unsubStore();
      });
    }
    return {
      provider: storedProvider,
      isExternal: true
    };
  }
  const resolved = await provider;
  return resolved ? {
    provider: resolved,
    isExternal: false
  } : null;
}

const DEFAULT_RELAY_URL = "wss://relay.walletconnect.com";
const DEFAULT_LOGGER = "debug";
let providerPromise = Promise.resolve(null);
const initClient = async _ref => {
  let {
    projectId,
    metadata
  } = _ref;
  utilInvariant.invariant(projectId != null, "FCL Wallet Connect Error: WalletConnect projectId is required");
  try {
    return universalProvider.UniversalProvider.init({
      logger: DEFAULT_LOGGER,
      relayUrl: DEFAULT_RELAY_URL,
      projectId: projectId,
      metadata: metadata
    });
  } catch (error) {
    if (error instanceof Error) {
      utilLogger.log({
        title: `${error.name} fcl-wc Init Client`,
        message: error.message,
        level: utilLogger.LEVELS.error
      });
    }
    throw error;
  }
};
const initLazy = config => {
  const {
    FclWcServicePlugin,
    providerPromise
  } = initHelper(config);
  fclCore__namespace.discovery.authn.update();
  return {
    FclWcServicePlugin,
    providerPromise
  };
};
const init = async config => {
  const {
    FclWcServicePlugin,
    providerPromise
  } = initLazy(config);
  const client = await providerPromise;
  fclCore__namespace.discovery.authn.update();
  return {
    FclWcServicePlugin,
    client
  };
};
const initHelper = config => {
  if (typeof window === "undefined") {
    throw new Error("FCL Wallet Connect Plugin can only be initialized in the browser");
  }

  // Lazy load the SignClient
  //  - Initialize the client if it doesn't exist
  //  - If it does exist, return existing client
  //  - If existing client fails to initialize, reinitialize
  providerPromise = providerPromise.catch(() => null).then(_client => {
    if (_client) {
      return _client;
    } else {
      return initClient({
        projectId: config.projectId,
        metadata: config.metadata
      });
    }
  }).catch(e => {
    utilLogger.log({
      title: `WalletConnect Client Initialization Error`,
      message: e.message ? e.message : e,
      level: utilLogger.LEVELS.error
    });
    throw e;
  });
  const FclWcServicePlugin = makeServicePlugin(providerPromise, config);
  return {
    FclWcServicePlugin,
    providerPromise
  };
};

// Returns the SignClient instance used by this plugin if it has been initialized
async function getProvider() {
  return providerPromise.then(provider => {
    if (!provider) {
      throw new Error("WalletConnect client not initialized");
    }
    return provider;
  });
}

exports.FLOW_METHODS = FLOW_METHODS;
exports.SERVICE_PLUGIN_NAME = SERVICE_PLUGIN_NAME;
exports.WC_SERVICE_METHOD = WC_SERVICE_METHOD;
exports.createSessionProposal = createSessionProposal;
exports.getProvider = getProvider;
exports.init = init;
exports.initLazy = initLazy;
exports.request = request;
//# sourceMappingURL=index.js.map
