'use strict';

var fclCore = require('@onflow/fcl-core');
var config = require('@onflow/config');
var utilInvariant = require('@onflow/util-invariant');
var utilUid = require('@onflow/util-uid');
var fclWc = require('@onflow/fcl-wc');
var typedefs = require('@onflow/typedefs');
var utilRpc = require('@onflow/util-rpc');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fclWc__namespace = /*#__PURE__*/_interopNamespaceDefault(fclWc);

const AbortController = globalThis.AbortController || require("abort-controller");
function wrapAbortSignal(signal) {
  const controller = new AbortController();
  if (signal?.aborted) controller.abort();
  signal?.addEventListener("abort", () => controller.abort());
  return controller;
}

let DiscoveryNotification = /*#__PURE__*/function (DiscoveryNotification) {
  DiscoveryNotification["NOTIFY_QRCODE_CONNECTING"] = "notifyQrCodeConnecting";
  DiscoveryNotification["NOTIFY_QRCODE_CONNECTED"] = "notifyQrCodeConnected";
  DiscoveryNotification["NOTIFY_QRCODE_ERROR"] = "notifyQrCodeError";
  return DiscoveryNotification;
}({});
let FclRequest = /*#__PURE__*/function (FclRequest) {
  FclRequest["REQUEST_WALLETCONNECT_QRCODE"] = "requestWalletConnectQrCode";
  FclRequest["EXEC_SERVICE"] = "execService";
  return FclRequest;
}({});

const APPROVED = "APPROVED";

// RPC handler for handling service execution requests (e.g extension service)
const execServiceHandlerFactory = _ref => {
  let {
    onExecResult,
    execStrategyOpts,
    execStrategyArgs,
    abortSignal
  } = _ref;
  return async _ref2 => {
    let {
      service
    } = _ref2;
    try {
      const result = await fclCore.execStrategy({
        ...execStrategyOpts,
        service,
        config: execStrategyOpts.config,
        abortSignal
      },
      // Pass the rest of the arguments (protect against future changes)
      ...execStrategyArgs.slice(1));
      const status = fclCore.normalizePollingResponse(result)?.status || APPROVED;
      if (status === APPROVED) {
        // Propogrates the result to the execStrategy hook
        onExecResult(result);

        // Notify Discovery that the service was approved
        return null;
      } else {
        // Notify Discovery that the service was rejected
        throw new Error(result?.reason || "Service was declined");
      }
    } catch (e) {
      throw new Error(e?.message || "Service execution failed");
    }
  };
};

// RPC handler for handling WalletConnect QR code requests
const wcRequestHandlerFactory = _ref => {
  let {
    rpc,
    network,
    onExecResult,
    authnBody,
    abortSignal
  } = _ref;
  const watchQr = watchQrFactory({
    rpc,
    authnBody
  });
  return async _ref2 => {
    if (abortSignal.aborted) {
      throw new Error("Handler has been terminated");
    }
    const provider = await fclWc.getProvider();

    // Execute WC bypass if session is approved
    const {
      uri,
      approval
    } = await fclWc.createSessionProposal({
      provider,
      network
    });

    // Watch for QR code connection asynchronously
    watchQr({
      uri,
      approval,
      onExecResult
    });
    return {
      uri
    };
  };
};
function watchQrFactory(_ref3) {
  let {
    rpc,
    authnBody
  } = _ref3;
  return _ref4 => {
    let {
      uri,
      approval,
      onExecResult
    } = _ref4;
    // Watch for QR code connection & resolve callback if connected
    setTimeout(async () => {
      try {
        const provider = await fclWc.getProvider();
        const session = await approval();
        rpc.notify(DiscoveryNotification.NOTIFY_QRCODE_CONNECTING, {
          uri
        });
        const result = await fclWc.request({
          method: fclWc.FLOW_METHODS.FLOW_AUTHN,
          body: authnBody,
          session,
          provider
        });
        rpc.notify(DiscoveryNotification.NOTIFY_QRCODE_CONNECTED, {
          uri
        });
        onExecResult(result);
      } catch (e) {
        rpc.notify(DiscoveryNotification.NOTIFY_QRCODE_ERROR, {
          uri,
          error: e?.message
        });
      }
    }, 0);
  };
}

// Initialize the discovery RPC client
function createDiscoveryRpcClient(_ref) {
  let {
    onExecResult,
    body,
    opts,
    args,
    abortSignal
  } = _ref;
  const rpc = new utilRpc.RpcClient({
    notifications: []
  });
  rpc.on(FclRequest.REQUEST_WALLETCONNECT_QRCODE, wcRequestHandlerFactory({
    network: opts.config.client.network,
    rpc,
    onExecResult,
    authnBody: body,
    abortSignal
  }));
  rpc.on(FclRequest.EXEC_SERVICE, execServiceHandlerFactory({
    onExecResult,
    execStrategyOpts: opts,
    execStrategyArgs: args,
    abortSignal
  }));
  return {
    connect: rpc.connect.bind(rpc),
    receive: rpc.receive.bind(rpc)
  };
}

async function execDiscovery(_ref) {
  let {
    customRpc,
    opts,
    args,
    abortSignal
  } = _ref;
  // Update the discovery config to enable RPC support
  const discoveryConfig = {
    ...opts.config,
    client: {
      ...opts.config.client,
      discoveryRpcEnabled: true
    }
  };

  // Execute base discovery request
  return fclCore.execStrategy({
    ...opts,
    config: discoveryConfig,
    customRpc,
    abortSignal
  },
  // @ts-ignore - Pass the rest of the arguments (protect against future changes)
  ...args.slice(1));
}

const AUTHN_SERVICE_TYPE = "authn";

// Defines the execStrategy hook for Discovery Service
// Used to define custom service execution rules for the Discovery Service
async function execStrategyHook() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  const [opts] = args;
  const {
    body,
    abortSignal: baseAbortSignal,
    service
  } = opts;

  // Ensure the service type is "auth" for the execStrategyHook
  if (service?.type !== AUTHN_SERVICE_TYPE) {
    console.error(`ERROR: Invalid service type for FCL Discovery execStrategyHook, expected "${AUTHN_SERVICE_TYPE}" but got "${service?.type}"`);
    return fclCore.execStrategy(...args);
  }

  // Create an abort controller for this context
  // Either used to terminate WC bypass proposal loop or the base discovery request
  const abortController = wrapAbortSignal(baseAbortSignal);
  let discoveryPromise;
  const resultPromise = new Promise(async (resolve, reject) => {
    // Initialize the discovery RPC client
    const rpc = createDiscoveryRpcClient({
      onExecResult: resolve,
      body,
      opts,
      args,
      abortSignal: abortController.signal
    });

    // Execute the base discovery request
    discoveryPromise = execDiscovery({
      customRpc: rpc,
      opts,
      args,
      abortSignal: abortController.signal
    }).then(resolve, reject);
  });

  // Wait for the result promise to resolve or reject
  await resultPromise.catch(() => {});

  // Give Discovery time to cleanup
  await Promise.race([new Promise(resolve => setTimeout(resolve, 1000)), discoveryPromise]).catch(() => {});

  // Ensure the abort signal is propagated to all candidates on completion
  abortController.abort();

  // Return the result
  return resultPromise;
}

const isServer = typeof window === "undefined";
const getMetadata = config => {
  const appTitle = config.appDetailTitle;
  const appIcon = config.appDetailIcon;
  const appDescription = config.appDetailDescription;
  const appUrl = config.appDetailUrl;
  return {
    name: appTitle ?? document.title,
    description: appDescription ?? "",
    url: appUrl ?? window.location.origin,
    icons: appIcon ? [appIcon] : []
  };
};

// Use previous configuration to check for changes & notify the user that this is not possible
let lastConfig = null;

// Only the first configuration will be used
let hasLoaded = false;
function initFclWcLoader() {
  config.config.subscribe(async fullConfig => {
    const wcConfig = {
      walletConnectProjectId: fullConfig["walletconnect.projectId"],
      walletConnectDisableNotifications: fullConfig["walletconnect.disableNotifications"],
      appDetailTitle: fullConfig["app.detail.title"],
      appDetailIcon: fullConfig["app.detail.icon"],
      appDetailDescription: fullConfig["app.detail.description"],
      appDetailUrl: fullConfig["app.detail.url"]
    };
    loadFclWc(wcConfig);
  });
}
function loadFclWc(wcConfig) {
  // We cannot load WalletConnect plugin on server side
  if (isServer) {
    return;
  }
  const projectId = wcConfig.walletConnectProjectId;
  const disableNotifications = wcConfig.walletConnectDisableNotifications;

  // Check if the plugin is already loaded by this loader, but with different configuration
  // The plugin can only be loaded once
  const previousConfig = lastConfig;
  lastConfig = JSON.stringify(wcConfig, null, 2);
  if (hasLoaded) {
    if (previousConfig !== lastConfig) {
      console.warn(`FCL WalletConnect Plugin has been already loaded with different configuration. It is not possible to change the configuration after the plugin has been loaded.

Previous configuration:
${previousConfig}

Current configuration:
${lastConfig}`);
    }
    return;
  }

  // If the configuration is not set, we do not load the plugin
  const isConfigured = !!projectId;
  if (!isConfigured) {
    return;
  }
  utilInvariant.invariant(!!projectId, "FCL Configuration value for 'walletconnect.projectId' is required");

  // Check if the plugin is already loaded manually
  // Usually this won't happen as it is more likely that the plugin will be loaded by this loader
  // before the developer has a chance to load it manually, but it's good to check
  if (fclCore.pluginRegistry.getPlugins().has(fclWc__namespace.SERVICE_PLUGIN_NAME)) {
    if (!hasLoaded) {
      console.warn("It seems like the FCL WalletConnect plugins has been already loaded manually. This is no longer necessary, please see the documentation for more information.");
    }
    hasLoaded = true;
    return;
  }
  hasLoaded = true;

  // Load the plugin if not already loaded
  // We must lazy load the plugin to avoid race conditions
  // where the developer attempts to use the plugin before
  // our loader applies the configuration
  const {
    providerPromise: _clientPromise,
    FclWcServicePlugin
  } = fclWc__namespace.initLazy({
    projectId,
    metadata: getMetadata(wcConfig),
    disableNotifications: disableNotifications ?? undefined
  });
  fclCore.pluginRegistry.add([FclWcServicePlugin]);
}

const PLATFORM = "web";
const discoveryOpts = {
  execStrategy: execStrategyHook
};
function createFlowClient(params) {
  // TODO: Load into the global plugin registry for now.  This should be
  // refactored to use a plugin registry bound to the client instance
  // in the future.
  loadFclWc({
    walletConnectProjectId: params.walletconnectProjectId,
    walletConnectDisableNotifications: params.walletconnectDisableNotifications,
    appDetailTitle: params.appDetailTitle,
    appDetailIcon: params.appDetailIcon,
    appDetailDescription: params.appDetailDescription,
    appDetailUrl: params.appDetailUrl
  });
  const fclCore$1 = fclCore.createFlowClientCore({
    flowNetwork: params.flowNetwork,
    flowJson: params.flowJson,
    accessNodeUrl: params.accessNodeUrl,
    computeLimit: params.computeLimit || 9999,
    transport: params.transport,
    platform: PLATFORM,
    storage: params.storage || LOCAL_STORAGE,
    discovery: discoveryOpts,
    discoveryWalletMethod: params.discoveryWalletMethod || "IFRAME/RPC",
    discoveryAuthnEndpoint: params.discoveryAuthnEndpoint,
    discoveryAuthnInclude: params.discoveryAuthnInclude,
    customResolver: params.customResolver,
    customDecoders: params.customDecoders,
    discoveryWallet: params.discoveryWallet,
    appDetailTitle: params.appDetailTitle,
    appDetailIcon: params.appDetailIcon,
    appDetailDescription: params.appDetailDescription,
    appDetailUrl: params.appDetailUrl,
    serviceOpenIdScopes: params.serviceOpenIdScopes
  });
  return {
    ...fclCore$1
  };
}

const FRAME = "FCL_IFRAME";
const FRAME_STYLES = `
  position:fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  height: 100%;
  width: 100vw;
  display:block;
  background:rgba(0,0,0,0.25);
  z-index: 2147483647;
  box-sizing: border-box;
  color-scheme: light;
`;
function renderFrame(src) {
  utilInvariant.invariant(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
    src
  });
  const $frame = document.createElement("iframe");
  $frame.src = src;
  $frame.id = FRAME;
  $frame.allow = "usb *; hid *; clipboard-write";
  $frame.frameBorder = "0";
  $frame.style.cssText = FRAME_STYLES;
  document.body.append($frame);
  const unmount = () => {
    if (document.getElementById(FRAME)) {
      document.getElementById(FRAME).remove();
    }
  };
  return [$frame.contentWindow, unmount];
}

const POP = "FCL_POP";
let popup = null;
let previousUrl$1 = null;
function popupWindow(url, windowName, win, w, h) {
  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
  const popup = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);
  if (!popup) throw new Error("Popup failed to open (was it blocked by a popup blocker?)");
  return popup;
}
function renderPop(src) {
  if (popup == null || popup?.closed) {
    popup = popupWindow(src, POP, window, 640, 770);
  } else if (previousUrl$1 !== src) {
    popup.location.replace(src);
    popup.focus();
  } else {
    popup.focus();
  }
  previousUrl$1 = src;
  const unmount = () => {
    if (popup && !popup.closed) {
      popup.close();
    }
    popup = null;
  };
  return [popup, unmount];
}

let tab$1 = null;
let previousUrl = null;
function renderTab(src) {
  if (tab$1 == null || tab$1?.closed) {
    tab$1 = window.open(src, "_blank");
    if (!tab$1) throw new Error("Tab failed to open (was it blocked by the browser?)");
  } else if (previousUrl !== src) {
    tab$1.location.replace(src);
    tab$1.focus();
  } else {
    tab$1.focus();
  }
  previousUrl = src;
  const unmount = () => {
    if (tab$1 && !tab$1.closed) {
      tab$1.close();
    }
    tab$1 = null;
  };
  return [tab$1, unmount];
}

const getDefaultConfig = () => {
  return {
    "discovery.wallet.method.default": "IFRAME/RPC"
  };
};

const noop$3 = () => {};
function frame(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$3,
    close: noop$3
  };
  const onClose = opts.onClose || noop$3;
  const onMessage = opts.onMessage || noop$3;
  const onReady = opts.onReady || noop$3;
  const onResponse = opts.onResponse || noop$3;
  const onCustomRpc = opts.onCustomRpc || noop$3;
  let $frame, unmount;
  const handler = fclCore.buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource: () => $frame
  });
  window.addEventListener("message", handler);
  [$frame, unmount] = renderFrame(fclCore.serviceEndpoint(service));
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      unmount();
      onClose();
    } catch (error) {
      console.error("Frame Close Error", error);
    }
  }
  function send(msg) {
    try {
      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Frame Send Error", msg, error);
    }
  }
}

const VERSION = "1.20.0";

function execIframeRPC(_ref) {
  let {
    service,
    body,
    config,
    customRpc,
    abortSignal,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = utilUid.uid();
    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    const {
      close
    } = frame(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            type: "FCL:VIEW:READY:RESPONSE",
            fclVersion: VERSION,
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params],
              deprecated: {
                message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });
          }
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                payload: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = fclCore.normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = fclCore.normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        reject(`Declined: Aborted`);
        close();
      }
      abortSignal.addEventListener("abort", () => {
        reject(`Declined: Aborted`);
        close();
      });
    }
  });
}

const noop$2 = () => {};
function pop(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$2,
    close: noop$2
  };
  const onClose = opts.onClose || noop$2;
  const onMessage = opts.onMessage || noop$2;
  const onReady = opts.onReady || noop$2;
  const onResponse = opts.onResponse || noop$2;
  const onCustomRpc = opts.onCustomRpc || noop$2;
  let $pop, unmount;
  const handler = fclCore.buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource: () => $pop
  });
  window.addEventListener("message", handler);
  [$pop, unmount] = renderPop(fclCore.serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($pop && $pop.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Popup Close Error", error);
    }
  }
  function send(msg) {
    try {
      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Popup Send Error", msg, error);
    }
  }
}

function execPopRPC(_ref) {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = utilUid.uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    const {
      close
    } = pop(service, {
      customRpc,
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                payload: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = fclCore.normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = fclCore.normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        reject(`Declined: Aborted`);
        close();
      }
      abortSignal.addEventListener("abort", () => {
        reject(`Declined: Aborted`);
        close();
      });
    }
  });
}

const noop$1 = () => {};
function tab(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$1,
    close: noop$1
  };
  const onClose = opts.onClose || noop$1;
  const onMessage = opts.onMessage || noop$1;
  const onReady = opts.onReady || noop$1;
  const onResponse = opts.onResponse || noop$1;
  const onCustomRpc = opts.onCustomRpc || noop$1;
  let $tab, unmount;
  const handler = fclCore.buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource: () => $tab
  });
  window.addEventListener("message", handler);
  [$tab, unmount] = renderTab(fclCore.serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($tab && $tab.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Tab Close Error", error);
    }
  }
  function send(msg) {
    try {
      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Tab Send Error", msg, error);
    }
  }
}

function execTabRPC(_ref) {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = utilUid.uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    const {
      close
    } = tab(service, {
      customRpc,
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                payload: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = fclCore.normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = fclCore.normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        close();
        reject(`Declined: Aborted`);
      }
      abortSignal.addEventListener("abort", () => {
        close();
        reject(`Declined: Aborted`);
      });
    }
  });
}

const noop = () => {};
function extension(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop,
    close: noop
  };
  const onClose = opts.onClose || noop;
  const onMessage = opts.onMessage || noop;
  const onReady = opts.onReady || noop;
  const onResponse = opts.onResponse || noop;
  const onCustomRpc = opts.onCustomRpc || noop;
  const handler = fclCore.buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc
  });
  window.addEventListener("message", handler);
  send({
    service
  });
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      onClose();
    } catch (error) {
      console.error("Ext Close Error", error);
    }
  }
  function send(msg) {
    try {
      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Ext Send Error", msg, error);
    }
  }
}

function execExtRPC(_ref) {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const {
      close
    } = extension(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                body: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = fclCore.normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execExtRPC onResponse error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        close();
        reject(`Declined: Aborted`);
      }
      abortSignal.addEventListener("abort", () => {
        close();
        reject(`Declined: Aborted`);
      });
    }
  });
}

const NOT_IMPLEMENTED = () => {
  throw new Error("Strategy util has not been implemented on this platform");
};
const VIEWS = {
  "VIEW/IFRAME": renderFrame,
  "VIEW/POP": renderPop,
  "VIEW/TAB": renderTab,
  "VIEW/MOBILE_BROWSER": NOT_IMPLEMENTED,
  "VIEW/DEEPLINK": NOT_IMPLEMENTED
};
async function execLocal(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    serviceEndpoint: () => {}
  };
  const {
    serviceEndpoint
  } = opts;
  try {
    return VIEWS[service.method](serviceEndpoint(service), opts);
  } catch (error) {
    console.error("execLocal({service, opts = {}})", error, {
      service,
      opts
    });
    throw error;
  }
}

const coreStrategies = {
  [fclCore.CORE_STRATEGIES["HTTP/RPC"]]: fclCore.getExecHttpPost(execLocal),
  [fclCore.CORE_STRATEGIES["HTTP/POST"]]: fclCore.getExecHttpPost(execLocal),
  [fclCore.CORE_STRATEGIES["IFRAME/RPC"]]: execIframeRPC,
  [fclCore.CORE_STRATEGIES["POP/RPC"]]: execPopRPC,
  [fclCore.CORE_STRATEGIES["TAB/RPC"]]: execTabRPC,
  [fclCore.CORE_STRATEGIES["EXT/RPC"]]: execExtRPC
};

const isServerSide = () => typeof window === "undefined";
const safeParseJSON = str => {
  if (str == null) return null;
  try {
    return JSON.parse(str);
  } catch (error) {
    return null;
  }
};
const SESSION_STORAGE = {
  can: !isServerSide() && !!window.sessionStorage,
  get: async key => safeParseJSON(sessionStorage.getItem(key)),
  put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))
};
const LOCAL_STORAGE = {
  can: !isServerSide() && !!window.localStorage,
  get: async key => safeParseJSON(localStorage.getItem(key)),
  put: async (key, value) => localStorage.setItem(key, JSON.stringify(value))
};

/**
 * @description The main current user service for managing user authentication and authorization in Flow applications.
 * This service provides a complete interface for wallet connections, user sessions, transaction signing, and user data management.
 * It handles the complexity of connecting to various FCL-compatible wallets, managing authentication state, and providing
 * authorization functions for transaction signing.
 *
 * The currentUser service is configured for web platforms and uses the browser's localStorage by default for session persistence.
 * It integrates with Flow's discovery service to enable wallet selection and supports both authentication and re-authentication flows.
 *
 * This service is reactive and provides subscription capabilities to monitor authentication state changes in real-time.
 * All wallet interactions are handled through FCL's standardized protocols, ensuring compatibility with the Flow ecosystem.
 *
 * Returns an object with the following methods:
 * ```typescript
 * {
 *   authenticate,        // Authenticates the user via FCL-compatible wallets
 *   unauthenticate,      // Logs out the current user and clears session data
 *   authorization,       // Produces authorization details for transaction signing
 *   signUserMessage,     // Signs arbitrary messages with the user's wallet
 *   subscribe,           // Subscribes to authentication state changes
 *   snapshot,            // Returns the current user object snapshot
 *   resolveArgument      // Resolves the current user as a transaction argument
 * }
 * ```
 *
 * @returns A CurrentUserService object
 *
 * @example
 * // Basic authentication flow
 * import * as fcl from "@onflow/fcl"
 *
 * // Configure FCL
 * fcl.config({
 *   "accessNode.api": "https://rest-testnet.onflow.org",
 *   "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn",
 *   "flow.network": "testnet"
 * })
 *
 * // Authenticate user
 * const user = await fcl.currentUser.authenticate()
 * console.log("User authenticated:", user.addr)
 *
 * // Check authentication status
 * const currentUser = await fcl.currentUser.snapshot()
 * if (currentUser.loggedIn) {
 *   console.log("User is logged in:", currentUser.addr)
 * }
 *
 * // Subscribe to authentication state changes
 * import * as fcl from "@onflow/fcl"
 *
 * const unsubscribe = fcl.currentUser.subscribe((user) => {
 *   if (user.loggedIn) {
 *     console.log("User logged in:", user.addr)
 *     document.getElementById("login-btn").style.display = "none"
 *     document.getElementById("logout-btn").style.display = "block"
 *   } else {
 *     console.log("User logged out")
 *     document.getElementById("login-btn").style.display = "block"
 *     document.getElementById("logout-btn").style.display = "none"
 *   }
 * })
 * // Clean up subscription when component unmounts
 * window.addEventListener("beforeunload", () => unsubscribe())
 */
const currentUser = fclCore.getCurrentUser({
  platform: "web",
  discovery: discoveryOpts,
  getStorageProvider: async () => {
    return (await config.config.get("fcl.storage")) || LOCAL_STORAGE;
  }
});

/**
 * @description A transaction execution function that allows you to submit Cadence transactions to the Flow blockchain
 * to mutate on-chain state. This function handles the complete transaction lifecycle including building, signing, and
 * sending transactions to Flow. It provides a high-level interface that abstracts the complexity of transaction
 * construction while offering flexibility for advanced use cases.
 *
 * The mutate function automatically handles authorization using the current authenticated user by default, but allows
 * for custom authorization functions to be specified for different transaction roles (proposer, payer, authorizer).
 * It supports both simple single-party transactions and complex multi-party transactions with different signatories.
 *
 * This function integrates with FCL's address replacement system, allowing you to use placeholder addresses in your
 * Cadence code that are replaced with actual addresses at execution time. It also supports Interaction Templates
 * for standardized transaction execution patterns.
 *
 * The mutate function accepts a configuration object with the following structure:
 * ```typescript
 * {
 *   cadence?: string,                    // The Cadence transaction code to execute (required if template not provided)
 *   args?: Function,                     // Function that returns an array of arguments for the transaction
 *   template?: any,                      // Interaction Template object or URL for standardized transactions
 *   limit?: number,                      // Compute (gas) limit for the transaction execution
 *   authz?: AccountAuthorization,        // Authorization function for all signatory roles (proposer, payer, authorizer)
 *   proposer?: AccountAuthorization,     // Specific authorization function for the proposer role
 *   payer?: AccountAuthorization,        // Specific authorization function for the payer role
 *   authorizations?: AccountAuthorization[]  // Array of authorization functions for authorizer roles
 * }
 * ```
 *
 * @param opts Transaction configuration options
 *
 * @returns Promise that resolves to the transaction ID (txId) when the transaction is submitted
 *
 * @throws Throws an error if transaction validation fails, required configuration is missing,
 * or transaction execution encounters an error
 *
 * @example
 * // Basic transaction submission
 * import * as fcl from "@onflow/fcl"
 *
 * // Configure FCL first
 * fcl.config({
 *   "accessNode.api": "https://rest-testnet.onflow.org",
 *   "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn",
 *   "flow.network": "testnet"
 * })
 *
 * // Authenticate user
 * await fcl.authenticate()
 *
 * // Submit a basic transaction
 * const txId = await fcl.mutate({
 *   cadence: `
 *     transaction(message: String) {
 *       prepare(account: AuthAccount) {
 *         log("Transaction executed by: ".concat(account.address.toString()))
 *         log("Message: ".concat(message))
 *       }
 *     }
 *   `,
 *   args: (arg, t) => [
 *     arg("Hello Flow!", t.String)
 *   ],
 *   limit: 50
 * })
 *
 * console.log("Transaction submitted:", txId)
 */
const mutate = fclCore.getMutate(currentUser);

/**
 * @description Calling this method will authenticate the current user via any wallet that supports FCL. Once called, FCL will initiate communication with the configured `discovery.wallet` endpoint which lets the user select a wallet to authenticate with. Once the wallet provider has authenticated the user, FCL will set the values on the current user object for future use and authorization.
 *
 * This method can only be used in web browsers.
 *
 * `discovery.wallet` value must be set in the configuration before calling this method. See FCL Configuration.
 *
 * The default discovery endpoint will open an iframe overlay to let the user choose a supported wallet.
 *
 * `authenticate` can also take a service returned from discovery with `fcl.authenticate({ service })`.
 *
 * @param opts Authentication options
 * @param opts.service Optional service to use for authentication. A service returned from discovery can be passed here.
 * @param opts.redir Optional redirect flag. Defaults to false.
 * @param opts.forceReauth Optional force re-authentication flag. Defaults to false.
 * @returns Promise that resolves to the authenticated CurrentUser object or undefined
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * fcl
 *   .config()
 *   .put('accessNode.api', 'https://rest-testnet.onflow.org')
 *   .put('discovery.wallet', 'https://fcl-discovery.onflow.org/testnet/authn');
 * // anywhere on the page
 * fcl.authenticate();
 */
const authenticate = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};

/**
 * @description Logs out the current user and sets the values on the current user object to null.
 *
 * This method can only be used in web browsers.
 *
 * The current user must be authenticated first.
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * fcl.config().put('accessNode.api', 'https://rest-testnet.onflow.org');
 * // first authenticate to set current user
 * fcl.authenticate();
 * // ... somewhere else & sometime later
 * fcl.unauthenticate();
 * // fcl.currentUser.loggedIn === null
 */
const unauthenticate = () => currentUser().unauthenticate();

/**
 * @description A convenience method that calls `fcl.unauthenticate()` and then `fcl.authenticate()` for the current user.
 *
 * This method can only be used in web browsers.
 *
 * The current user must be authenticated first.
 *
 * @param opts Authentication options passed to authenticate method
 * @param opts.service Optional service to use for authentication
 * @param opts.redir Optional redirect flag. Defaults to false.
 * @param opts.forceReauth Optional force re-authentication flag. Defaults to false.
 * @returns Promise that resolves to the authenticated CurrentUser object or undefined
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * // first authenticate to set current user
 * fcl.authenticate();
 * // ... somewhere else & sometime later
 * fcl.reauthenticate();
 * // logs out user and opens up login/sign-up flow
 */
const reauthenticate = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  currentUser().unauthenticate();
  return currentUser().authenticate(opts);
};

/**
 * @description A convenience method that calls and is equivalent to `fcl.authenticate()`.
 *
 * This method can only be used in web browsers.
 *
 * @param opts Authentication options passed to authenticate method
 * @param opts.service Optional service to use for authentication
 * @param opts.redir Optional redirect flag. Defaults to false.
 * @param opts.forceReauth Optional force re-authentication flag. Defaults to false.
 * @returns Promise that resolves to the authenticated CurrentUser object or undefined
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * fcl.config()
 *   .put('accessNode.api', 'https://rest-testnet.onflow.org')
 *   .put('discovery.wallet', 'https://fcl-discovery.onflow.org/testnet/authn');
 *
 * // User clicks sign up button
 * fcl.signUp();
 */
const signUp = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};

/**
 * @description A convenience method that calls and is equivalent to `fcl.authenticate()`.
 *
 * This method can only be used in web browsers.
 *
 * @param opts Authentication options passed to authenticate method
 * @param opts.service Optional service to use for authentication
 * @param opts.redir Optional redirect flag. Defaults to false.
 * @param opts.forceReauth Optional force re-authentication flag. Defaults to false.
 * @returns Promise that resolves to the authenticated CurrentUser object or undefined
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * fcl.config()
 *   .put('accessNode.api', 'https://rest-testnet.onflow.org')
 *   .put('discovery.wallet', 'https://fcl-discovery.onflow.org/testnet/authn');
 *
 * // User clicks log in button
 * fcl.logIn();
 */
const logIn = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};

/**
 * @description A convenience method that produces the needed authorization details for the current user to submit transactions to Flow. It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.
 *
 * You can replace this function with your own authorization function if needed.
 *
 * @returns An object containing the necessary details from the current user to authorize a transaction in any role.
 *
 * @example
 * import * as fcl from '@onflow/fcl';
 * // login somewhere before
 * fcl.authenticate();
 * // once logged in authz will produce values
 * console.log(fcl.authz);
 * // prints {addr, signingFunction, keyId, sequenceNum} from the current authenticated user.
 *
 * const txId = await fcl.mutate({
 *   cadence: `
 *     import Profile from 0xba1132bc08f82fe2
 *
 *     transaction(name: String) {
 *       prepare(account: auth(BorrowValue) &Account) {
 *         account.storage.borrow<&{Profile.Owner}>(from: Profile.privatePath)!.setName(name)
 *       }
 *     }
 *   `,
 *   args: (arg, t) => [arg('myName', t.String)],
 *   proposer: fcl.authz, // optional - default is fcl.authz
 *   payer: fcl.authz, // optional - default is fcl.authz
 *   authorizations: [fcl.authz], // optional - default is [fcl.authz]
 * });
 *
 * @note The default values for `proposer`, `payer`, and `authorizations` are already `fcl.authz` so there is no need to include these parameters, it is shown only for example purposes.
 */
const authz = currentUser().authorization;
config.config(getDefaultConfig());
fclCore.initServiceRegistry({
  coreStrategies
});

// Automatically load fcl-wc plugin
// Based on the user's config
initFclWcLoader();

Object.defineProperty(exports, "AppUtils", {
  enumerable: true,
  get: function () { return fclCore.AppUtils; }
});
Object.defineProperty(exports, "InteractionTemplateUtils", {
  enumerable: true,
  get: function () { return fclCore.InteractionTemplateUtils; }
});
Object.defineProperty(exports, "TestUtils", {
  enumerable: true,
  get: function () { return fclCore.TestUtils; }
});
Object.defineProperty(exports, "TransactionError", {
  enumerable: true,
  get: function () { return fclCore.TransactionError; }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () { return fclCore.VERSION; }
});
Object.defineProperty(exports, "WalletUtils", {
  enumerable: true,
  get: function () { return fclCore.WalletUtils; }
});
Object.defineProperty(exports, "account", {
  enumerable: true,
  get: function () { return fclCore.account; }
});
Object.defineProperty(exports, "arg", {
  enumerable: true,
  get: function () { return fclCore.arg; }
});
Object.defineProperty(exports, "args", {
  enumerable: true,
  get: function () { return fclCore.args; }
});
Object.defineProperty(exports, "atBlockHeight", {
  enumerable: true,
  get: function () { return fclCore.atBlockHeight; }
});
Object.defineProperty(exports, "atBlockId", {
  enumerable: true,
  get: function () { return fclCore.atBlockId; }
});
Object.defineProperty(exports, "authorization", {
  enumerable: true,
  get: function () { return fclCore.authorization; }
});
Object.defineProperty(exports, "authorizations", {
  enumerable: true,
  get: function () { return fclCore.authorizations; }
});
Object.defineProperty(exports, "block", {
  enumerable: true,
  get: function () { return fclCore.block; }
});
Object.defineProperty(exports, "build", {
  enumerable: true,
  get: function () { return fclCore.build; }
});
Object.defineProperty(exports, "cadence", {
  enumerable: true,
  get: function () { return fclCore.cadence; }
});
Object.defineProperty(exports, "cdc", {
  enumerable: true,
  get: function () { return fclCore.cdc; }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () { return fclCore.config; }
});
Object.defineProperty(exports, "createSignableVoucher", {
  enumerable: true,
  get: function () { return fclCore.createSignableVoucher; }
});
Object.defineProperty(exports, "decode", {
  enumerable: true,
  get: function () { return fclCore.decode; }
});
Object.defineProperty(exports, "discovery", {
  enumerable: true,
  get: function () { return fclCore.discovery; }
});
Object.defineProperty(exports, "display", {
  enumerable: true,
  get: function () { return fclCore.display; }
});
Object.defineProperty(exports, "events", {
  enumerable: true,
  get: function () { return fclCore.events; }
});
Object.defineProperty(exports, "flowEmulator", {
  enumerable: true,
  get: function () { return fclCore.flowEmulator; }
});
Object.defineProperty(exports, "flowMainnet", {
  enumerable: true,
  get: function () { return fclCore.flowMainnet; }
});
Object.defineProperty(exports, "flowTestnet", {
  enumerable: true,
  get: function () { return fclCore.flowTestnet; }
});
Object.defineProperty(exports, "getAccount", {
  enumerable: true,
  get: function () { return fclCore.getAccount; }
});
Object.defineProperty(exports, "getBlock", {
  enumerable: true,
  get: function () { return fclCore.getBlock; }
});
Object.defineProperty(exports, "getBlockHeader", {
  enumerable: true,
  get: function () { return fclCore.getBlockHeader; }
});
Object.defineProperty(exports, "getChainId", {
  enumerable: true,
  get: function () { return fclCore.getChainId; }
});
Object.defineProperty(exports, "getCollection", {
  enumerable: true,
  get: function () { return fclCore.getCollection; }
});
Object.defineProperty(exports, "getEvents", {
  enumerable: true,
  get: function () { return fclCore.getEvents; }
});
Object.defineProperty(exports, "getEventsAtBlockHeightRange", {
  enumerable: true,
  get: function () { return fclCore.getEventsAtBlockHeightRange; }
});
Object.defineProperty(exports, "getEventsAtBlockIds", {
  enumerable: true,
  get: function () { return fclCore.getEventsAtBlockIds; }
});
Object.defineProperty(exports, "getNetworkParameters", {
  enumerable: true,
  get: function () { return fclCore.getNetworkParameters; }
});
Object.defineProperty(exports, "getNodeVersionInfo", {
  enumerable: true,
  get: function () { return fclCore.getNodeVersionInfo; }
});
Object.defineProperty(exports, "getTransaction", {
  enumerable: true,
  get: function () { return fclCore.getTransaction; }
});
Object.defineProperty(exports, "getTransactionStatus", {
  enumerable: true,
  get: function () { return fclCore.getTransactionStatus; }
});
Object.defineProperty(exports, "invariant", {
  enumerable: true,
  get: function () { return fclCore.invariant; }
});
Object.defineProperty(exports, "isBad", {
  enumerable: true,
  get: function () { return fclCore.isBad; }
});
Object.defineProperty(exports, "isOk", {
  enumerable: true,
  get: function () { return fclCore.isOk; }
});
Object.defineProperty(exports, "limit", {
  enumerable: true,
  get: function () { return fclCore.limit; }
});
Object.defineProperty(exports, "nodeVersionInfo", {
  enumerable: true,
  get: function () { return fclCore.nodeVersionInfo; }
});
Object.defineProperty(exports, "param", {
  enumerable: true,
  get: function () { return fclCore.param; }
});
Object.defineProperty(exports, "params", {
  enumerable: true,
  get: function () { return fclCore.params; }
});
Object.defineProperty(exports, "payer", {
  enumerable: true,
  get: function () { return fclCore.payer; }
});
Object.defineProperty(exports, "ping", {
  enumerable: true,
  get: function () { return fclCore.ping; }
});
Object.defineProperty(exports, "pipe", {
  enumerable: true,
  get: function () { return fclCore.pipe; }
});
Object.defineProperty(exports, "pluginRegistry", {
  enumerable: true,
  get: function () { return fclCore.pluginRegistry; }
});
Object.defineProperty(exports, "proposer", {
  enumerable: true,
  get: function () { return fclCore.proposer; }
});
Object.defineProperty(exports, "query", {
  enumerable: true,
  get: function () { return fclCore.query; }
});
Object.defineProperty(exports, "queryRaw", {
  enumerable: true,
  get: function () { return fclCore.queryRaw; }
});
Object.defineProperty(exports, "ref", {
  enumerable: true,
  get: function () { return fclCore.ref; }
});
Object.defineProperty(exports, "sansPrefix", {
  enumerable: true,
  get: function () { return fclCore.sansPrefix; }
});
Object.defineProperty(exports, "script", {
  enumerable: true,
  get: function () { return fclCore.script; }
});
Object.defineProperty(exports, "send", {
  enumerable: true,
  get: function () { return fclCore.send; }
});
Object.defineProperty(exports, "serialize", {
  enumerable: true,
  get: function () { return fclCore.serialize; }
});
Object.defineProperty(exports, "subscribe", {
  enumerable: true,
  get: function () { return fclCore.subscribe; }
});
Object.defineProperty(exports, "subscribeEvents", {
  enumerable: true,
  get: function () { return fclCore.subscribeEvents; }
});
Object.defineProperty(exports, "subscribeRaw", {
  enumerable: true,
  get: function () { return fclCore.subscribeRaw; }
});
Object.defineProperty(exports, "t", {
  enumerable: true,
  get: function () { return fclCore.t; }
});
Object.defineProperty(exports, "transaction", {
  enumerable: true,
  get: function () { return fclCore.transaction; }
});
Object.defineProperty(exports, "tx", {
  enumerable: true,
  get: function () { return fclCore.tx; }
});
Object.defineProperty(exports, "validator", {
  enumerable: true,
  get: function () { return fclCore.validator; }
});
Object.defineProperty(exports, "verifyUserSignatures", {
  enumerable: true,
  get: function () { return fclCore.verifyUserSignatures; }
});
Object.defineProperty(exports, "voucherIntercept", {
  enumerable: true,
  get: function () { return fclCore.voucherIntercept; }
});
Object.defineProperty(exports, "voucherToTxId", {
  enumerable: true,
  get: function () { return fclCore.voucherToTxId; }
});
Object.defineProperty(exports, "why", {
  enumerable: true,
  get: function () { return fclCore.why; }
});
Object.defineProperty(exports, "withPrefix", {
  enumerable: true,
  get: function () { return fclCore.withPrefix; }
});
exports.LOCAL_STORAGE = LOCAL_STORAGE;
exports.SESSION_STORAGE = SESSION_STORAGE;
exports.authenticate = authenticate;
exports.authz = authz;
exports.createFlowClient = createFlowClient;
exports.currentUser = currentUser;
exports.logIn = logIn;
exports.mutate = mutate;
exports.reauthenticate = reauthenticate;
exports.signUp = signUp;
exports.unauthenticate = unauthenticate;
Object.keys(typedefs).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return typedefs[k]; }
  });
});
//# sourceMappingURL=fcl.js.map
